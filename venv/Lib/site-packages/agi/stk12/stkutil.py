################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################ 

__all__ = ["AgCROrientationAzEl", "AgCROrientationEulerAngles", "AgCROrientationOffsetCart", "AgCROrientationQuaternion", 
"AgCROrientationYPRAngles", "AgCartesian", "AgCartesian2Vector", "AgCartesian3Vector", "AgConversionUtility", "AgCylindrical", 
"AgDate", "AgDirection", "AgDirectionEuler", "AgDirectionPR", "AgDirectionRADec", "AgDirectionXYZ", "AgDoublesCollection", 
"AgEAzElAboutBoresight", "AgECoordinateSystem", "AgEDirectionType", "AgEEulerDirectionSequence", "AgEEulerOrientationSequence", 
"AgEExecMultiCmdResultAction", "AgEFillStyle", "AgELineStyle", "AgELogMsgDispID", "AgELogMsgType", "AgEOrbitStateType", 
"AgEOrientationType", "AgEPRSequence", "AgEPositionType", "AgEPropertyInfoValueType", "AgEYPRAnglesSequence", "AgExecCmdResult", 
"AgExecMultiCmdResult", "AgGeocentric", "AgGeodetic", "AgOrientation", "AgOrientationAzEl", "AgOrientationEulerAngles", 
"AgOrientationQuaternion", "AgOrientationYPRAngles", "AgPlanetocentric", "AgPlanetodetic", "AgPosition", "AgPropertyInfo", 
"AgPropertyInfoCollection", "AgQuantity", "AgRuntimeTypeInfo", "AgSpherical", "AgUnitPrefsDim", "AgUnitPrefsDimCollection", 
"AgUnitPrefsUnit", "AgUnitPrefsUnitCollection", "IAgCartesian", "IAgCartesian2Vector", "IAgCartesian3Vector", "IAgConversionUtility", 
"IAgCylindrical", "IAgDate", "IAgDirection", "IAgDirectionEuler", "IAgDirectionPR", "IAgDirectionRADec", "IAgDirectionXYZ", 
"IAgDoublesCollection", "IAgExecCmdResult", "IAgExecMultiCmdResult", "IAgGeocentric", "IAgGeodetic", "IAgLocationData", 
"IAgOrbitState", "IAgOrientation", "IAgOrientationAzEl", "IAgOrientationEulerAngles", "IAgOrientationPositionOffset", "IAgOrientationQuaternion", 
"IAgOrientationYPRAngles", "IAgPlanetocentric", "IAgPlanetodetic", "IAgPosition", "IAgPropertyInfo", "IAgPropertyInfoCollection", 
"IAgQuantity", "IAgRuntimeTypeInfo", "IAgRuntimeTypeInfoProvider", "IAgSpherical", "IAgUnitPrefsDim", "IAgUnitPrefsDimCollection", 
"IAgUnitPrefsUnit", "IAgUnitPrefsUnitCollection"]

import typing

from ctypes   import byref, POINTER
from datetime import datetime
from enum     import IntEnum, IntFlag

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .internal  import dataanalysisutil as agdata
from .utilities import colors           as agcolor
from .internal.comutil     import IUnknown, IDispatch, IPictureDisp
from .internal.apiutil     import interface_proxy, enumerator_proxy, out_arg
from .internal.eventutil   import *
from .utilities.exceptions import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgEPositionType(IntEnum):
    """Facility/place/target position types."""
    # Cartesian: position specified in terms of the X, Y and Z components of the object's position vector, where the Z-axis points to the North pole, and the X-axis crosses 0 degrees latitude/0 degrees longitude.
    eCartesian = 0x0
    # Cylindrical: position specified in terms of radius (polar), longitude (measured in degrees from -360.0 degrees to +360.0 degrees), and the Z component of the object's position vector.
    eCylindrical = 0x1
    # Geocentric: position specified in terms of latitude (spherical latitude of the sub-point on the surface of the Earth), longitude and altitude.
    eGeocentric = 0x2
    # Geodetic: position specified in terms of latitude (angle between the normal to the reference ellipsoid and the equatorial plane), longitude and altitude.
    eGeodetic = 0x3
    # Spherical: position specified in terms of latitude (spherical latitude of the sub-point on the surface of the Earth), longitude and radius (distance of the object from the center of the Earth).
    eSpherical = 0x4
    # Planetocentric: position specified in terms of latitude (spherical latitude of the sub-point on the surface of the Earth), longitude and altitude.
    ePlanetocentric = 0x5
    # Planetodetic: position specified in terms of latitude (angle between the normal to the reference ellipsoid and the equatorial plane), longitude and altitude.
    ePlanetodetic = 0x6

AgEPositionType.eCartesian.__doc__ = "Cartesian: position specified in terms of the X, Y and Z components of the object's position vector, where the Z-axis points to the North pole, and the X-axis crosses 0 degrees latitude/0 degrees longitude."
AgEPositionType.eCylindrical.__doc__ = "Cylindrical: position specified in terms of radius (polar), longitude (measured in degrees from -360.0 degrees to +360.0 degrees), and the Z component of the object's position vector."
AgEPositionType.eGeocentric.__doc__ = "Geocentric: position specified in terms of latitude (spherical latitude of the sub-point on the surface of the Earth), longitude and altitude."
AgEPositionType.eGeodetic.__doc__ = "Geodetic: position specified in terms of latitude (angle between the normal to the reference ellipsoid and the equatorial plane), longitude and altitude."
AgEPositionType.eSpherical.__doc__ = "Spherical: position specified in terms of latitude (spherical latitude of the sub-point on the surface of the Earth), longitude and radius (distance of the object from the center of the Earth)."
AgEPositionType.ePlanetocentric.__doc__ = "Planetocentric: position specified in terms of latitude (spherical latitude of the sub-point on the surface of the Earth), longitude and altitude."
AgEPositionType.ePlanetodetic.__doc__ = "Planetodetic: position specified in terms of latitude (angle between the normal to the reference ellipsoid and the equatorial plane), longitude and altitude."

agcls.AgTypeNameMap["AgEPositionType"] = AgEPositionType

class AgEEulerDirectionSequence(IntEnum):
    """Euler direction sequences."""
    # 12 sequence.
    e12 = 0
    # 21 sequence.
    e21 = 1
    # 31 sequence.
    e31 = 2
    # 32 sequence.
    e32 = 3

AgEEulerDirectionSequence.e12.__doc__ = "12 sequence."
AgEEulerDirectionSequence.e21.__doc__ = "21 sequence."
AgEEulerDirectionSequence.e31.__doc__ = "31 sequence."
AgEEulerDirectionSequence.e32.__doc__ = "32 sequence."

agcls.AgTypeNameMap["AgEEulerDirectionSequence"] = AgEEulerDirectionSequence

class AgEDirectionType(IntEnum):
    """Direction options for aligned and constrained vectors."""
    # Euler B and C angles.
    eDirEuler = 0
    # Pitch and Roll angles.
    eDirPR = 1
    # Spherical elements: Right Ascension and Declination.
    eDirRADec = 2
    # Cartesian elements.
    eDirXYZ = 3

AgEDirectionType.eDirEuler.__doc__ = "Euler B and C angles."
AgEDirectionType.eDirPR.__doc__ = "Pitch and Roll angles."
AgEDirectionType.eDirRADec.__doc__ = "Spherical elements: Right Ascension and Declination."
AgEDirectionType.eDirXYZ.__doc__ = "Cartesian elements."

agcls.AgTypeNameMap["AgEDirectionType"] = AgEDirectionType

class AgEPRSequence(IntEnum):
    """Pitch-Roll (PR) direction sequences."""
    # PR sequence.
    ePR = 0

AgEPRSequence.ePR.__doc__ = "PR sequence."

agcls.AgTypeNameMap["AgEPRSequence"] = AgEPRSequence

class AgEOrientationType(IntEnum):
    """Orientation methods."""
    # AzEl (azimuth-elevation) method.
    eAzEl = 0
    # Euler angles method.
    eEulerAngles = 1
    # Quaternion method.
    eQuaternion = 2
    # YPR (yaw-pitch-roll) method.
    eYPRAngles = 3

AgEOrientationType.eAzEl.__doc__ = "AzEl (azimuth-elevation) method."
AgEOrientationType.eEulerAngles.__doc__ = "Euler angles method."
AgEOrientationType.eQuaternion.__doc__ = "Quaternion method."
AgEOrientationType.eYPRAngles.__doc__ = "YPR (yaw-pitch-roll) method."

agcls.AgTypeNameMap["AgEOrientationType"] = AgEOrientationType

class AgEAzElAboutBoresight(IntEnum):
    """About Boresight options for AzEl orientation method."""
    # Hold: rotation about the Y axis followed by rotation about the new X-axis.
    eAzElAboutBoresightHold = 0
    # Rotate: rotation about the sensor's or antenna's Z axis by the azimuth angle, followed by rotation about the new Y axis by 90 degrees minus the elevation angle.
    eAzElAboutBoresightRotate = 1

AgEAzElAboutBoresight.eAzElAboutBoresightHold.__doc__ = "Hold: rotation about the Y axis followed by rotation about the new X-axis."
AgEAzElAboutBoresight.eAzElAboutBoresightRotate.__doc__ = "Rotate: rotation about the sensor's or antenna's Z axis by the azimuth angle, followed by rotation about the new Y axis by 90 degrees minus the elevation angle."

agcls.AgTypeNameMap["AgEAzElAboutBoresight"] = AgEAzElAboutBoresight

class AgEEulerOrientationSequence(IntEnum):
    """Euler rotation sequence options:"""
    # 121 rotation.
    e121 = 0
    # 123 rotation.
    e123 = 1
    # 131 rotation.
    e131 = 2
    # 132 rotation.
    e132 = 3
    # 212 rotation.
    e212 = 4
    # 213 rotation.
    e213 = 5
    # 231 rotation.
    e231 = 6
    # 232 rotation.
    e232 = 7
    # 312 rotation.
    e312 = 8
    # 313 rotation.
    e313 = 9
    # 321 rotation.
    e321 = 10
    # 323 rotation.
    e323 = 11

AgEEulerOrientationSequence.e121.__doc__ = "121 rotation."
AgEEulerOrientationSequence.e123.__doc__ = "123 rotation."
AgEEulerOrientationSequence.e131.__doc__ = "131 rotation."
AgEEulerOrientationSequence.e132.__doc__ = "132 rotation."
AgEEulerOrientationSequence.e212.__doc__ = "212 rotation."
AgEEulerOrientationSequence.e213.__doc__ = "213 rotation."
AgEEulerOrientationSequence.e231.__doc__ = "231 rotation."
AgEEulerOrientationSequence.e232.__doc__ = "232 rotation."
AgEEulerOrientationSequence.e312.__doc__ = "312 rotation."
AgEEulerOrientationSequence.e313.__doc__ = "313 rotation."
AgEEulerOrientationSequence.e321.__doc__ = "321 rotation."
AgEEulerOrientationSequence.e323.__doc__ = "323 rotation."

agcls.AgTypeNameMap["AgEEulerOrientationSequence"] = AgEEulerOrientationSequence

class AgEYPRAnglesSequence(IntEnum):
    """Yaw-Pitch-Roll (YPR) sequences."""
    # PRY sequence.
    ePRY = 0
    # PYR sequence.
    ePYR = 1
    # RPY sequence.
    eRPY = 2
    # RYP sequence.
    eRYP = 3
    # YPR sequence.
    eYPR = 4
    # YRP sequence.
    eYRP = 5

AgEYPRAnglesSequence.ePRY.__doc__ = "PRY sequence."
AgEYPRAnglesSequence.ePYR.__doc__ = "PYR sequence."
AgEYPRAnglesSequence.eRPY.__doc__ = "RPY sequence."
AgEYPRAnglesSequence.eRYP.__doc__ = "RYP sequence."
AgEYPRAnglesSequence.eYPR.__doc__ = "YPR sequence."
AgEYPRAnglesSequence.eYRP.__doc__ = "YRP sequence."

agcls.AgTypeNameMap["AgEYPRAnglesSequence"] = AgEYPRAnglesSequence

class AgEOrbitStateType(IntEnum):
    """Coordinate types used in specifying orbit state."""
    # Cartesian coordinate type.
    eOrbitStateCartesian = 0
    # Classical (Keplerian) coordinate type.
    eOrbitStateClassical = 1
    # Equinoctial coordinate type.
    eOrbitStateEquinoctial = 2
    # Delaunay variables coordinate type.
    eOrbitStateDelaunay = 3
    # Spherical coordinate type.
    eOrbitStateSpherical = 4
    # Mixed spherical coordinate type.
    eOrbitStateMixedSpherical = 5
    # Geodetic coordinate type.
    eOrbitStateGeodetic = 6

AgEOrbitStateType.eOrbitStateCartesian.__doc__ = "Cartesian coordinate type."
AgEOrbitStateType.eOrbitStateClassical.__doc__ = "Classical (Keplerian) coordinate type."
AgEOrbitStateType.eOrbitStateEquinoctial.__doc__ = "Equinoctial coordinate type."
AgEOrbitStateType.eOrbitStateDelaunay.__doc__ = "Delaunay variables coordinate type."
AgEOrbitStateType.eOrbitStateSpherical.__doc__ = "Spherical coordinate type."
AgEOrbitStateType.eOrbitStateMixedSpherical.__doc__ = "Mixed spherical coordinate type."
AgEOrbitStateType.eOrbitStateGeodetic.__doc__ = "Geodetic coordinate type."

agcls.AgTypeNameMap["AgEOrbitStateType"] = AgEOrbitStateType

class AgECoordinateSystem(IntEnum):
    """Earth-centered coordinate systems for defining certain propagators."""
    # Represents coordinate system not supported by the Object Model
    eCoordinateSystemUnknown = -1
    # Alignment at Epoch: an inertial system coincident with ECF at the Coord Epoch. Often used to specify launch trajectories.
    eCoordinateSystemAlignmentAtEpoch = 0
    # B1950: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth at the beginning of the Besselian year 1950 and corresponds to 31 December 1949 22:09:07.2 or JD 2433282.423.
    eCoordinateSystemB1950 = 1
    # Fixed: X is fixed at 0 deg longitude, Y is fixed at 90 deg longitude, and Z is directed toward the north pole.
    eCoordinateSystemFixed = 2
    # J2000: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth on 1 Jan 2000 at 12:00:00.00 TDB, which corresponds to JD 2451545.0 TDB.
    eCoordinateSystemJ2000 = 3
    # Mean of Date: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth at the Orbit Epoch.
    eCoordinateSystemMeanOfDate = 4
    # Mean of Epoch: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth at the Coord Epoch.
    eCoordinateSystemMeanOfEpoch = 5
    # TEME of Date: X points toward the mean vernal equinox and Z points along the true rotation axis of the Earth at the Orbit Epoch.
    eCoordinateSystemTEMEOfDate = 6
    # TEME of Epoch: X points toward the mean vernal equinox and Z points along the true rotation axis of the Earth at the Coord Epoch.
    eCoordinateSystemTEMEOfEpoch = 7
    # True of Date: X points toward the true vernal equinox and Z points along the true rotation axis of the Earth at the Orbit Epoch.
    eCoordinateSystemTrueOfDate = 8
    # True of Epoch: X points toward the true vernal equinox and Z points along the true rotation axis of the Earth at the Coord Epoch.
    eCoordinateSystemTrueOfEpoch = 9
    # True of Ref Date: A special case of True of Epoch. Instead of the Coord Epoch, this system uses a Reference Date defined in the Integration Control page of the scenario's PODS properties.
    eCoordinateSystemTrueOfRefDate = 10
    # ICRF: International Celestial Reference Frame.
    eCoordinateSystemICRF = 11
    # Mean Earth
    eCoordinateSystemMeanEarth = 13
    # uses an analytic formula not modeling lunar libration
    eCoordinateSystemFixedNoLibration = 14
    # Fixed_IAU2003
    eCoordinateSystemFixedIAU2003 = 15
    # PrincipalAxes_421
    eCoordinateSystemPrincipalAxes421 = 16
    # PrincipalAxes_403
    eCoordinateSystemPrincipalAxes403 = 17
    # Inertial
    eCoordinateSystemInertial = 18
    # The mean ecliptic system evaluated at the J2000 epoch. The mean ecliptic plane is defined as the rotation of the J2000 XY plane about the J2000 X axis by the mean obliquity defined using FK5 IAU76 theory.
    eCoordinateSystemJ2000Ecliptic = 19
    # The true ecliptic system, evaluated at each given time. The true ecliptic plane is defined as the rotation of the J2000 XY plane about the J2000 X axis by the true obliquity defined using FK5 IAU76 theory.
    eCoordinateSystemTrueEclipticOfDate = 21
    # PrincipalAxes_430
    eCoordinateSystemPrincipalAxes430 = 22
    # TrueOfDateRotating: Like the Fixed system, but ignores pole wander. The XY plane is the same as the XY plane of the TrueOfDate system, and the system rotates about the TrueOfDate Z-axis.
    eCoordinateSystemTrueOfDateRotating = 23
    # EclipticJ2000ICRF: An ecliptic system that is a fixed offset of the ICRF system, found by rotating the ICRF system about its X-axis by the mean obliquity at the J2000 epoch (i.e., 84381.448 arcSecs). The ecliptic plane is the XY-plane of this system.
    eCoordinateSystemEclipticJ2000ICRF = 24

AgECoordinateSystem.eCoordinateSystemUnknown.__doc__ = "Represents coordinate system not supported by the Object Model"
AgECoordinateSystem.eCoordinateSystemAlignmentAtEpoch.__doc__ = "Alignment at Epoch: an inertial system coincident with ECF at the Coord Epoch. Often used to specify launch trajectories."
AgECoordinateSystem.eCoordinateSystemB1950.__doc__ = "B1950: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth at the beginning of the Besselian year 1950 and corresponds to 31 December 1949 22:09:07.2 or JD 2433282.423."
AgECoordinateSystem.eCoordinateSystemFixed.__doc__ = "Fixed: X is fixed at 0 deg longitude, Y is fixed at 90 deg longitude, and Z is directed toward the north pole."
AgECoordinateSystem.eCoordinateSystemJ2000.__doc__ = "J2000: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth on 1 Jan 2000 at 12:00:00.00 TDB, which corresponds to JD 2451545.0 TDB."
AgECoordinateSystem.eCoordinateSystemMeanOfDate.__doc__ = "Mean of Date: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth at the Orbit Epoch."
AgECoordinateSystem.eCoordinateSystemMeanOfEpoch.__doc__ = "Mean of Epoch: X points toward the mean vernal equinox and Z points along the mean rotation axis of the Earth at the Coord Epoch."
AgECoordinateSystem.eCoordinateSystemTEMEOfDate.__doc__ = "TEME of Date: X points toward the mean vernal equinox and Z points along the true rotation axis of the Earth at the Orbit Epoch."
AgECoordinateSystem.eCoordinateSystemTEMEOfEpoch.__doc__ = "TEME of Epoch: X points toward the mean vernal equinox and Z points along the true rotation axis of the Earth at the Coord Epoch."
AgECoordinateSystem.eCoordinateSystemTrueOfDate.__doc__ = "True of Date: X points toward the true vernal equinox and Z points along the true rotation axis of the Earth at the Orbit Epoch."
AgECoordinateSystem.eCoordinateSystemTrueOfEpoch.__doc__ = "True of Epoch: X points toward the true vernal equinox and Z points along the true rotation axis of the Earth at the Coord Epoch."
AgECoordinateSystem.eCoordinateSystemTrueOfRefDate.__doc__ = "True of Ref Date: A special case of True of Epoch. Instead of the Coord Epoch, this system uses a Reference Date defined in the Integration Control page of the scenario's PODS properties."
AgECoordinateSystem.eCoordinateSystemICRF.__doc__ = "ICRF: International Celestial Reference Frame."
AgECoordinateSystem.eCoordinateSystemMeanEarth.__doc__ = "Mean Earth"
AgECoordinateSystem.eCoordinateSystemFixedNoLibration.__doc__ = "uses an analytic formula not modeling lunar libration"
AgECoordinateSystem.eCoordinateSystemFixedIAU2003.__doc__ = "Fixed_IAU2003"
AgECoordinateSystem.eCoordinateSystemPrincipalAxes421.__doc__ = "PrincipalAxes_421"
AgECoordinateSystem.eCoordinateSystemPrincipalAxes403.__doc__ = "PrincipalAxes_403"
AgECoordinateSystem.eCoordinateSystemInertial.__doc__ = "Inertial"
AgECoordinateSystem.eCoordinateSystemJ2000Ecliptic.__doc__ = "The mean ecliptic system evaluated at the J2000 epoch. The mean ecliptic plane is defined as the rotation of the J2000 XY plane about the J2000 X axis by the mean obliquity defined using FK5 IAU76 theory."
AgECoordinateSystem.eCoordinateSystemTrueEclipticOfDate.__doc__ = "The true ecliptic system, evaluated at each given time. The true ecliptic plane is defined as the rotation of the J2000 XY plane about the J2000 X axis by the true obliquity defined using FK5 IAU76 theory."
AgECoordinateSystem.eCoordinateSystemPrincipalAxes430.__doc__ = "PrincipalAxes_430"
AgECoordinateSystem.eCoordinateSystemTrueOfDateRotating.__doc__ = "TrueOfDateRotating: Like the Fixed system, but ignores pole wander. The XY plane is the same as the XY plane of the TrueOfDate system, and the system rotates about the TrueOfDate Z-axis."
AgECoordinateSystem.eCoordinateSystemEclipticJ2000ICRF.__doc__ = "EclipticJ2000ICRF: An ecliptic system that is a fixed offset of the ICRF system, found by rotating the ICRF system about its X-axis by the mean obliquity at the J2000 epoch (i.e., 84381.448 arcSecs). The ecliptic plane is the XY-plane of this system."

agcls.AgTypeNameMap["AgECoordinateSystem"] = AgECoordinateSystem

class AgELogMsgType(IntEnum):
    """Log message types."""
    # Debugging message.
    eLogMsgDebug = 0
    # Informational message.
    eLogMsgInfo = 1
    # Informational message.
    eLogMsgForceInfo = 2
    # Warning message.
    eLogMsgWarning = 3
    # Alarm message.
    eLogMsgAlarm = 4

AgELogMsgType.eLogMsgDebug.__doc__ = "Debugging message."
AgELogMsgType.eLogMsgInfo.__doc__ = "Informational message."
AgELogMsgType.eLogMsgForceInfo.__doc__ = "Informational message."
AgELogMsgType.eLogMsgWarning.__doc__ = "Warning message."
AgELogMsgType.eLogMsgAlarm.__doc__ = "Alarm message."

agcls.AgTypeNameMap["AgELogMsgType"] = AgELogMsgType

class AgELogMsgDispID(IntEnum):
    """Log message destination options."""
    # STK displays the message in all the log destination.
    eLogMsgDispAll = -1
    # STK displays the message in the default log destination.
    eLogMsgDispDefault = 0
    # STK displays the message in the message window.
    eLogMsgDispMsgWin = 1
    # STK displays the message in the status bar.
    eLogMsgDispStatusBar = 2

AgELogMsgDispID.eLogMsgDispAll.__doc__ = "STK displays the message in all the log destination."
AgELogMsgDispID.eLogMsgDispDefault.__doc__ = "STK displays the message in the default log destination."
AgELogMsgDispID.eLogMsgDispMsgWin.__doc__ = "STK displays the message in the message window."
AgELogMsgDispID.eLogMsgDispStatusBar.__doc__ = "STK displays the message in the status bar."

agcls.AgTypeNameMap["AgELogMsgDispID"] = AgELogMsgDispID

class AgELineStyle(IntEnum):
    """Line Style"""
    # Specifies a solid line.
    eSolid = 0
    # Specifies a dashed line.
    eDashed = 1
    # Specifies a dotted line.
    eDotted = 2
    # Dot-dashed line.
    eDotDashed = 3
    # Specifies a long dashed line.
    eLongDashed = 4
    # Specifies an alternating dash-dot-dot line.
    eDashDotDotted = 5
    # Specifies a user configurable medium dashed line.
    eMDash = 6
    # Specifies a user configurable long dashed line.
    eLDash = 7
    # Specifies a user configurable small dash-dotted line.
    eSDashDot = 8
    # Specifies a user configurable medium dash-dotted line.
    eMDashDot = 9
    # Specifies a user configurable long dash-dotted line.
    eLDashDot = 10
    # Specifies a user configurable medium followed by small dashed line.
    eMSDash = 11
    # Specifies a user configurable long followed by small dashed line.
    eLSDash = 12
    # Specifies a user configurable long followed by medium dashed line.
    eLMDash = 13
    # Specifies a user configurable medium followed by small dashed line.
    eLMSDash = 14
    # Specifies a dotted line.
    eDot = 15
    # Specifies a long dashed line.
    eLongDash = 16
    # Specifies an alternating dash-dot line.
    eSDash = 17

AgELineStyle.eSolid.__doc__ = "Specifies a solid line."
AgELineStyle.eDashed.__doc__ = "Specifies a dashed line."
AgELineStyle.eDotted.__doc__ = "Specifies a dotted line."
AgELineStyle.eDotDashed.__doc__ = "Dot-dashed line."
AgELineStyle.eLongDashed.__doc__ = "Specifies a long dashed line."
AgELineStyle.eDashDotDotted.__doc__ = "Specifies an alternating dash-dot-dot line."
AgELineStyle.eMDash.__doc__ = "Specifies a user configurable medium dashed line."
AgELineStyle.eLDash.__doc__ = "Specifies a user configurable long dashed line."
AgELineStyle.eSDashDot.__doc__ = "Specifies a user configurable small dash-dotted line."
AgELineStyle.eMDashDot.__doc__ = "Specifies a user configurable medium dash-dotted line."
AgELineStyle.eLDashDot.__doc__ = "Specifies a user configurable long dash-dotted line."
AgELineStyle.eMSDash.__doc__ = "Specifies a user configurable medium followed by small dashed line."
AgELineStyle.eLSDash.__doc__ = "Specifies a user configurable long followed by small dashed line."
AgELineStyle.eLMDash.__doc__ = "Specifies a user configurable long followed by medium dashed line."
AgELineStyle.eLMSDash.__doc__ = "Specifies a user configurable medium followed by small dashed line."
AgELineStyle.eDot.__doc__ = "Specifies a dotted line."
AgELineStyle.eLongDash.__doc__ = "Specifies a long dashed line."
AgELineStyle.eSDash.__doc__ = "Specifies an alternating dash-dot line."

agcls.AgTypeNameMap["AgELineStyle"] = AgELineStyle

class AgEExecMultiCmdResultAction(IntFlag):
    """Enumeration defines a set of actions when an error occurs while executing a command batch."""
    # Continue executing the remaining commands in the command batch.
    eContinueOnError = 0
    # Terminate the execution of the command batch but do not throw an exception.
    eStopOnError = 1
    # Terminate the execution of the command batch and throw an exception.
    eExceptionOnError = 2
    # Ignore results returned by individual commands. The option must be used in combination with other flags.
    eIgnoreExecCmdResult = 0x8000

AgEExecMultiCmdResultAction.eContinueOnError.__doc__ = "Continue executing the remaining commands in the command batch."
AgEExecMultiCmdResultAction.eStopOnError.__doc__ = "Terminate the execution of the command batch but do not throw an exception."
AgEExecMultiCmdResultAction.eExceptionOnError.__doc__ = "Terminate the execution of the command batch and throw an exception."
AgEExecMultiCmdResultAction.eIgnoreExecCmdResult.__doc__ = "Ignore results returned by individual commands. The option must be used in combination with other flags."

agcls.AgTypeNameMap["AgEExecMultiCmdResultAction"] = AgEExecMultiCmdResultAction

class AgEFillStyle(IntEnum):
    """Fill Style"""
    # Specifies a solid fill style.
    eFillStyleSolid = 0
    # Specifies a horizontally striped fill style.
    eFillStyleHorizontalStripe = 1
    # Specifies a diagonally striped fill style.
    eFillStyleDiagonalStripe1 = 2
    # Specifies a diagonally striped fill style.
    eFillStyleDiagonalStripe2 = 3
    # Specifies a hatched fill style.
    eFillStyleHatch = 4
    # Specifies a diagonally hatched fill style.
    eFillStyleDiagonalHatch = 5
    # Specifies a special fill style where every other pixel is drawn.
    eFillStyleScreen = 6
    # Specifies a vertically striped fill style.
    eFillStyleVerticalStripe = 7

AgEFillStyle.eFillStyleSolid.__doc__ = "Specifies a solid fill style."
AgEFillStyle.eFillStyleHorizontalStripe.__doc__ = "Specifies a horizontally striped fill style."
AgEFillStyle.eFillStyleDiagonalStripe1.__doc__ = "Specifies a diagonally striped fill style."
AgEFillStyle.eFillStyleDiagonalStripe2.__doc__ = "Specifies a diagonally striped fill style."
AgEFillStyle.eFillStyleHatch.__doc__ = "Specifies a hatched fill style."
AgEFillStyle.eFillStyleDiagonalHatch.__doc__ = "Specifies a diagonally hatched fill style."
AgEFillStyle.eFillStyleScreen.__doc__ = "Specifies a special fill style where every other pixel is drawn."
AgEFillStyle.eFillStyleVerticalStripe.__doc__ = "Specifies a vertically striped fill style."

agcls.AgTypeNameMap["AgEFillStyle"] = AgEFillStyle

class AgEPropertyInfoValueType(IntEnum):
    """The enumeration used to determine what type of property is being used."""
    # Property is of type int.
    ePropertyInfoValueTypeInt = 0
    # Property is of type real.
    ePropertyInfoValueTypeReal = 1
    # Property is of type IAgQuantity.
    ePropertyInfoValueTypeQuantity = 2
    # Property is of type IAgDate.
    ePropertyInfoValueTypeDate = 3
    # Property is of type string.
    ePropertyInfoValueTypeString = 4
    # Property is of type bool.
    ePropertyInfoValueTypeBool = 5
    # Property is an interface.
    ePropertyInfoValueTypeInterface = 6

AgEPropertyInfoValueType.ePropertyInfoValueTypeInt.__doc__ = "Property is of type int."
AgEPropertyInfoValueType.ePropertyInfoValueTypeReal.__doc__ = "Property is of type real."
AgEPropertyInfoValueType.ePropertyInfoValueTypeQuantity.__doc__ = "Property is of type IAgQuantity."
AgEPropertyInfoValueType.ePropertyInfoValueTypeDate.__doc__ = "Property is of type IAgDate."
AgEPropertyInfoValueType.ePropertyInfoValueTypeString.__doc__ = "Property is of type string."
AgEPropertyInfoValueType.ePropertyInfoValueTypeBool.__doc__ = "Property is of type bool."
AgEPropertyInfoValueType.ePropertyInfoValueTypeInterface.__doc__ = "Property is an interface."

agcls.AgTypeNameMap["AgEPropertyInfoValueType"] = AgEPropertyInfoValueType


class IAgLocationData(object):
    """Base interface IAgLocationData. IAgPosition derives from this interface."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C1E99EDA-C666-4971-AFD0-2259CB7E8452}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgLocationData._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgLocationData from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgLocationData.__dict__ and type(IAgLocationData.__dict__[attrname]) == property:
            return IAgLocationData.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgLocationData.")
    

agcls.AgClassCatalog.add_catalog_entry("{C1E99EDA-C666-4971-AFD0-2259CB7E8452}", IAgLocationData)
agcls.AgTypeNameMap["IAgLocationData"] = IAgLocationData

class IAgPosition(object):
    """IAgPosition provides access to the position of the object"""
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F25960CE-1D73-4BA0-A429-541DD6D808DE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "ConvertTo" : 1,
                             "get_PosType" : 2,
                             "Assign" : 3,
                             "AssignGeocentric" : 4,
                             "AssignGeodetic" : 5,
                             "AssignSpherical" : 6,
                             "AssignCylindrical" : 7,
                             "AssignCartesian" : 8,
                             "AssignPlanetocentric" : 9,
                             "AssignPlanetodetic" : 10,
                             "QueryPlanetocentric" : 11,
                             "QueryPlanetodetic" : 12,
                             "QuerySpherical" : 13,
                             "QueryCylindrical" : 14,
                             "QueryCartesian" : 15,
                             "get_CentralBodyName" : 16,
                             "QueryPlanetocentricArray" : 17,
                             "QueryPlanetodeticArray" : 18,
                             "QuerySphericalArray" : 19,
                             "QueryCylindricalArray" : 20,
                             "QueryCartesianArray" : 21, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgPosition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgPosition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgPosition.__dict__ and type(IAgPosition.__dict__[attrname]) == property:
            return IAgPosition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgPosition.")
    
    _ConvertTo_metadata = { "name" : "ConvertTo",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPositionType), agmarshall.AgInterface_out_arg,) }
    def ConvertTo(self, type:"AgEPositionType") -> "IAgPosition":
        """Changes the position coordinates to type specified."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._ConvertTo_metadata, type, out_arg())

    _get_PosType_metadata = { "name" : "PosType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPositionType),) }
    @property
    def PosType(self) -> "AgEPositionType":
        """Gets the type of position currently being used."""
        return self._intf.get_property(IAgPosition._metadata, IAgPosition._get_PosType_metadata)

    _Assign_metadata = { "name" : "Assign",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgPosition"),) }
    def Assign(self, pPosition:"IAgPosition") -> None:
        """This assigns the coordinates into the system."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._Assign_metadata, pPosition)

    _AssignGeocentric_metadata = { "name" : "AssignGeocentric",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def AssignGeocentric(self, lat:typing.Any, lon:typing.Any, alt:float) -> None:
        """Helper method to assign the position using the Geocentric representation."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._AssignGeocentric_metadata, lat, lon, alt)

    _AssignGeodetic_metadata = { "name" : "AssignGeodetic",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def AssignGeodetic(self, lat:typing.Any, lon:typing.Any, alt:float) -> None:
        """Helper method to assign the position using the Geodetic representation."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._AssignGeodetic_metadata, lat, lon, alt)

    _AssignSpherical_metadata = { "name" : "AssignSpherical",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def AssignSpherical(self, lat:typing.Any, lon:typing.Any, radius:float) -> None:
        """Helper method to assign the position using the Spherical representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._AssignSpherical_metadata, lat, lon, radius)

    _AssignCylindrical_metadata = { "name" : "AssignCylindrical",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_arg,) }
    def AssignCylindrical(self, radius:float, z:float, lon:typing.Any) -> None:
        """Helper method to assign the position using the Cylindrical representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._AssignCylindrical_metadata, radius, z, lon)

    _AssignCartesian_metadata = { "name" : "AssignCartesian",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignCartesian(self, x:float, y:float, z:float) -> None:
        """Helper method to assign the position using the Cartesian representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._AssignCartesian_metadata, x, y, z)

    _AssignPlanetocentric_metadata = { "name" : "AssignPlanetocentric",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def AssignPlanetocentric(self, lat:typing.Any, lon:typing.Any, alt:float) -> None:
        """Helper method to assign the position using the Planetocentric representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._AssignPlanetocentric_metadata, lat, lon, alt)

    _AssignPlanetodetic_metadata = { "name" : "AssignPlanetodetic",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def AssignPlanetodetic(self, lat:typing.Any, lon:typing.Any, alt:float) -> None:
        """Helper method to assign the position using the Planetodetic representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._AssignPlanetodetic_metadata, lat, lon, alt)

    _QueryPlanetocentric_metadata = { "name" : "QueryPlanetocentric",
            "arg_types" : (POINTER(agcom.VARIANT), POINTER(agcom.VARIANT), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def QueryPlanetocentric(self) -> typing.Tuple[typing.Any, typing.Any, float]:
        """Helper method to get the position using the Planetocentric representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryPlanetocentric_metadata, out_arg(), out_arg(), out_arg())

    _QueryPlanetodetic_metadata = { "name" : "QueryPlanetodetic",
            "arg_types" : (POINTER(agcom.VARIANT), POINTER(agcom.VARIANT), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def QueryPlanetodetic(self) -> typing.Tuple[typing.Any, typing.Any, float]:
        """Helper method to get the position using the Planetodetic representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryPlanetodetic_metadata, out_arg(), out_arg(), out_arg())

    _QuerySpherical_metadata = { "name" : "QuerySpherical",
            "arg_types" : (POINTER(agcom.VARIANT), POINTER(agcom.VARIANT), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def QuerySpherical(self) -> typing.Tuple[typing.Any, typing.Any, float]:
        """Helper method to get the position using the Spherical representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QuerySpherical_metadata, out_arg(), out_arg(), out_arg())

    _QueryCylindrical_metadata = { "name" : "QueryCylindrical",
            "arg_types" : (POINTER(agcom.DOUBLE), POINTER(agcom.VARIANT), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg,) }
    def QueryCylindrical(self) -> typing.Tuple[float, typing.Any, float]:
        """Helper method to get the position using the Cylindrical representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryCylindrical_metadata, out_arg(), out_arg(), out_arg())

    _QueryCartesian_metadata = { "name" : "QueryCartesian",
            "arg_types" : (POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def QueryCartesian(self) -> typing.Tuple[float, float, float]:
        """Helper method to get the position using the Cartesian representation"""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryCartesian_metadata, out_arg(), out_arg(), out_arg())

    _get_CentralBodyName_metadata = { "name" : "CentralBodyName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def CentralBodyName(self) -> str:
        """Gets the central body."""
        return self._intf.get_property(IAgPosition._metadata, IAgPosition._get_CentralBodyName_metadata)

    _QueryPlanetocentricArray_metadata = { "name" : "QueryPlanetocentricArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryPlanetocentricArray(self) -> list:
        """Returns the Planetocentric elements as an array."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryPlanetocentricArray_metadata, out_arg())

    _QueryPlanetodeticArray_metadata = { "name" : "QueryPlanetodeticArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryPlanetodeticArray(self) -> list:
        """Returns the Planetodetic elements as an array."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryPlanetodeticArray_metadata, out_arg())

    _QuerySphericalArray_metadata = { "name" : "QuerySphericalArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QuerySphericalArray(self) -> list:
        """Returns the Spherical elements as an array."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QuerySphericalArray_metadata, out_arg())

    _QueryCylindricalArray_metadata = { "name" : "QueryCylindricalArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryCylindricalArray(self) -> list:
        """Returns the Cylindrical elements as an array."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryCylindricalArray_metadata, out_arg())

    _QueryCartesianArray_metadata = { "name" : "QueryCartesianArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryCartesianArray(self) -> list:
        """Returns the Cartesian elements as an array."""
        return self._intf.invoke(IAgPosition._metadata, IAgPosition._QueryCartesianArray_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{F25960CE-1D73-4BA0-A429-541DD6D808DE}", IAgPosition)
agcls.AgTypeNameMap["IAgPosition"] = IAgPosition

class IAgPlanetocentric(IAgPosition):
    """Planetocentric Position Type."""
    _num_methods = 6
    _vtable_offset = IAgPosition._vtable_offset + IAgPosition._num_methods
    _metadata = {
        "uuid" : "{605061D3-5594-4B88-AC0A-D4EA90EFFAA1}",
        "vtable_reference" : IAgPosition._vtable_offset + IAgPosition._num_methods - 1,
        "method_offsets" : { "get_Lat" : 1,
                             "set_Lat" : 2,
                             "get_Lon" : 3,
                             "set_Lon" : 4,
                             "get_Alt" : 5,
                             "set_Alt" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgPlanetocentric._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgPlanetocentric from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgPlanetocentric.__dict__ and type(IAgPlanetocentric.__dict__[attrname]) == property:
            return IAgPlanetocentric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgPosition.__setattr__(self, attrname, value)
    
    _get_Lat_metadata = { "name" : "Lat",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lat(self) -> typing.Any:
        """Uses Latitude Dimension."""
        return self._intf.get_property(IAgPlanetocentric._metadata, IAgPlanetocentric._get_Lat_metadata)

    _set_Lat_metadata = { "name" : "Lat",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lat.setter
    def Lat(self, pVal:typing.Any) -> None:
        return self._intf.set_property(IAgPlanetocentric._metadata, IAgPlanetocentric._set_Lat_metadata, pVal)

    _get_Lon_metadata = { "name" : "Lon",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lon(self) -> typing.Any:
        """Uses Longitude Dimension."""
        return self._intf.get_property(IAgPlanetocentric._metadata, IAgPlanetocentric._get_Lon_metadata)

    _set_Lon_metadata = { "name" : "Lon",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lon.setter
    def Lon(self, pVal:typing.Any) -> None:
        return self._intf.set_property(IAgPlanetocentric._metadata, IAgPlanetocentric._set_Lon_metadata, pVal)

    _get_Alt_metadata = { "name" : "Alt",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Alt(self) -> float:
        """Dimension depends on context."""
        return self._intf.get_property(IAgPlanetocentric._metadata, IAgPlanetocentric._get_Alt_metadata)

    _set_Alt_metadata = { "name" : "Alt",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Alt.setter
    def Alt(self, pVal:float) -> None:
        return self._intf.set_property(IAgPlanetocentric._metadata, IAgPlanetocentric._set_Alt_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{605061D3-5594-4B88-AC0A-D4EA90EFFAA1}", IAgPlanetocentric)
agcls.AgTypeNameMap["IAgPlanetocentric"] = IAgPlanetocentric

class IAgGeocentric(IAgPosition):
    """Geocentric Position Type."""
    _num_methods = 6
    _vtable_offset = IAgPosition._vtable_offset + IAgPosition._num_methods
    _metadata = {
        "uuid" : "{7D22F2C8-81B1-452E-AA06-0AEEB1FDF0F9}",
        "vtable_reference" : IAgPosition._vtable_offset + IAgPosition._num_methods - 1,
        "method_offsets" : { "get_Lat" : 1,
                             "set_Lat" : 2,
                             "get_Lon" : 3,
                             "set_Lon" : 4,
                             "get_Alt" : 5,
                             "set_Alt" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgGeocentric._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgGeocentric from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgGeocentric.__dict__ and type(IAgGeocentric.__dict__[attrname]) == property:
            return IAgGeocentric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgPosition.__setattr__(self, attrname, value)
    
    _get_Lat_metadata = { "name" : "Lat",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lat(self) -> typing.Any:
        """Uses Latitude Dimension."""
        return self._intf.get_property(IAgGeocentric._metadata, IAgGeocentric._get_Lat_metadata)

    _set_Lat_metadata = { "name" : "Lat",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lat.setter
    def Lat(self, pVal:typing.Any) -> None:
        return self._intf.set_property(IAgGeocentric._metadata, IAgGeocentric._set_Lat_metadata, pVal)

    _get_Lon_metadata = { "name" : "Lon",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lon(self) -> typing.Any:
        """Uses Longitude Dimension."""
        return self._intf.get_property(IAgGeocentric._metadata, IAgGeocentric._get_Lon_metadata)

    _set_Lon_metadata = { "name" : "Lon",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lon.setter
    def Lon(self, pVal:typing.Any) -> None:
        return self._intf.set_property(IAgGeocentric._metadata, IAgGeocentric._set_Lon_metadata, pVal)

    _get_Alt_metadata = { "name" : "Alt",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Alt(self) -> float:
        """Dimension depends on context."""
        return self._intf.get_property(IAgGeocentric._metadata, IAgGeocentric._get_Alt_metadata)

    _set_Alt_metadata = { "name" : "Alt",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Alt.setter
    def Alt(self, pVal:float) -> None:
        return self._intf.set_property(IAgGeocentric._metadata, IAgGeocentric._set_Alt_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{7D22F2C8-81B1-452E-AA06-0AEEB1FDF0F9}", IAgGeocentric)
agcls.AgTypeNameMap["IAgGeocentric"] = IAgGeocentric

class IAgSpherical(IAgPosition):
    """Spherical Position Type."""
    _num_methods = 6
    _vtable_offset = IAgPosition._vtable_offset + IAgPosition._num_methods
    _metadata = {
        "uuid" : "{62B93DF1-C615-4363-B4D9-DAA1ACE56204}",
        "vtable_reference" : IAgPosition._vtable_offset + IAgPosition._num_methods - 1,
        "method_offsets" : { "get_Lat" : 1,
                             "set_Lat" : 2,
                             "get_Lon" : 3,
                             "set_Lon" : 4,
                             "get_Radius" : 5,
                             "set_Radius" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgSpherical._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgSpherical from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgSpherical.__dict__ and type(IAgSpherical.__dict__[attrname]) == property:
            return IAgSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgPosition.__setattr__(self, attrname, value)
    
    _get_Lat_metadata = { "name" : "Lat",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lat(self) -> typing.Any:
        """Uses Latitude Dimension."""
        return self._intf.get_property(IAgSpherical._metadata, IAgSpherical._get_Lat_metadata)

    _set_Lat_metadata = { "name" : "Lat",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lat.setter
    def Lat(self, pVal:typing.Any) -> None:
        return self._intf.set_property(IAgSpherical._metadata, IAgSpherical._set_Lat_metadata, pVal)

    _get_Lon_metadata = { "name" : "Lon",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lon(self) -> typing.Any:
        """Uses Longitude Dimension."""
        return self._intf.get_property(IAgSpherical._metadata, IAgSpherical._get_Lon_metadata)

    _set_Lon_metadata = { "name" : "Lon",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lon.setter
    def Lon(self, pVal:typing.Any) -> None:
        return self._intf.set_property(IAgSpherical._metadata, IAgSpherical._set_Lon_metadata, pVal)

    _get_Radius_metadata = { "name" : "Radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Radius(self) -> float:
        """Dimension depends on context."""
        return self._intf.get_property(IAgSpherical._metadata, IAgSpherical._get_Radius_metadata)

    _set_Radius_metadata = { "name" : "Radius",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Radius.setter
    def Radius(self, pVal:float) -> None:
        return self._intf.set_property(IAgSpherical._metadata, IAgSpherical._set_Radius_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{62B93DF1-C615-4363-B4D9-DAA1ACE56204}", IAgSpherical)
agcls.AgTypeNameMap["IAgSpherical"] = IAgSpherical

class IAgCylindrical(IAgPosition):
    """Cylindrical Position Type."""
    _num_methods = 6
    _vtable_offset = IAgPosition._vtable_offset + IAgPosition._num_methods
    _metadata = {
        "uuid" : "{36F08499-F7C4-41DE-AB49-794EC65C5165}",
        "vtable_reference" : IAgPosition._vtable_offset + IAgPosition._num_methods - 1,
        "method_offsets" : { "get_Radius" : 1,
                             "set_Radius" : 2,
                             "get_Z" : 3,
                             "set_Z" : 4,
                             "get_Lon" : 5,
                             "set_Lon" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCylindrical._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCylindrical from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCylindrical.__dict__ and type(IAgCylindrical.__dict__[attrname]) == property:
            return IAgCylindrical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgPosition.__setattr__(self, attrname, value)
    
    _get_Radius_metadata = { "name" : "Radius",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Radius(self) -> float:
        """Dimension depends on context."""
        return self._intf.get_property(IAgCylindrical._metadata, IAgCylindrical._get_Radius_metadata)

    _set_Radius_metadata = { "name" : "Radius",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Radius.setter
    def Radius(self, pVal:float) -> None:
        return self._intf.set_property(IAgCylindrical._metadata, IAgCylindrical._set_Radius_metadata, pVal)

    _get_Z_metadata = { "name" : "Z",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Z(self) -> float:
        """Uses Angle Dimension."""
        return self._intf.get_property(IAgCylindrical._metadata, IAgCylindrical._get_Z_metadata)

    _set_Z_metadata = { "name" : "Z",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Z.setter
    def Z(self, pVal:float) -> None:
        return self._intf.set_property(IAgCylindrical._metadata, IAgCylindrical._set_Z_metadata, pVal)

    _get_Lon_metadata = { "name" : "Lon",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lon(self) -> typing.Any:
        """Dimension depends on context."""
        return self._intf.get_property(IAgCylindrical._metadata, IAgCylindrical._get_Lon_metadata)

    _set_Lon_metadata = { "name" : "Lon",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lon.setter
    def Lon(self, pVal:typing.Any) -> None:
        return self._intf.set_property(IAgCylindrical._metadata, IAgCylindrical._set_Lon_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{36F08499-F7C4-41DE-AB49-794EC65C5165}", IAgCylindrical)
agcls.AgTypeNameMap["IAgCylindrical"] = IAgCylindrical

class IAgCartesian(IAgPosition):
    """IAgCartesian Interface used to access a position using Cartesian Coordinates"""
    _num_methods = 6
    _vtable_offset = IAgPosition._vtable_offset + IAgPosition._num_methods
    _metadata = {
        "uuid" : "{F6D3AD94-04C0-464E-8B95-8A859AA1BCA7}",
        "vtable_reference" : IAgPosition._vtable_offset + IAgPosition._num_methods - 1,
        "method_offsets" : { "get_X" : 1,
                             "set_X" : 2,
                             "get_Y" : 3,
                             "set_Y" : 4,
                             "get_Z" : 5,
                             "set_Z" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCartesian._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCartesian from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCartesian.__dict__ and type(IAgCartesian.__dict__[attrname]) == property:
            return IAgCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgPosition.__setattr__(self, attrname, value)
    
    _get_X_metadata = { "name" : "X",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def X(self) -> float:
        """Dimension depends on context."""
        return self._intf.get_property(IAgCartesian._metadata, IAgCartesian._get_X_metadata)

    _set_X_metadata = { "name" : "X",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @X.setter
    def X(self, pVal:float) -> None:
        return self._intf.set_property(IAgCartesian._metadata, IAgCartesian._set_X_metadata, pVal)

    _get_Y_metadata = { "name" : "Y",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Y(self) -> float:
        """Dimension depends on context."""
        return self._intf.get_property(IAgCartesian._metadata, IAgCartesian._get_Y_metadata)

    _set_Y_metadata = { "name" : "Y",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Y.setter
    def Y(self, pVal:float) -> None:
        return self._intf.set_property(IAgCartesian._metadata, IAgCartesian._set_Y_metadata, pVal)

    _get_Z_metadata = { "name" : "Z",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Z(self) -> float:
        """Dimension depends on context."""
        return self._intf.get_property(IAgCartesian._metadata, IAgCartesian._get_Z_metadata)

    _set_Z_metadata = { "name" : "Z",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Z.setter
    def Z(self, pVal:float) -> None:
        return self._intf.set_property(IAgCartesian._metadata, IAgCartesian._set_Z_metadata, pVal)


agcls.AgClassCatalog.add_catalog_entry("{F6D3AD94-04C0-464E-8B95-8A859AA1BCA7}", IAgCartesian)
agcls.AgTypeNameMap["IAgCartesian"] = IAgCartesian

class IAgGeodetic(IAgPosition):
    """IAgGeodetic sets the position using Geodetic properties."""
    _num_methods = 6
    _vtable_offset = IAgPosition._vtable_offset + IAgPosition._num_methods
    _metadata = {
        "uuid" : "{93D3322B-C842-48D2-AFCF-BC42B59DB28E}",
        "vtable_reference" : IAgPosition._vtable_offset + IAgPosition._num_methods - 1,
        "method_offsets" : { "get_Lat" : 1,
                             "set_Lat" : 2,
                             "get_Lon" : 3,
                             "set_Lon" : 4,
                             "get_Alt" : 5,
                             "set_Alt" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgGeodetic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgGeodetic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgGeodetic.__dict__ and type(IAgGeodetic.__dict__[attrname]) == property:
            return IAgGeodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgPosition.__setattr__(self, attrname, value)
    
    _get_Lat_metadata = { "name" : "Lat",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lat(self) -> typing.Any:
        """Latitude. Uses Latitude Dimension."""
        return self._intf.get_property(IAgGeodetic._metadata, IAgGeodetic._get_Lat_metadata)

    _set_Lat_metadata = { "name" : "Lat",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lat.setter
    def Lat(self, pLat:typing.Any) -> None:
        return self._intf.set_property(IAgGeodetic._metadata, IAgGeodetic._set_Lat_metadata, pLat)

    _get_Lon_metadata = { "name" : "Lon",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lon(self) -> typing.Any:
        """Longitude. Uses Longitude Dimension."""
        return self._intf.get_property(IAgGeodetic._metadata, IAgGeodetic._get_Lon_metadata)

    _set_Lon_metadata = { "name" : "Lon",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lon.setter
    def Lon(self, pLon:typing.Any) -> None:
        return self._intf.set_property(IAgGeodetic._metadata, IAgGeodetic._set_Lon_metadata, pLon)

    _get_Alt_metadata = { "name" : "Alt",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Alt(self) -> float:
        """Altitude. Dimension depends on context."""
        return self._intf.get_property(IAgGeodetic._metadata, IAgGeodetic._get_Alt_metadata)

    _set_Alt_metadata = { "name" : "Alt",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Alt.setter
    def Alt(self, pAlt:float) -> None:
        return self._intf.set_property(IAgGeodetic._metadata, IAgGeodetic._set_Alt_metadata, pAlt)


agcls.AgClassCatalog.add_catalog_entry("{93D3322B-C842-48D2-AFCF-BC42B59DB28E}", IAgGeodetic)
agcls.AgTypeNameMap["IAgGeodetic"] = IAgGeodetic

class IAgPlanetodetic(IAgPosition):
    """IAgPlanetodetic sets the position using Planetodetic properties."""
    _num_methods = 6
    _vtable_offset = IAgPosition._vtable_offset + IAgPosition._num_methods
    _metadata = {
        "uuid" : "{E0F982B1-7B17-40F7-B64B-AFD0D112A74C}",
        "vtable_reference" : IAgPosition._vtable_offset + IAgPosition._num_methods - 1,
        "method_offsets" : { "get_Lat" : 1,
                             "set_Lat" : 2,
                             "get_Lon" : 3,
                             "set_Lon" : 4,
                             "get_Alt" : 5,
                             "set_Alt" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgPlanetodetic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgPlanetodetic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgPlanetodetic.__dict__ and type(IAgPlanetodetic.__dict__[attrname]) == property:
            return IAgPlanetodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgPosition.__setattr__(self, attrname, value)
    
    _get_Lat_metadata = { "name" : "Lat",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lat(self) -> typing.Any:
        """Latitude. Uses Latitude Dimension."""
        return self._intf.get_property(IAgPlanetodetic._metadata, IAgPlanetodetic._get_Lat_metadata)

    _set_Lat_metadata = { "name" : "Lat",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lat.setter
    def Lat(self, pLat:typing.Any) -> None:
        return self._intf.set_property(IAgPlanetodetic._metadata, IAgPlanetodetic._set_Lat_metadata, pLat)

    _get_Lon_metadata = { "name" : "Lon",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Lon(self) -> typing.Any:
        """Longitude. Uses Longitude Dimension."""
        return self._intf.get_property(IAgPlanetodetic._metadata, IAgPlanetodetic._get_Lon_metadata)

    _set_Lon_metadata = { "name" : "Lon",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Lon.setter
    def Lon(self, pLon:typing.Any) -> None:
        return self._intf.set_property(IAgPlanetodetic._metadata, IAgPlanetodetic._set_Lon_metadata, pLon)

    _get_Alt_metadata = { "name" : "Alt",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Alt(self) -> float:
        """Altitude. Dimension depends on context."""
        return self._intf.get_property(IAgPlanetodetic._metadata, IAgPlanetodetic._get_Alt_metadata)

    _set_Alt_metadata = { "name" : "Alt",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Alt.setter
    def Alt(self, pAlt:float) -> None:
        return self._intf.set_property(IAgPlanetodetic._metadata, IAgPlanetodetic._set_Alt_metadata, pAlt)


agcls.AgClassCatalog.add_catalog_entry("{E0F982B1-7B17-40F7-B64B-AFD0D112A74C}", IAgPlanetodetic)
agcls.AgTypeNameMap["IAgPlanetodetic"] = IAgPlanetodetic

class IAgDirection(object):
    """Interface to set and retrieve direction options for aligned and constrained vectors."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8304507A-4915-453D-8944-2080659C0257}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "ConvertTo" : 1,
                             "get_DirectionType" : 2,
                             "Assign" : 3,
                             "AssignEuler" : 4,
                             "AssignPR" : 5,
                             "AssignRADec" : 6,
                             "AssignXYZ" : 7,
                             "QueryEuler" : 8,
                             "QueryPR" : 9,
                             "QueryRADec" : 10,
                             "QueryXYZ" : 11,
                             "QueryEulerArray" : 12,
                             "QueryPRArray" : 13,
                             "QueryRADecArray" : 14,
                             "QueryXYZArray" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgDirection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgDirection from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgDirection.__dict__ and type(IAgDirection.__dict__[attrname]) == property:
            return IAgDirection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgDirection.")
    
    _ConvertTo_metadata = { "name" : "ConvertTo",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEDirectionType), agmarshall.AgInterface_out_arg,) }
    def ConvertTo(self, type:"AgEDirectionType") -> "IAgDirection":
        """Method to changes the direction to the type specified."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._ConvertTo_metadata, type, out_arg())

    _get_DirectionType_metadata = { "name" : "DirectionType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEDirectionType),) }
    @property
    def DirectionType(self) -> "AgEDirectionType":
        """Returns the type of direction currently being used."""
        return self._intf.get_property(IAgDirection._metadata, IAgDirection._get_DirectionType_metadata)

    _Assign_metadata = { "name" : "Assign",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgDirection"),) }
    def Assign(self, pDirection:"IAgDirection") -> None:
        """Assign a new direction."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._Assign_metadata, pDirection)

    _AssignEuler_metadata = { "name" : "AssignEuler",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.LONG,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.AgEnum_arg(AgEEulerDirectionSequence),) }
    def AssignEuler(self, b:typing.Any, c:typing.Any, sequence:"AgEEulerDirectionSequence") -> None:
        """Helper method to set direction using the Euler representation. Params B and C use Angle Dimension."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._AssignEuler_metadata, b, c, sequence)

    _AssignPR_metadata = { "name" : "AssignPR",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def AssignPR(self, pitch:typing.Any, roll:typing.Any) -> None:
        """Helper method to set direction using the Pitch Roll representation. Pitch and Roll use Angle Dimension."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._AssignPR_metadata, pitch, roll)

    _AssignRADec_metadata = { "name" : "AssignRADec",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def AssignRADec(self, ra:typing.Any, dec:typing.Any) -> None:
        """Helper method to set direction using the Right Ascension and Declination representation. Param Dec uses Latitude. Param RA uses Longitude."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._AssignRADec_metadata, ra, dec)

    _AssignXYZ_metadata = { "name" : "AssignXYZ",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignXYZ(self, x:float, y:float, z:float) -> None:
        """Helper method to set direction using the Cartesian representation. Params X, Y and Z are dimensionless."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._AssignXYZ_metadata, x, y, z)

    _QueryEuler_metadata = { "name" : "QueryEuler",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT), POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerDirectionSequence), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def QueryEuler(self, sequence:"AgEEulerDirectionSequence") -> typing.Tuple[typing.Any, typing.Any]:
        """Helper method to get direction using the Euler representation. Params B and C use Angle Dimension."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryEuler_metadata, sequence, out_arg(), out_arg())

    _QueryPR_metadata = { "name" : "QueryPR",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT), POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPRSequence), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def QueryPR(self, sequence:"AgEPRSequence") -> typing.Tuple[typing.Any, typing.Any]:
        """Helper method to get direction using the Pitch Roll representation. Pitch and Roll use Angle Dimension."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryPR_metadata, sequence, out_arg(), out_arg())

    _QueryRADec_metadata = { "name" : "QueryRADec",
            "arg_types" : (POINTER(agcom.VARIANT), POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def QueryRADec(self) -> typing.Tuple[typing.Any, typing.Any]:
        """Helper method to get direction using the Right Ascension and Declination representation. Param Dec uses Latitude. Param RA uses Longitude."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryRADec_metadata, out_arg(), out_arg())

    _QueryXYZ_metadata = { "name" : "QueryXYZ",
            "arg_types" : (POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def QueryXYZ(self) -> typing.Tuple[float, float, float]:
        """Helper method to get direction using the Cartesian representation. Params X, Y and Z are dimensionless."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryXYZ_metadata, out_arg(), out_arg(), out_arg())

    _QueryEulerArray_metadata = { "name" : "QueryEulerArray",
            "arg_types" : (agcom.LONG, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerDirectionSequence), agmarshall.LPSAFEARRAY_arg,) }
    def QueryEulerArray(self, sequence:"AgEEulerDirectionSequence") -> list:
        """Returns the Euler elements in an array."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryEulerArray_metadata, sequence, out_arg())

    _QueryPRArray_metadata = { "name" : "QueryPRArray",
            "arg_types" : (agcom.LONG, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPRSequence), agmarshall.LPSAFEARRAY_arg,) }
    def QueryPRArray(self, sequence:"AgEPRSequence") -> list:
        """Returns the PR elements in an array."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryPRArray_metadata, sequence, out_arg())

    _QueryRADecArray_metadata = { "name" : "QueryRADecArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryRADecArray(self) -> list:
        """Returns the RADec elements in an array."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryRADecArray_metadata, out_arg())

    _QueryXYZArray_metadata = { "name" : "QueryXYZArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryXYZArray(self) -> list:
        """Returns the XYZ elements in an array."""
        return self._intf.invoke(IAgDirection._metadata, IAgDirection._QueryXYZArray_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{8304507A-4915-453D-8944-2080659C0257}", IAgDirection)
agcls.AgTypeNameMap["IAgDirection"] = IAgDirection

class IAgDirectionEuler(IAgDirection):
    """Interface for Euler direction sequence."""
    _num_methods = 6
    _vtable_offset = IAgDirection._vtable_offset + IAgDirection._num_methods
    _metadata = {
        "uuid" : "{9CBDC138-72D1-4734-8F95-2140266D37B5}",
        "vtable_reference" : IAgDirection._vtable_offset + IAgDirection._num_methods - 1,
        "method_offsets" : { "get_B" : 1,
                             "set_B" : 2,
                             "get_C" : 3,
                             "set_C" : 4,
                             "get_Sequence" : 5,
                             "set_Sequence" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgDirectionEuler._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgDirectionEuler from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgDirectionEuler.__dict__ and type(IAgDirectionEuler.__dict__[attrname]) == property:
            return IAgDirectionEuler.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgDirection.__setattr__(self, attrname, value)
    
    _get_B_metadata = { "name" : "B",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def B(self) -> typing.Any:
        """Euler B angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgDirectionEuler._metadata, IAgDirectionEuler._get_B_metadata)

    _set_B_metadata = { "name" : "B",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @B.setter
    def B(self, va:typing.Any) -> None:
        return self._intf.set_property(IAgDirectionEuler._metadata, IAgDirectionEuler._set_B_metadata, va)

    _get_C_metadata = { "name" : "C",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def C(self) -> typing.Any:
        """Euler C angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgDirectionEuler._metadata, IAgDirectionEuler._get_C_metadata)

    _set_C_metadata = { "name" : "C",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @C.setter
    def C(self, vb:typing.Any) -> None:
        return self._intf.set_property(IAgDirectionEuler._metadata, IAgDirectionEuler._set_C_metadata, vb)

    _get_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerDirectionSequence),) }
    @property
    def Sequence(self) -> "AgEEulerDirectionSequence":
        """Euler direction sequence.  Must be set before B,C values. Otherwise the B,C values will converted to the Sequence specified."""
        return self._intf.get_property(IAgDirectionEuler._metadata, IAgDirectionEuler._get_Sequence_metadata)

    _set_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerDirectionSequence),) }
    @Sequence.setter
    def Sequence(self, sequence:"AgEEulerDirectionSequence") -> None:
        return self._intf.set_property(IAgDirectionEuler._metadata, IAgDirectionEuler._set_Sequence_metadata, sequence)


agcls.AgClassCatalog.add_catalog_entry("{9CBDC138-72D1-4734-8F95-2140266D37B5}", IAgDirectionEuler)
agcls.AgTypeNameMap["IAgDirectionEuler"] = IAgDirectionEuler

class IAgDirectionPR(IAgDirection):
    """Interface for Pitch-Roll (PR) direction sequence."""
    _num_methods = 6
    _vtable_offset = IAgDirection._vtable_offset + IAgDirection._num_methods
    _metadata = {
        "uuid" : "{5AC01BF1-2B95-4C13-8B69-09FDC485330E}",
        "vtable_reference" : IAgDirection._vtable_offset + IAgDirection._num_methods - 1,
        "method_offsets" : { "get_Pitch" : 1,
                             "set_Pitch" : 2,
                             "get_Roll" : 3,
                             "set_Roll" : 4,
                             "get_Sequence" : 5,
                             "set_Sequence" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgDirectionPR._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgDirectionPR from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgDirectionPR.__dict__ and type(IAgDirectionPR.__dict__[attrname]) == property:
            return IAgDirectionPR.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgDirection.__setattr__(self, attrname, value)
    
    _get_Pitch_metadata = { "name" : "Pitch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Pitch(self) -> typing.Any:
        """Pitch angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgDirectionPR._metadata, IAgDirectionPR._get_Pitch_metadata)

    _set_Pitch_metadata = { "name" : "Pitch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Pitch.setter
    def Pitch(self, vPitch:typing.Any) -> None:
        return self._intf.set_property(IAgDirectionPR._metadata, IAgDirectionPR._set_Pitch_metadata, vPitch)

    _get_Roll_metadata = { "name" : "Roll",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Roll(self) -> typing.Any:
        """Roll angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgDirectionPR._metadata, IAgDirectionPR._get_Roll_metadata)

    _set_Roll_metadata = { "name" : "Roll",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Roll.setter
    def Roll(self, vRoll:typing.Any) -> None:
        return self._intf.set_property(IAgDirectionPR._metadata, IAgDirectionPR._set_Roll_metadata, vRoll)

    _get_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPRSequence),) }
    @property
    def Sequence(self) -> "AgEPRSequence":
        """PR direction sequence. Must be set before Pitch,Roll values. Otherwise the current Pitch,Roll values will be converted to the Sequence specified."""
        return self._intf.get_property(IAgDirectionPR._metadata, IAgDirectionPR._get_Sequence_metadata)

    _set_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPRSequence),) }
    @Sequence.setter
    def Sequence(self, sequence:"AgEPRSequence") -> None:
        return self._intf.set_property(IAgDirectionPR._metadata, IAgDirectionPR._set_Sequence_metadata, sequence)


agcls.AgClassCatalog.add_catalog_entry("{5AC01BF1-2B95-4C13-8B69-09FDC485330E}", IAgDirectionPR)
agcls.AgTypeNameMap["IAgDirectionPR"] = IAgDirectionPR

class IAgDirectionRADec(IAgDirection):
    """Interface for Spherical direction (Right Ascension and Declination)."""
    _num_methods = 6
    _vtable_offset = IAgDirection._vtable_offset + IAgDirection._num_methods
    _metadata = {
        "uuid" : "{A921E587-EC8A-4F1E-99BB-6E13B8E0D5E7}",
        "vtable_reference" : IAgDirection._vtable_offset + IAgDirection._num_methods - 1,
        "method_offsets" : { "get_Dec" : 1,
                             "set_Dec" : 2,
                             "get_RA" : 3,
                             "set_RA" : 4,
                             "get_Magnitude" : 5,
                             "set_Magnitude" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgDirectionRADec._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgDirectionRADec from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgDirectionRADec.__dict__ and type(IAgDirectionRADec.__dict__[attrname]) == property:
            return IAgDirectionRADec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgDirection.__setattr__(self, attrname, value)
    
    _get_Dec_metadata = { "name" : "Dec",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Dec(self) -> typing.Any:
        """Declination: angle above the x-y plane. Uses Latitude Dimension."""
        return self._intf.get_property(IAgDirectionRADec._metadata, IAgDirectionRADec._get_Dec_metadata)

    _set_Dec_metadata = { "name" : "Dec",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Dec.setter
    def Dec(self, vLat:typing.Any) -> None:
        return self._intf.set_property(IAgDirectionRADec._metadata, IAgDirectionRADec._set_Dec_metadata, vLat)

    _get_RA_metadata = { "name" : "RA",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def RA(self) -> typing.Any:
        """Right Ascension: angle in x-y plane from x towards y. Uses Longitude Dimension."""
        return self._intf.get_property(IAgDirectionRADec._metadata, IAgDirectionRADec._get_RA_metadata)

    _set_RA_metadata = { "name" : "RA",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @RA.setter
    def RA(self, vLon:typing.Any) -> None:
        return self._intf.set_property(IAgDirectionRADec._metadata, IAgDirectionRADec._set_RA_metadata, vLon)

    _get_Magnitude_metadata = { "name" : "Magnitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Magnitude(self) -> float:
        """A unitless value that represents magnitude."""
        return self._intf.get_property(IAgDirectionRADec._metadata, IAgDirectionRADec._get_Magnitude_metadata)

    _set_Magnitude_metadata = { "name" : "Magnitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Magnitude.setter
    def Magnitude(self, magnitude:float) -> None:
        return self._intf.set_property(IAgDirectionRADec._metadata, IAgDirectionRADec._set_Magnitude_metadata, magnitude)


agcls.AgClassCatalog.add_catalog_entry("{A921E587-EC8A-4F1E-99BB-6E13B8E0D5E7}", IAgDirectionRADec)
agcls.AgTypeNameMap["IAgDirectionRADec"] = IAgDirectionRADec

class IAgDirectionXYZ(IAgDirection):
    """Interface for Cartesian direction."""
    _num_methods = 6
    _vtable_offset = IAgDirection._vtable_offset + IAgDirection._num_methods
    _metadata = {
        "uuid" : "{2B499A22-6662-4F20-8B82-AA7701CD87A4}",
        "vtable_reference" : IAgDirection._vtable_offset + IAgDirection._num_methods - 1,
        "method_offsets" : { "get_X" : 1,
                             "set_X" : 2,
                             "get_Y" : 3,
                             "set_Y" : 4,
                             "get_Z" : 5,
                             "set_Z" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgDirectionXYZ._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgDirectionXYZ from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgDirectionXYZ.__dict__ and type(IAgDirectionXYZ.__dict__[attrname]) == property:
            return IAgDirectionXYZ.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgDirection.__setattr__(self, attrname, value)
    
    _get_X_metadata = { "name" : "X",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def X(self) -> float:
        """X component. Dimensionless"""
        return self._intf.get_property(IAgDirectionXYZ._metadata, IAgDirectionXYZ._get_X_metadata)

    _set_X_metadata = { "name" : "X",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @X.setter
    def X(self, vx:float) -> None:
        return self._intf.set_property(IAgDirectionXYZ._metadata, IAgDirectionXYZ._set_X_metadata, vx)

    _get_Y_metadata = { "name" : "Y",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Y(self) -> float:
        """Y component. Dimensionless"""
        return self._intf.get_property(IAgDirectionXYZ._metadata, IAgDirectionXYZ._get_Y_metadata)

    _set_Y_metadata = { "name" : "Y",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Y.setter
    def Y(self, vy:float) -> None:
        return self._intf.set_property(IAgDirectionXYZ._metadata, IAgDirectionXYZ._set_Y_metadata, vy)

    _get_Z_metadata = { "name" : "Z",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Z(self) -> float:
        """Z component. Dimensionless"""
        return self._intf.get_property(IAgDirectionXYZ._metadata, IAgDirectionXYZ._get_Z_metadata)

    _set_Z_metadata = { "name" : "Z",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Z.setter
    def Z(self, vz:float) -> None:
        return self._intf.set_property(IAgDirectionXYZ._metadata, IAgDirectionXYZ._set_Z_metadata, vz)


agcls.AgClassCatalog.add_catalog_entry("{2B499A22-6662-4F20-8B82-AA7701CD87A4}", IAgDirectionXYZ)
agcls.AgTypeNameMap["IAgDirectionXYZ"] = IAgDirectionXYZ

class IAgCartesian3Vector(object):
    """Represents a cartesian 3-D vector."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7B741836-71F9-4115-97F8-EAB30362E5C7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_X" : 1,
                             "set_X" : 2,
                             "get_Y" : 3,
                             "set_Y" : 4,
                             "get_Z" : 5,
                             "set_Z" : 6,
                             "Get" : 7,
                             "Set" : 8,
                             "ToArray" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCartesian3Vector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCartesian3Vector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCartesian3Vector.__dict__ and type(IAgCartesian3Vector.__dict__[attrname]) == property:
            return IAgCartesian3Vector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCartesian3Vector.")
    
    _get_X_metadata = { "name" : "X",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def X(self) -> float:
        """X coordinate"""
        return self._intf.get_property(IAgCartesian3Vector._metadata, IAgCartesian3Vector._get_X_metadata)

    _set_X_metadata = { "name" : "X",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @X.setter
    def X(self, x:float) -> None:
        return self._intf.set_property(IAgCartesian3Vector._metadata, IAgCartesian3Vector._set_X_metadata, x)

    _get_Y_metadata = { "name" : "Y",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Y(self) -> float:
        """Y coordinate"""
        return self._intf.get_property(IAgCartesian3Vector._metadata, IAgCartesian3Vector._get_Y_metadata)

    _set_Y_metadata = { "name" : "Y",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Y.setter
    def Y(self, y:float) -> None:
        return self._intf.set_property(IAgCartesian3Vector._metadata, IAgCartesian3Vector._set_Y_metadata, y)

    _get_Z_metadata = { "name" : "Z",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Z(self) -> float:
        """Z coordinate"""
        return self._intf.get_property(IAgCartesian3Vector._metadata, IAgCartesian3Vector._get_Z_metadata)

    _set_Z_metadata = { "name" : "Z",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Z.setter
    def Z(self, z:float) -> None:
        return self._intf.set_property(IAgCartesian3Vector._metadata, IAgCartesian3Vector._set_Z_metadata, z)

    _Get_metadata = { "name" : "Get",
            "arg_types" : (POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def Get(self) -> typing.Tuple[float, float, float]:
        """Returns cartesian vector"""
        return self._intf.invoke(IAgCartesian3Vector._metadata, IAgCartesian3Vector._Get_metadata, out_arg(), out_arg(), out_arg())

    _Set_metadata = { "name" : "Set",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def Set(self, x:float, y:float, z:float) -> None:
        """Sets cartesian vector"""
        return self._intf.invoke(IAgCartesian3Vector._metadata, IAgCartesian3Vector._Set_metadata, x, y, z)

    _ToArray_metadata = { "name" : "ToArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def ToArray(self) -> list:
        """Returns coordinates as an array."""
        return self._intf.invoke(IAgCartesian3Vector._metadata, IAgCartesian3Vector._ToArray_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7B741836-71F9-4115-97F8-EAB30362E5C7}", IAgCartesian3Vector)
agcls.AgTypeNameMap["IAgCartesian3Vector"] = IAgCartesian3Vector

class IAgOrientation(object):
    """Interface to set and retrieve the orientation method."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8467175F-1BD8-4498-90FD-08C67072D120}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "ConvertTo" : 1,
                             "get_OrientationType" : 2,
                             "Assign" : 3,
                             "AssignAzEl" : 4,
                             "AssignEulerAngles" : 5,
                             "AssignQuaternion" : 6,
                             "AssignYPRAngles" : 7,
                             "QueryAzEl" : 8,
                             "QueryEulerAngles" : 9,
                             "QueryQuaternion" : 10,
                             "QueryYPRAngles" : 11,
                             "QueryAzElArray" : 12,
                             "QueryEulerAnglesArray" : 13,
                             "QueryQuaternionArray" : 14,
                             "QueryYPRAnglesArray" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgOrientation._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgOrientation from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgOrientation.__dict__ and type(IAgOrientation.__dict__[attrname]) == property:
            return IAgOrientation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgOrientation.")
    
    _ConvertTo_metadata = { "name" : "ConvertTo",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEOrientationType), agmarshall.AgInterface_out_arg,) }
    def ConvertTo(self, type:"AgEOrientationType") -> "IAgOrientation":
        """Method to change the orientation method to the type specified."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._ConvertTo_metadata, type, out_arg())

    _get_OrientationType_metadata = { "name" : "OrientationType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEOrientationType),) }
    @property
    def OrientationType(self) -> "AgEOrientationType":
        """Returns the orientation method currently being used."""
        return self._intf.get_property(IAgOrientation._metadata, IAgOrientation._get_OrientationType_metadata)

    _Assign_metadata = { "name" : "Assign",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgOrientation"),) }
    def Assign(self, pOrientation:"IAgOrientation") -> None:
        """Assign a new orientation method."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._Assign_metadata, pOrientation)

    _AssignAzEl_metadata = { "name" : "AssignAzEl",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.LONG,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.AgEnum_arg(AgEAzElAboutBoresight),) }
    def AssignAzEl(self, azimuth:typing.Any, elevation:typing.Any, aboutBoresight:"AgEAzElAboutBoresight") -> None:
        """Helper method to set orientation using the AzEl representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._AssignAzEl_metadata, azimuth, elevation, aboutBoresight)

    _AssignEulerAngles_metadata = { "name" : "AssignEulerAngles",
            "arg_types" : (agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerOrientationSequence), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def AssignEulerAngles(self, sequence:"AgEEulerOrientationSequence", a:typing.Any, b:typing.Any, c:typing.Any) -> None:
        """Helper method to set orientation using the Euler angles representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._AssignEulerAngles_metadata, sequence, a, b, c)

    _AssignQuaternion_metadata = { "name" : "AssignQuaternion",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignQuaternion(self, qx:float, qy:float, qz:float, qs:float) -> None:
        """Helper method to set orientation using the Quaternion representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._AssignQuaternion_metadata, qx, qy, qz, qs)

    _AssignYPRAngles_metadata = { "name" : "AssignYPRAngles",
            "arg_types" : (agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.AgEnum_arg(AgEYPRAnglesSequence), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def AssignYPRAngles(self, sequence:"AgEYPRAnglesSequence", yaw:typing.Any, pitch:typing.Any, roll:typing.Any) -> None:
        """Helper method to set orientation using the YPR angles representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._AssignYPRAngles_metadata, sequence, yaw, pitch, roll)

    _QueryAzEl_metadata = { "name" : "QueryAzEl",
            "arg_types" : (POINTER(agcom.VARIANT), POINTER(agcom.VARIANT), POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.AgEnum_arg(AgEAzElAboutBoresight),) }
    def QueryAzEl(self) -> typing.Tuple[typing.Any, typing.Any, AgEAzElAboutBoresight]:
        """Helper method to get orientation using the AzEl representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryAzEl_metadata, out_arg(), out_arg(), out_arg())

    _QueryEulerAngles_metadata = { "name" : "QueryEulerAngles",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT), POINTER(agcom.VARIANT), POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerOrientationSequence), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def QueryEulerAngles(self, sequence:"AgEEulerOrientationSequence") -> typing.Tuple[typing.Any, typing.Any, typing.Any]:
        """Helper method to get orientation using the Euler angles representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryEulerAngles_metadata, sequence, out_arg(), out_arg(), out_arg())

    _QueryQuaternion_metadata = { "name" : "QueryQuaternion",
            "arg_types" : (POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def QueryQuaternion(self) -> typing.Tuple[float, float, float, float]:
        """Helper method to get orientation using the Quaternion representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryQuaternion_metadata, out_arg(), out_arg(), out_arg(), out_arg())

    _QueryYPRAngles_metadata = { "name" : "QueryYPRAngles",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT), POINTER(agcom.VARIANT), POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEYPRAnglesSequence), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def QueryYPRAngles(self, sequence:"AgEYPRAnglesSequence") -> typing.Tuple[typing.Any, typing.Any, typing.Any]:
        """Helper method to get orientation using the YPR angles representation."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryYPRAngles_metadata, sequence, out_arg(), out_arg(), out_arg())

    _QueryAzElArray_metadata = { "name" : "QueryAzElArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryAzElArray(self) -> list:
        """Returns the AzEl elements as an array."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryAzElArray_metadata, out_arg())

    _QueryEulerAnglesArray_metadata = { "name" : "QueryEulerAnglesArray",
            "arg_types" : (agcom.LONG, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerOrientationSequence), agmarshall.LPSAFEARRAY_arg,) }
    def QueryEulerAnglesArray(self, sequence:"AgEEulerOrientationSequence") -> list:
        """Returns the Euler elements as an array."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryEulerAnglesArray_metadata, sequence, out_arg())

    _QueryQuaternionArray_metadata = { "name" : "QueryQuaternionArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def QueryQuaternionArray(self) -> list:
        """Returns the Quaternion elements as an array."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryQuaternionArray_metadata, out_arg())

    _QueryYPRAnglesArray_metadata = { "name" : "QueryYPRAnglesArray",
            "arg_types" : (agcom.LONG, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEYPRAnglesSequence), agmarshall.LPSAFEARRAY_arg,) }
    def QueryYPRAnglesArray(self, sequence:"AgEYPRAnglesSequence") -> list:
        """Returns the YPR Angles elements as an array."""
        return self._intf.invoke(IAgOrientation._metadata, IAgOrientation._QueryYPRAnglesArray_metadata, sequence, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{8467175F-1BD8-4498-90FD-08C67072D120}", IAgOrientation)
agcls.AgTypeNameMap["IAgOrientation"] = IAgOrientation

class IAgOrientationAzEl(IAgOrientation):
    """Interface for AzEl orientation method."""
    _num_methods = 6
    _vtable_offset = IAgOrientation._vtable_offset + IAgOrientation._num_methods
    _metadata = {
        "uuid" : "{6A6B1D7D-6A7F-48B3-98CA-019CA46499FE}",
        "vtable_reference" : IAgOrientation._vtable_offset + IAgOrientation._num_methods - 1,
        "method_offsets" : { "get_Azimuth" : 1,
                             "set_Azimuth" : 2,
                             "get_Elevation" : 3,
                             "set_Elevation" : 4,
                             "get_AboutBoresight" : 5,
                             "set_AboutBoresight" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgOrientationAzEl._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgOrientationAzEl from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgOrientationAzEl.__dict__ and type(IAgOrientationAzEl.__dict__[attrname]) == property:
            return IAgOrientationAzEl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgOrientation.__setattr__(self, attrname, value)
    
    _get_Azimuth_metadata = { "name" : "Azimuth",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Azimuth(self) -> typing.Any:
        """Measured in the XY plane of the parent reference frame about its Z axis in the right-handed sense for both vehicle-based sensors and facility-based sensors. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationAzEl._metadata, IAgOrientationAzEl._get_Azimuth_metadata)

    _set_Azimuth_metadata = { "name" : "Azimuth",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Azimuth.setter
    def Azimuth(self, vAzimuth:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationAzEl._metadata, IAgOrientationAzEl._set_Azimuth_metadata, vAzimuth)

    _get_Elevation_metadata = { "name" : "Elevation",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Elevation(self) -> typing.Any:
        """Defined as the angle between the XY plane of the parent reference frame and the sensor or antenna boresight measured toward the positive Z axis. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationAzEl._metadata, IAgOrientationAzEl._get_Elevation_metadata)

    _set_Elevation_metadata = { "name" : "Elevation",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Elevation.setter
    def Elevation(self, vElevation:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationAzEl._metadata, IAgOrientationAzEl._set_Elevation_metadata, vElevation)

    _get_AboutBoresight_metadata = { "name" : "AboutBoresight",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEAzElAboutBoresight),) }
    @property
    def AboutBoresight(self) -> "AgEAzElAboutBoresight":
        """Determines orientation of the X and Y axes with respect to the parent's reference frame."""
        return self._intf.get_property(IAgOrientationAzEl._metadata, IAgOrientationAzEl._get_AboutBoresight_metadata)

    _set_AboutBoresight_metadata = { "name" : "AboutBoresight",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgEAzElAboutBoresight),) }
    @AboutBoresight.setter
    def AboutBoresight(self, aboutBoresight:"AgEAzElAboutBoresight") -> None:
        return self._intf.set_property(IAgOrientationAzEl._metadata, IAgOrientationAzEl._set_AboutBoresight_metadata, aboutBoresight)


agcls.AgClassCatalog.add_catalog_entry("{6A6B1D7D-6A7F-48B3-98CA-019CA46499FE}", IAgOrientationAzEl)
agcls.AgTypeNameMap["IAgOrientationAzEl"] = IAgOrientationAzEl

class IAgOrientationEulerAngles(IAgOrientation):
    """Interface for Euler Angles orientation method."""
    _num_methods = 8
    _vtable_offset = IAgOrientation._vtable_offset + IAgOrientation._num_methods
    _metadata = {
        "uuid" : "{4204C7E1-EC21-40AD-A905-BB35A3FDF7BD}",
        "vtable_reference" : IAgOrientation._vtable_offset + IAgOrientation._num_methods - 1,
        "method_offsets" : { "get_Sequence" : 1,
                             "set_Sequence" : 2,
                             "get_A" : 3,
                             "set_A" : 4,
                             "get_B" : 5,
                             "set_B" : 6,
                             "get_C" : 7,
                             "set_C" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgOrientationEulerAngles._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgOrientationEulerAngles from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgOrientationEulerAngles.__dict__ and type(IAgOrientationEulerAngles.__dict__[attrname]) == property:
            return IAgOrientationEulerAngles.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgOrientation.__setattr__(self, attrname, value)
    
    _get_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerOrientationSequence),) }
    @property
    def Sequence(self) -> "AgEEulerOrientationSequence":
        """Euler rotation sequence. Must be set before A,B,C values. Otherwise the current A,B,C values will be converted to the Sequence specified."""
        return self._intf.get_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._get_Sequence_metadata)

    _set_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgEEulerOrientationSequence),) }
    @Sequence.setter
    def Sequence(self, ppVal:"AgEEulerOrientationSequence") -> None:
        return self._intf.set_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._set_Sequence_metadata, ppVal)

    _get_A_metadata = { "name" : "A",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def A(self) -> typing.Any:
        """Euler A angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._get_A_metadata)

    _set_A_metadata = { "name" : "A",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @A.setter
    def A(self, va:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._set_A_metadata, va)

    _get_B_metadata = { "name" : "B",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def B(self) -> typing.Any:
        """Euler b angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._get_B_metadata)

    _set_B_metadata = { "name" : "B",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @B.setter
    def B(self, vb:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._set_B_metadata, vb)

    _get_C_metadata = { "name" : "C",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def C(self) -> typing.Any:
        """Euler C angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._get_C_metadata)

    _set_C_metadata = { "name" : "C",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @C.setter
    def C(self, vc:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationEulerAngles._metadata, IAgOrientationEulerAngles._set_C_metadata, vc)


agcls.AgClassCatalog.add_catalog_entry("{4204C7E1-EC21-40AD-A905-BB35A3FDF7BD}", IAgOrientationEulerAngles)
agcls.AgTypeNameMap["IAgOrientationEulerAngles"] = IAgOrientationEulerAngles

class IAgOrientationQuaternion(IAgOrientation):
    """Interface for Quaternion orientation method."""
    _num_methods = 8
    _vtable_offset = IAgOrientation._vtable_offset + IAgOrientation._num_methods
    _metadata = {
        "uuid" : "{101FAC5C-8DDB-4D4F-9C73-58146CA8EB01}",
        "vtable_reference" : IAgOrientation._vtable_offset + IAgOrientation._num_methods - 1,
        "method_offsets" : { "get_QX" : 1,
                             "set_QX" : 2,
                             "get_QY" : 3,
                             "set_QY" : 4,
                             "get_QZ" : 5,
                             "set_QZ" : 6,
                             "get_QS" : 7,
                             "set_QS" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgOrientationQuaternion._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgOrientationQuaternion from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgOrientationQuaternion.__dict__ and type(IAgOrientationQuaternion.__dict__[attrname]) == property:
            return IAgOrientationQuaternion.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgOrientation.__setattr__(self, attrname, value)
    
    _get_QX_metadata = { "name" : "QX",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def QX(self) -> float:
        """The first element of the vector component of the quaternion representing orientation between two sets of axes. This quaternion is from the reference axes to the body frame; if n and A are the axis and angle of rotation, respectively, then QX = nx si..."""
        return self._intf.get_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._get_QX_metadata)

    _set_QX_metadata = { "name" : "QX",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @QX.setter
    def QX(self, vQX:float) -> None:
        return self._intf.set_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._set_QX_metadata, vQX)

    _get_QY_metadata = { "name" : "QY",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def QY(self) -> float:
        """The second element of the vector component of the quaternion representing orientation between two sets of axes. This quaternion is from the reference axes to the body frame; if n and A are the axis and angle of rotation, respectively, then QY = ny s..."""
        return self._intf.get_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._get_QY_metadata)

    _set_QY_metadata = { "name" : "QY",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @QY.setter
    def QY(self, vQY:float) -> None:
        return self._intf.set_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._set_QY_metadata, vQY)

    _get_QZ_metadata = { "name" : "QZ",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def QZ(self) -> float:
        """The third element of the vector component of the quaternion representing orientation between two sets of axes. This quaternion is from the reference axes to the body frame; if n and A are the axis and angle of rotation, respectively, then QZ = nz si..."""
        return self._intf.get_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._get_QZ_metadata)

    _set_QZ_metadata = { "name" : "QZ",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @QZ.setter
    def QZ(self, vQZ:float) -> None:
        return self._intf.set_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._set_QZ_metadata, vQZ)

    _get_QS_metadata = { "name" : "QS",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def QS(self) -> float:
        """The scalar component of the quaternion representing orientation between two sets of axes. This quaternion is from the reference axes to the body frame; if n and A are the axis and angle of rotation, respectively, then QS = cos(A/2). Dimensionless."""
        return self._intf.get_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._get_QS_metadata)

    _set_QS_metadata = { "name" : "QS",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @QS.setter
    def QS(self, vQS:float) -> None:
        return self._intf.set_property(IAgOrientationQuaternion._metadata, IAgOrientationQuaternion._set_QS_metadata, vQS)


agcls.AgClassCatalog.add_catalog_entry("{101FAC5C-8DDB-4D4F-9C73-58146CA8EB01}", IAgOrientationQuaternion)
agcls.AgTypeNameMap["IAgOrientationQuaternion"] = IAgOrientationQuaternion

class IAgOrientationYPRAngles(IAgOrientation):
    """Interface for Yaw-Pitch Roll (YPR) Angles orientation system."""
    _num_methods = 8
    _vtable_offset = IAgOrientation._vtable_offset + IAgOrientation._num_methods
    _metadata = {
        "uuid" : "{97A9D45D-E718-41FC-ACD2-CEBBEFD2011B}",
        "vtable_reference" : IAgOrientation._vtable_offset + IAgOrientation._num_methods - 1,
        "method_offsets" : { "get_Sequence" : 1,
                             "set_Sequence" : 2,
                             "get_Yaw" : 3,
                             "set_Yaw" : 4,
                             "get_Pitch" : 5,
                             "set_Pitch" : 6,
                             "get_Roll" : 7,
                             "set_Roll" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgOrientationYPRAngles._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgOrientationYPRAngles from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgOrientationYPRAngles.__dict__ and type(IAgOrientationYPRAngles.__dict__[attrname]) == property:
            return IAgOrientationYPRAngles.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAgOrientation.__setattr__(self, attrname, value)
    
    _get_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEYPRAnglesSequence),) }
    @property
    def Sequence(self) -> "AgEYPRAnglesSequence":
        """YPR sequence. Must be set before Yaw,Pitch,Roll values. Otherwise the current Yaw,Pitch,Roll values will be converted to the Sequence specified."""
        return self._intf.get_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._get_Sequence_metadata)

    _set_Sequence_metadata = { "name" : "Sequence",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgEYPRAnglesSequence),) }
    @Sequence.setter
    def Sequence(self, sequence:"AgEYPRAnglesSequence") -> None:
        return self._intf.set_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._set_Sequence_metadata, sequence)

    _get_Yaw_metadata = { "name" : "Yaw",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Yaw(self) -> typing.Any:
        """Yaw angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._get_Yaw_metadata)

    _set_Yaw_metadata = { "name" : "Yaw",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Yaw.setter
    def Yaw(self, vYaw:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._set_Yaw_metadata, vYaw)

    _get_Pitch_metadata = { "name" : "Pitch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Pitch(self) -> typing.Any:
        """Pitch angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._get_Pitch_metadata)

    _set_Pitch_metadata = { "name" : "Pitch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Pitch.setter
    def Pitch(self, vPitch:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._set_Pitch_metadata, vPitch)

    _get_Roll_metadata = { "name" : "Roll",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Roll(self) -> typing.Any:
        """Roll angle. Uses Angle Dimension."""
        return self._intf.get_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._get_Roll_metadata)

    _set_Roll_metadata = { "name" : "Roll",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Roll.setter
    def Roll(self, vRoll:typing.Any) -> None:
        return self._intf.set_property(IAgOrientationYPRAngles._metadata, IAgOrientationYPRAngles._set_Roll_metadata, vRoll)


agcls.AgClassCatalog.add_catalog_entry("{97A9D45D-E718-41FC-ACD2-CEBBEFD2011B}", IAgOrientationYPRAngles)
agcls.AgTypeNameMap["IAgOrientationYPRAngles"] = IAgOrientationYPRAngles

class IAgOrientationPositionOffset(object):
    """Interface for defining the orientation origin position offset relative to the parent object."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0DDA686C-559C-4BEA-969B-BF40708242B6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_PositionOffset" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgOrientationPositionOffset._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgOrientationPositionOffset from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgOrientationPositionOffset.__dict__ and type(IAgOrientationPositionOffset.__dict__[attrname]) == property:
            return IAgOrientationPositionOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgOrientationPositionOffset.")
    
    _get_PositionOffset_metadata = { "name" : "PositionOffset",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def PositionOffset(self) -> "IAgCartesian3Vector":
        """Gets or sets the position offset cartesian vector."""
        return self._intf.get_property(IAgOrientationPositionOffset._metadata, IAgOrientationPositionOffset._get_PositionOffset_metadata)


agcls.AgClassCatalog.add_catalog_entry("{0DDA686C-559C-4BEA-969B-BF40708242B6}", IAgOrientationPositionOffset)
agcls.AgTypeNameMap["IAgOrientationPositionOffset"] = IAgOrientationPositionOffset

class IAgOrbitState(object):
    """Interface to set and retrieve the coordinate type used to specify the orbit state."""
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{42342AD2-F6C5-426B-AB2A-3688F05353C8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "ConvertTo" : 1,
                             "get_OrbitStateType" : 2,
                             "Assign" : 3,
                             "AssignClassical" : 4,
                             "AssignCartesian" : 5,
                             "AssignGeodetic" : 6,
                             "AssignEquinoctialPosigrade" : 7,
                             "AssignEquinoctialRetrograde" : 8,
                             "AssignMixedSpherical" : 9,
                             "AssignSpherical" : 10,
                             "get_CentralBodyName" : 11,
                             "get_Epoch" : 12,
                             "set_Epoch" : 13, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgOrbitState._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgOrbitState from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgOrbitState.__dict__ and type(IAgOrbitState.__dict__[attrname]) == property:
            return IAgOrbitState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgOrbitState.")
    
    _ConvertTo_metadata = { "name" : "ConvertTo",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEOrbitStateType), agmarshall.AgInterface_out_arg,) }
    def ConvertTo(self, type:"AgEOrbitStateType") -> "IAgOrbitState":
        """Method to changes the coordinate type to the type specified."""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._ConvertTo_metadata, type, out_arg())

    _get_OrbitStateType_metadata = { "name" : "OrbitStateType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEOrbitStateType),) }
    @property
    def OrbitStateType(self) -> "AgEOrbitStateType":
        """Returns the coordinate type currently being used."""
        return self._intf.get_property(IAgOrbitState._metadata, IAgOrbitState._get_OrbitStateType_metadata)

    _Assign_metadata = { "name" : "Assign",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgOrbitState"),) }
    def Assign(self, pOrbitState:"IAgOrbitState") -> None:
        """Assign a new coordinate type."""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._Assign_metadata, pOrbitState)

    _AssignClassical_metadata = { "name" : "AssignClassical",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECoordinateSystem), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignClassical(self, eCoordinateSystem:"AgECoordinateSystem", semiMajorAxis:float, eccentricity:float, inclination:float, argOfPerigee:float, rAAN:float, meanAnomaly:float) -> None:
        """Helper method to assign a new orbit state using Classical representation"""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._AssignClassical_metadata, eCoordinateSystem, semiMajorAxis, eccentricity, inclination, argOfPerigee, rAAN, meanAnomaly)

    _AssignCartesian_metadata = { "name" : "AssignCartesian",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECoordinateSystem), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignCartesian(self, eCoordinateSystem:"AgECoordinateSystem", xPosition:float, yPosition:float, zPosition:float, xVelocity:float, yVelocity:float, zVelocity:float) -> None:
        """Helper method to assign a new orbit state using Cartesian representation"""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._AssignCartesian_metadata, eCoordinateSystem, xPosition, yPosition, zPosition, xVelocity, yVelocity, zVelocity)

    _AssignGeodetic_metadata = { "name" : "AssignGeodetic",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECoordinateSystem), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignGeodetic(self, eCoordinateSystem:"AgECoordinateSystem", latitude:float, longitude:float, altitude:float, latitudeRate:float, longitudeRate:float, altitudeRate:float) -> None:
        """Helper method to assign a new orbit state using Geodetic representation"""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._AssignGeodetic_metadata, eCoordinateSystem, latitude, longitude, altitude, latitudeRate, longitudeRate, altitudeRate)

    _AssignEquinoctialPosigrade_metadata = { "name" : "AssignEquinoctialPosigrade",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECoordinateSystem), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignEquinoctialPosigrade(self, eCoordinateSystem:"AgECoordinateSystem", semiMajorAxis:float, h:float, k:float, p:float, q:float, meanLon:float) -> None:
        """Helper method to assign a new orbit state using Equinoctial representation"""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._AssignEquinoctialPosigrade_metadata, eCoordinateSystem, semiMajorAxis, h, k, p, q, meanLon)

    _AssignEquinoctialRetrograde_metadata = { "name" : "AssignEquinoctialRetrograde",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECoordinateSystem), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignEquinoctialRetrograde(self, eCoordinateSystem:"AgECoordinateSystem", semiMajorAxis:float, h:float, k:float, p:float, q:float, meanLon:float) -> None:
        """Helper method to assign a new orbit state using Equinoctial representation"""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._AssignEquinoctialRetrograde_metadata, eCoordinateSystem, semiMajorAxis, h, k, p, q, meanLon)

    _AssignMixedSpherical_metadata = { "name" : "AssignMixedSpherical",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECoordinateSystem), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignMixedSpherical(self, eCoordinateSystem:"AgECoordinateSystem", latitude:float, longitude:float, altitude:float, horFlightPathAngle:float, flightPathAzimuth:float, velocity:float) -> None:
        """Helper method to assign a new orbit state using Mixed Spherical representation"""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._AssignMixedSpherical_metadata, eCoordinateSystem, latitude, longitude, altitude, horFlightPathAngle, flightPathAzimuth, velocity)

    _AssignSpherical_metadata = { "name" : "AssignSpherical",
            "arg_types" : (agcom.LONG, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECoordinateSystem), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def AssignSpherical(self, eCoordinateSystem:"AgECoordinateSystem", rightAscension:float, declination:float, radius:float, horFlightPathAngle:float, flightPathAzimuth:float, velocity:float) -> None:
        """Helper method to assign a new orbit state using Spherical representation"""
        return self._intf.invoke(IAgOrbitState._metadata, IAgOrbitState._AssignSpherical_metadata, eCoordinateSystem, rightAscension, declination, radius, horFlightPathAngle, flightPathAzimuth, velocity)

    _get_CentralBodyName_metadata = { "name" : "CentralBodyName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def CentralBodyName(self) -> str:
        """Gets the central body."""
        return self._intf.get_property(IAgOrbitState._metadata, IAgOrbitState._get_CentralBodyName_metadata)

    _get_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Epoch(self) -> typing.Any:
        """The state epoch"""
        return self._intf.get_property(IAgOrbitState._metadata, IAgOrbitState._get_Epoch_metadata)

    _set_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IAgOrbitState._metadata, IAgOrbitState._set_Epoch_metadata, epoch)


agcls.AgClassCatalog.add_catalog_entry("{42342AD2-F6C5-426B-AB2A-3688F05353C8}", IAgOrbitState)
agcls.AgTypeNameMap["IAgOrbitState"] = IAgOrbitState

class IAgCartesian2Vector(object):
    """Represents a cartesian 2-D vector."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DA459BD7-5810-4B30-8397-21EDA9E52D2B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_X" : 1,
                             "set_X" : 2,
                             "get_Y" : 3,
                             "set_Y" : 4,
                             "Get" : 5,
                             "Set" : 6,
                             "ToArray" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCartesian2Vector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCartesian2Vector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCartesian2Vector.__dict__ and type(IAgCartesian2Vector.__dict__[attrname]) == property:
            return IAgCartesian2Vector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCartesian2Vector.")
    
    _get_X_metadata = { "name" : "X",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def X(self) -> float:
        """X coordinate"""
        return self._intf.get_property(IAgCartesian2Vector._metadata, IAgCartesian2Vector._get_X_metadata)

    _set_X_metadata = { "name" : "X",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @X.setter
    def X(self, x:float) -> None:
        return self._intf.set_property(IAgCartesian2Vector._metadata, IAgCartesian2Vector._set_X_metadata, x)

    _get_Y_metadata = { "name" : "Y",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Y(self) -> float:
        """Y coordinate"""
        return self._intf.get_property(IAgCartesian2Vector._metadata, IAgCartesian2Vector._get_Y_metadata)

    _set_Y_metadata = { "name" : "Y",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Y.setter
    def Y(self, y:float) -> None:
        return self._intf.set_property(IAgCartesian2Vector._metadata, IAgCartesian2Vector._set_Y_metadata, y)

    _Get_metadata = { "name" : "Get",
            "arg_types" : (POINTER(agcom.DOUBLE), POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def Get(self) -> typing.Tuple[float, float]:
        """Returns cartesian vector"""
        return self._intf.invoke(IAgCartesian2Vector._metadata, IAgCartesian2Vector._Get_metadata, out_arg(), out_arg())

    _Set_metadata = { "name" : "Set",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def Set(self, x:float, y:float) -> None:
        """Sets cartesian vector"""
        return self._intf.invoke(IAgCartesian2Vector._metadata, IAgCartesian2Vector._Set_metadata, x, y)

    _ToArray_metadata = { "name" : "ToArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def ToArray(self) -> list:
        """Returns coordinates as an array."""
        return self._intf.invoke(IAgCartesian2Vector._metadata, IAgCartesian2Vector._ToArray_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{DA459BD7-5810-4B30-8397-21EDA9E52D2B}", IAgCartesian2Vector)
agcls.AgTypeNameMap["IAgCartesian2Vector"] = IAgCartesian2Vector

class IAgUnitPrefsDim(object):
    """Provides info on a Dimension from the global unit table."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AA966FFD-1A99-45D8-9193-C519BBBA99FA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Id" : 1,
                             "get_Name" : 2,
                             "get_AvailableUnits" : 3,
                             "get_CurrentUnit" : 4,
                             "SetCurrentUnit" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgUnitPrefsDim._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgUnitPrefsDim from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgUnitPrefsDim.__dict__ and type(IAgUnitPrefsDim.__dict__[attrname]) == property:
            return IAgUnitPrefsDim.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgUnitPrefsDim.")
    
    _get_Id_metadata = { "name" : "Id",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Id(self) -> int:
        """Returns the ID of the dimension."""
        return self._intf.get_property(IAgUnitPrefsDim._metadata, IAgUnitPrefsDim._get_Id_metadata)

    _get_Name_metadata = { "name" : "Name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Name(self) -> str:
        """Returns the current Dimension's full name."""
        return self._intf.get_property(IAgUnitPrefsDim._metadata, IAgUnitPrefsDim._get_Name_metadata)

    _get_AvailableUnits_metadata = { "name" : "AvailableUnits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AvailableUnits(self) -> "IAgUnitPrefsUnitCollection":
        """Returns collection of Units."""
        return self._intf.get_property(IAgUnitPrefsDim._metadata, IAgUnitPrefsDim._get_AvailableUnits_metadata)

    _get_CurrentUnit_metadata = { "name" : "CurrentUnit",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CurrentUnit(self) -> "IAgUnitPrefsUnit":
        """Returns the current unit for this dimension."""
        return self._intf.get_property(IAgUnitPrefsDim._metadata, IAgUnitPrefsDim._get_CurrentUnit_metadata)

    _SetCurrentUnit_metadata = { "name" : "SetCurrentUnit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetCurrentUnit(self, unitAbbrv:str) -> None:
        """Sets the Unit for this simple dimension."""
        return self._intf.invoke(IAgUnitPrefsDim._metadata, IAgUnitPrefsDim._SetCurrentUnit_metadata, unitAbbrv)


agcls.AgClassCatalog.add_catalog_entry("{AA966FFD-1A99-45D8-9193-C519BBBA99FA}", IAgUnitPrefsDim)
agcls.AgTypeNameMap["IAgUnitPrefsDim"] = IAgUnitPrefsDim

class IAgPropertyInfo(object):
    """Property information."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{26A48B4B-BF6A-4F9D-9658-44A7A2DBBE2A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Name" : 1,
                             "get_PropertyType" : 2,
                             "GetValue" : 3,
                             "SetValue" : 4,
                             "get_HasMin" : 5,
                             "get_HasMax" : 6,
                             "get_Min" : 7,
                             "get_Max" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgPropertyInfo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgPropertyInfo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgPropertyInfo.__dict__ and type(IAgPropertyInfo.__dict__[attrname]) == property:
            return IAgPropertyInfo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgPropertyInfo.")
    
    _get_Name_metadata = { "name" : "Name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Name(self) -> str:
        """The name of the property."""
        return self._intf.get_property(IAgPropertyInfo._metadata, IAgPropertyInfo._get_Name_metadata)

    _get_PropertyType_metadata = { "name" : "PropertyType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPropertyInfoValueType),) }
    @property
    def PropertyType(self) -> "AgEPropertyInfoValueType":
        """The type of property."""
        return self._intf.get_property(IAgPropertyInfo._metadata, IAgPropertyInfo._get_PropertyType_metadata)

    _GetValue_metadata = { "name" : "GetValue",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def GetValue(self) -> typing.Any:
        """The value of the property. Use PropertyType to determine the type to cast to."""
        return self._intf.invoke(IAgPropertyInfo._metadata, IAgPropertyInfo._GetValue_metadata, out_arg())

    _SetValue_metadata = { "name" : "SetValue",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def SetValue(self, propertyInfo:typing.Any) -> None:
        """The value of the property. Use PropertyType to determine the type to cast to."""
        return self._intf.invoke(IAgPropertyInfo._metadata, IAgPropertyInfo._SetValue_metadata, propertyInfo)

    _get_HasMin_metadata = { "name" : "HasMin",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def HasMin(self) -> bool:
        """Used to determine if the property has a minimum value."""
        return self._intf.get_property(IAgPropertyInfo._metadata, IAgPropertyInfo._get_HasMin_metadata)

    _get_HasMax_metadata = { "name" : "HasMax",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def HasMax(self) -> bool:
        """Used to determine if the property has a maximum value."""
        return self._intf.get_property(IAgPropertyInfo._metadata, IAgPropertyInfo._get_HasMax_metadata)

    _get_Min_metadata = { "name" : "Min",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Min(self) -> typing.Any:
        """The minimum value of this property. Use PropertyType to determine the type to cast to."""
        return self._intf.get_property(IAgPropertyInfo._metadata, IAgPropertyInfo._get_Min_metadata)

    _get_Max_metadata = { "name" : "Max",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Max(self) -> typing.Any:
        """The maximum value of this property. Use PropertyType to determine the type to cast to."""
        return self._intf.get_property(IAgPropertyInfo._metadata, IAgPropertyInfo._get_Max_metadata)


agcls.AgClassCatalog.add_catalog_entry("{26A48B4B-BF6A-4F9D-9658-44A7A2DBBE2A}", IAgPropertyInfo)
agcls.AgTypeNameMap["IAgPropertyInfo"] = IAgPropertyInfo

class IAgPropertyInfoCollection(object):
    """The collection of properties."""
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{198E6280-1D5A-4AED-9DE3-ACE354B95287}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Item" : 1,
                             "get__NewEnum" : 2,
                             "get_Count" : 3,
                             "GetItemByIndex" : 4,
                             "GetItemByName" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgPropertyInfoCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgPropertyInfoCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgPropertyInfoCollection.__dict__ and type(IAgPropertyInfoCollection.__dict__[attrname]) == property:
            return IAgPropertyInfoCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgPropertyInfoCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgPropertyInfo":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgPropertyInfo":
        """Allows the user to iterate through the properties."""
        return self._intf.invoke(IAgPropertyInfoCollection._metadata, IAgPropertyInfoCollection._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Enumerates through the properties."""
        return self._intf.get_property(IAgPropertyInfoCollection._metadata, IAgPropertyInfoCollection._get__NewEnum_metadata)

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """The number of properties available."""
        return self._intf.get_property(IAgPropertyInfoCollection._metadata, IAgPropertyInfoCollection._get_Count_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgPropertyInfo":
        """Retrieves a property from the collection by index."""
        return self._intf.invoke(IAgPropertyInfoCollection._metadata, IAgPropertyInfoCollection._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgPropertyInfo":
        """Retrieves a property from the collection by name."""
        return self._intf.invoke(IAgPropertyInfoCollection._metadata, IAgPropertyInfoCollection._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{198E6280-1D5A-4AED-9DE3-ACE354B95287}", IAgPropertyInfoCollection)
agcls.AgTypeNameMap["IAgPropertyInfoCollection"] = IAgPropertyInfoCollection

class IAgRuntimeTypeInfo(object):
    """Interface used to retrieve the properties at runtime."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{01F8872C-9586-4131-A724-F97C6ADD083F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Properties" : 1,
                             "get_IsCollection" : 2,
                             "get_Count" : 3,
                             "GetItem" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgRuntimeTypeInfo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgRuntimeTypeInfo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgRuntimeTypeInfo.__dict__ and type(IAgRuntimeTypeInfo.__dict__[attrname]) == property:
            return IAgRuntimeTypeInfo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgRuntimeTypeInfo.")
    
    _get_Properties_metadata = { "name" : "Properties",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Properties(self) -> "IAgPropertyInfoCollection":
        """The collection of properties."""
        return self._intf.get_property(IAgRuntimeTypeInfo._metadata, IAgRuntimeTypeInfo._get_Properties_metadata)

    _get_IsCollection_metadata = { "name" : "IsCollection",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsCollection(self) -> bool:
        """Determines if the interface is a collection."""
        return self._intf.get_property(IAgRuntimeTypeInfo._metadata, IAgRuntimeTypeInfo._get_IsCollection_metadata)

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """If the interface is a collection, returns the collection count."""
        return self._intf.get_property(IAgRuntimeTypeInfo._metadata, IAgRuntimeTypeInfo._get_Count_metadata)

    _GetItem_metadata = { "name" : "GetItem",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def GetItem(self, index:int) -> "IAgPropertyInfo":
        """Returns the property of the collection at the given index."""
        return self._intf.invoke(IAgRuntimeTypeInfo._metadata, IAgRuntimeTypeInfo._GetItem_metadata, index, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{01F8872C-9586-4131-A724-F97C6ADD083F}", IAgRuntimeTypeInfo)
agcls.AgTypeNameMap["IAgRuntimeTypeInfo"] = IAgRuntimeTypeInfo

class IAgRuntimeTypeInfoProvider(object):
    """Access point for IAgRuntimeTypeInfo."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E9AD01B5-7892-4367-8EC7-60EA26CE0E11}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ProvideRuntimeTypeInfo" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgRuntimeTypeInfoProvider._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgRuntimeTypeInfoProvider from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgRuntimeTypeInfoProvider.__dict__ and type(IAgRuntimeTypeInfoProvider.__dict__[attrname]) == property:
            return IAgRuntimeTypeInfoProvider.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgRuntimeTypeInfoProvider.")
    
    _get_ProvideRuntimeTypeInfo_metadata = { "name" : "ProvideRuntimeTypeInfo",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ProvideRuntimeTypeInfo(self) -> "IAgRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        return self._intf.get_property(IAgRuntimeTypeInfoProvider._metadata, IAgRuntimeTypeInfoProvider._get_ProvideRuntimeTypeInfo_metadata)


agcls.AgClassCatalog.add_catalog_entry("{E9AD01B5-7892-4367-8EC7-60EA26CE0E11}", IAgRuntimeTypeInfoProvider)
agcls.AgTypeNameMap["IAgRuntimeTypeInfoProvider"] = IAgRuntimeTypeInfoProvider

class IAgExecCmdResult(object):
    """Collection of strings returned by the ExecuteCommand."""
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{CC5C63BC-FF0A-4CC8-AD58-5A8D11DD9C60}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_Count" : 1,
                             "Item" : 2,
                             "get__NewEnum" : 3,
                             "Range" : 4,
                             "get_IsSucceeded" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgExecCmdResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgExecCmdResult from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgExecCmdResult.__dict__ and type(IAgExecCmdResult.__dict__[attrname]) == property:
            return IAgExecCmdResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgExecCmdResult.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> str:
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Number of elements contained in the collection."""
        return self._intf.get_property(IAgExecCmdResult._metadata, IAgExecCmdResult._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.BSTR_arg,) }
    def Item(self, index:int) -> str:
        """Gets the element at the specified index (0-based)."""
        return self._intf.invoke(IAgExecCmdResult._metadata, IAgExecCmdResult._Item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns an object that can be used to iterate through all the strings in the collection."""
        return self._intf.get_property(IAgExecCmdResult._metadata, IAgExecCmdResult._get__NewEnum_metadata)

    _Range_metadata = { "name" : "Range",
            "arg_types" : (agcom.LONG, agcom.LONG, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.LONG_arg, agmarshall.LPSAFEARRAY_arg,) }
    def Range(self, startIndex:int, stopIndex:int) -> list:
        """Return the elements within the specified range."""
        return self._intf.invoke(IAgExecCmdResult._metadata, IAgExecCmdResult._Range_metadata, startIndex, stopIndex, out_arg())

    _get_IsSucceeded_metadata = { "name" : "IsSucceeded",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsSucceeded(self) -> bool:
        """Indicates whether the object contains valid results."""
        return self._intf.get_property(IAgExecCmdResult._metadata, IAgExecCmdResult._get_IsSucceeded_metadata)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{CC5C63BC-FF0A-4CC8-AD58-5A8D11DD9C60}", IAgExecCmdResult)
agcls.AgTypeNameMap["IAgExecCmdResult"] = IAgExecCmdResult

class IAgExecMultiCmdResult(object):
    """Collection of objects returned by the ExecuteMultipleCommands."""
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{ECEFEE1C-F623-4926-A738-3D95FC5E3DEE}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_Count" : 1,
                             "Item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgExecMultiCmdResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgExecMultiCmdResult from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgExecMultiCmdResult.__dict__ and type(IAgExecMultiCmdResult.__dict__[attrname]) == property:
            return IAgExecMultiCmdResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgExecMultiCmdResult.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgExecCmdResult":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Number of elements contained in the collection."""
        return self._intf.get_property(IAgExecMultiCmdResult._metadata, IAgExecMultiCmdResult._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, index:int) -> "IAgExecCmdResult":
        """Gets the element at the specified index (0-based)."""
        return self._intf.invoke(IAgExecMultiCmdResult._metadata, IAgExecMultiCmdResult._Item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns an object that can be used to iterate through all the objects in the collection."""
        return self._intf.get_property(IAgExecMultiCmdResult._metadata, IAgExecMultiCmdResult._get__NewEnum_metadata)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{ECEFEE1C-F623-4926-A738-3D95FC5E3DEE}", IAgExecMultiCmdResult)
agcls.AgTypeNameMap["IAgExecMultiCmdResult"] = IAgExecMultiCmdResult

class IAgUnitPrefsUnit(object):
    """Provides info about a unit."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4B4E2F51-280F-4E35-AEA5-71CDAC7342C4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_FullName" : 1,
                             "get_Abbrv" : 2,
                             "get_Id" : 3,
                             "get_Dimension" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgUnitPrefsUnit._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgUnitPrefsUnit from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgUnitPrefsUnit.__dict__ and type(IAgUnitPrefsUnit.__dict__[attrname]) == property:
            return IAgUnitPrefsUnit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgUnitPrefsUnit.")
    
    _get_FullName_metadata = { "name" : "FullName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def FullName(self) -> str:
        """Returns the fullname of the unit."""
        return self._intf.get_property(IAgUnitPrefsUnit._metadata, IAgUnitPrefsUnit._get_FullName_metadata)

    _get_Abbrv_metadata = { "name" : "Abbrv",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Abbrv(self) -> str:
        """Returns the abbreviation of the unit."""
        return self._intf.get_property(IAgUnitPrefsUnit._metadata, IAgUnitPrefsUnit._get_Abbrv_metadata)

    _get_Id_metadata = { "name" : "Id",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Id(self) -> int:
        """Returns the ID of the unit."""
        return self._intf.get_property(IAgUnitPrefsUnit._metadata, IAgUnitPrefsUnit._get_Id_metadata)

    _get_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Dimension(self) -> "IAgUnitPrefsDim":
        """Returns the Dimension for this unit."""
        return self._intf.get_property(IAgUnitPrefsUnit._metadata, IAgUnitPrefsUnit._get_Dimension_metadata)


agcls.AgClassCatalog.add_catalog_entry("{4B4E2F51-280F-4E35-AEA5-71CDAC7342C4}", IAgUnitPrefsUnit)
agcls.AgTypeNameMap["IAgUnitPrefsUnit"] = IAgUnitPrefsUnit

class IAgUnitPrefsUnitCollection(object):
    """Provides access to the Unit collection."""
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{C9A263F5-A021-4BEC-85F3-526FA41F1CB4}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Item" : 1,
                             "get_Count" : 2,
                             "get__NewEnum" : 3,
                             "GetItemByIndex" : 4,
                             "GetItemByName" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgUnitPrefsUnitCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgUnitPrefsUnitCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgUnitPrefsUnitCollection.__dict__ and type(IAgUnitPrefsUnitCollection.__dict__[attrname]) == property:
            return IAgUnitPrefsUnitCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgUnitPrefsUnitCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgUnitPrefsUnit":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgUnitPrefsUnit":
        """Returns the specific item in the collection given a unit identifier or an index."""
        return self._intf.invoke(IAgUnitPrefsUnitCollection._metadata, IAgUnitPrefsUnitCollection._Item_metadata, indexOrName, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns the number of items in the collection."""
        return self._intf.get_property(IAgUnitPrefsUnitCollection._metadata, IAgUnitPrefsUnitCollection._get_Count_metadata)

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns an enumeration of AgUnitPrefsUnit."""
        return self._intf.get_property(IAgUnitPrefsUnitCollection._metadata, IAgUnitPrefsUnitCollection._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgUnitPrefsUnit":
        """Retrieves a unit from the collection by index."""
        return self._intf.invoke(IAgUnitPrefsUnitCollection._metadata, IAgUnitPrefsUnitCollection._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgUnitPrefsUnit":
        """Retrieves a unit from the collection by name."""
        return self._intf.invoke(IAgUnitPrefsUnitCollection._metadata, IAgUnitPrefsUnitCollection._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{C9A263F5-A021-4BEC-85F3-526FA41F1CB4}", IAgUnitPrefsUnitCollection)
agcls.AgTypeNameMap["IAgUnitPrefsUnitCollection"] = IAgUnitPrefsUnitCollection

class IAgUnitPrefsDimCollection(object):
    """Provides accesses to the global unit table."""
    _num_methods = 12
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{40AE1C29-E5F5-426A-AEB7-D02CC7D2873C}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Item" : 1,
                             "get_Count" : 2,
                             "SetCurrentUnit" : 3,
                             "GetCurrentUnitAbbrv" : 4,
                             "get_MissionElapsedTime" : 5,
                             "set_MissionElapsedTime" : 6,
                             "get_JulianDateOffset" : 7,
                             "set_JulianDateOffset" : 8,
                             "get__NewEnum" : 9,
                             "ResetUnits" : 10,
                             "GetItemByIndex" : 11,
                             "GetItemByName" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgUnitPrefsDimCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgUnitPrefsDimCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgUnitPrefsDimCollection.__dict__ and type(IAgUnitPrefsDimCollection.__dict__[attrname]) == property:
            return IAgUnitPrefsDimCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgUnitPrefsDimCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgUnitPrefsDim":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgUnitPrefsDim":
        """Returns an IAgUnitPrefsDim given a Dimension name or an index."""
        return self._intf.invoke(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._Item_metadata, indexOrName, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns the number of items in the collection."""
        return self._intf.get_property(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._get_Count_metadata)

    _SetCurrentUnit_metadata = { "name" : "SetCurrentUnit",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def SetCurrentUnit(self, dimension:str, unitAbbrv:str) -> None:
        """Returns the Current unit for a Dimension."""
        return self._intf.invoke(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._SetCurrentUnit_metadata, dimension, unitAbbrv)

    _GetCurrentUnitAbbrv_metadata = { "name" : "GetCurrentUnitAbbrv",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.BSTR_arg,) }
    def GetCurrentUnitAbbrv(self, indexOrDimName:typing.Any) -> str:
        """Returns the Current Unit for a Dimension."""
        return self._intf.invoke(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._GetCurrentUnitAbbrv_metadata, indexOrDimName, out_arg())

    _get_MissionElapsedTime_metadata = { "name" : "MissionElapsedTime",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def MissionElapsedTime(self) -> typing.Any:
        """The MissionElapsedTime."""
        return self._intf.get_property(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._get_MissionElapsedTime_metadata)

    _set_MissionElapsedTime_metadata = { "name" : "MissionElapsedTime",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @MissionElapsedTime.setter
    def MissionElapsedTime(self, pMisElapTime:typing.Any) -> None:
        return self._intf.set_property(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._set_MissionElapsedTime_metadata, pMisElapTime)

    _get_JulianDateOffset_metadata = { "name" : "JulianDateOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def JulianDateOffset(self) -> float:
        """The JulianDateOffset."""
        return self._intf.get_property(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._get_JulianDateOffset_metadata)

    _set_JulianDateOffset_metadata = { "name" : "JulianDateOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @JulianDateOffset.setter
    def JulianDateOffset(self, pJDateOffset:float) -> None:
        return self._intf.set_property(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._set_JulianDateOffset_metadata, pJDateOffset)

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a collection of IAgUnitPrefsDim."""
        return self._intf.get_property(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._get__NewEnum_metadata)

    _ResetUnits_metadata = { "name" : "ResetUnits",
            "arg_types" : (),
            "marshallers" : () }
    def ResetUnits(self) -> None:
        """Resets the unitpreferences to the Default units"""
        return self._intf.invoke(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._ResetUnits_metadata, )

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgUnitPrefsDim":
        """Retrieves a dimension from the collection by index."""
        return self._intf.invoke(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgUnitPrefsDim":
        """Retrieves a dimension from the collection by name."""
        return self._intf.invoke(IAgUnitPrefsDimCollection._metadata, IAgUnitPrefsDimCollection._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{40AE1C29-E5F5-426A-AEB7-D02CC7D2873C}", IAgUnitPrefsDimCollection)
agcls.AgTypeNameMap["IAgUnitPrefsDimCollection"] = IAgUnitPrefsDimCollection

class IAgQuantity(object):
    """Provides helper methods for a quantity."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C0BBB39C-54E2-4344-B24E-58AA6AA4446B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Dimension" : 1,
                             "get_Unit" : 2,
                             "ConvertToUnit" : 3,
                             "get_Value" : 4,
                             "set_Value" : 5,
                             "Add" : 6,
                             "Subtract" : 7,
                             "MultiplyQty" : 8,
                             "DivideQty" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgQuantity._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgQuantity from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgQuantity.__dict__ and type(IAgQuantity.__dict__[attrname]) == property:
            return IAgQuantity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgQuantity.")
    
    _get_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Dimension(self) -> str:
        """Gets the name of the dimension"""
        return self._intf.get_property(IAgQuantity._metadata, IAgQuantity._get_Dimension_metadata)

    _get_Unit_metadata = { "name" : "Unit",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Unit(self) -> str:
        """The current Unit abbreviation."""
        return self._intf.get_property(IAgQuantity._metadata, IAgQuantity._get_Unit_metadata)

    _ConvertToUnit_metadata = { "name" : "ConvertToUnit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def ConvertToUnit(self, unitAbbrv:str) -> None:
        """Changes the value in this quantity to the specified unit."""
        return self._intf.invoke(IAgQuantity._metadata, IAgQuantity._ConvertToUnit_metadata, unitAbbrv)

    _get_Value_metadata = { "name" : "Value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Value(self) -> float:
        """The current value."""
        return self._intf.get_property(IAgQuantity._metadata, IAgQuantity._get_Value_metadata)

    _set_Value_metadata = { "name" : "Value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Value.setter
    def Value(self, value:float) -> None:
        return self._intf.set_property(IAgQuantity._metadata, IAgQuantity._set_Value_metadata, value)

    _Add_metadata = { "name" : "Add",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.AgInterface_out_arg,) }
    def Add(self, quantity:"IAgQuantity") -> "IAgQuantity":
        """Adds the value from the IAgQuantity interface to this interface. Returns a new IAgQuantity. The dimensions must be similar."""
        return self._intf.invoke(IAgQuantity._metadata, IAgQuantity._Add_metadata, quantity, out_arg())

    _Subtract_metadata = { "name" : "Subtract",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.AgInterface_out_arg,) }
    def Subtract(self, quantity:"IAgQuantity") -> "IAgQuantity":
        """Subtracts the value from the IAgQuantity interface to this interface. Returns a new IAgQuantity. The dimensions must be similar."""
        return self._intf.invoke(IAgQuantity._metadata, IAgQuantity._Subtract_metadata, quantity, out_arg())

    _MultiplyQty_metadata = { "name" : "MultiplyQty",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.AgInterface_out_arg,) }
    def MultiplyQty(self, quantity:"IAgQuantity") -> "IAgQuantity":
        """Multiplies the value from the IAgQuantity interface to this interface. Returns a new IAgQuantity. The dimensions must be similar."""
        return self._intf.invoke(IAgQuantity._metadata, IAgQuantity._MultiplyQty_metadata, quantity, out_arg())

    _DivideQty_metadata = { "name" : "DivideQty",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.AgInterface_out_arg,) }
    def DivideQty(self, quantity:"IAgQuantity") -> "IAgQuantity":
        """Divides the value from the IAgQuantity interface to this interface. The dimensions must be similar."""
        return self._intf.invoke(IAgQuantity._metadata, IAgQuantity._DivideQty_metadata, quantity, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C0BBB39C-54E2-4344-B24E-58AA6AA4446B}", IAgQuantity)
agcls.AgTypeNameMap["IAgQuantity"] = IAgQuantity

class IAgDate(object):
    """Provides helper methods for a date."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BFC8EA09-19BD-432A-923D-C553E8E37993}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Format" : 1,
                             "SetDate" : 2,
                             "get_OLEDate" : 3,
                             "set_OLEDate" : 4,
                             "get_WholeDays" : 5,
                             "set_WholeDays" : 6,
                             "get_SecIntoDay" : 7,
                             "set_SecIntoDay" : 8,
                             "get_WholeDaysUTC" : 9,
                             "set_WholeDaysUTC" : 10,
                             "get_SecIntoDayUTC" : 11,
                             "set_SecIntoDayUTC" : 12,
                             "Add" : 13,
                             "Subtract" : 14,
                             "Span" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgDate._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgDate from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgDate.__dict__ and type(IAgDate.__dict__[attrname]) == property:
            return IAgDate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgDate.")
    
    _Format_metadata = { "name" : "Format",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def Format(self, unit:str) -> str:
        """Returns the value of the date given the unit."""
        return self._intf.invoke(IAgDate._metadata, IAgDate._Format_metadata, unit, out_arg())

    _SetDate_metadata = { "name" : "SetDate",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def SetDate(self, unit:str, value:str) -> None:
        """Sets this date with the given date value and unit type."""
        return self._intf.invoke(IAgDate._metadata, IAgDate._SetDate_metadata, unit, value)

    _get_OLEDate_metadata = { "name" : "OLEDate",
            "arg_types" : (POINTER(agcom.DATE),),
            "marshallers" : (agmarshall.DATE_arg,) }
    @property
    def OLEDate(self) -> datetime:
        """The current time in OLE DATE Format."""
        return self._intf.get_property(IAgDate._metadata, IAgDate._get_OLEDate_metadata)

    _set_OLEDate_metadata = { "name" : "OLEDate",
            "arg_types" : (agcom.DATE,),
            "marshallers" : (agmarshall.DATE_arg,) }
    @OLEDate.setter
    def OLEDate(self, inVal:datetime) -> None:
        return self._intf.set_property(IAgDate._metadata, IAgDate._set_OLEDate_metadata, inVal)

    _get_WholeDays_metadata = { "name" : "WholeDays",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def WholeDays(self) -> int:
        """The Julian Day Number of the date of interest."""
        return self._intf.get_property(IAgDate._metadata, IAgDate._get_WholeDays_metadata)

    _set_WholeDays_metadata = { "name" : "WholeDays",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @WholeDays.setter
    def WholeDays(self, wholeDays:int) -> None:
        return self._intf.set_property(IAgDate._metadata, IAgDate._set_WholeDays_metadata, wholeDays)

    _get_SecIntoDay_metadata = { "name" : "SecIntoDay",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def SecIntoDay(self) -> float:
        """Contains values between 0.0 and 86400 with the exception of when the date is inside a leap second in which case the SecIntoDay can become as large as 86401.0"""
        return self._intf.get_property(IAgDate._metadata, IAgDate._get_SecIntoDay_metadata)

    _set_SecIntoDay_metadata = { "name" : "SecIntoDay",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @SecIntoDay.setter
    def SecIntoDay(self, secIntoDay:float) -> None:
        return self._intf.set_property(IAgDate._metadata, IAgDate._set_SecIntoDay_metadata, secIntoDay)

    _get_WholeDaysUTC_metadata = { "name" : "WholeDaysUTC",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def WholeDaysUTC(self) -> int:
        """The UTC Day Number of the date of interest."""
        return self._intf.get_property(IAgDate._metadata, IAgDate._get_WholeDaysUTC_metadata)

    _set_WholeDaysUTC_metadata = { "name" : "WholeDaysUTC",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    @WholeDaysUTC.setter
    def WholeDaysUTC(self, wholeDays:int) -> None:
        return self._intf.set_property(IAgDate._metadata, IAgDate._set_WholeDaysUTC_metadata, wholeDays)

    _get_SecIntoDayUTC_metadata = { "name" : "SecIntoDayUTC",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def SecIntoDayUTC(self) -> float:
        """Contains values between 0.0 and 86400 with the exception of when the date is inside a leap second in which case the SecIntoDay can become as large as 86401.0"""
        return self._intf.get_property(IAgDate._metadata, IAgDate._get_SecIntoDayUTC_metadata)

    _set_SecIntoDayUTC_metadata = { "name" : "SecIntoDayUTC",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @SecIntoDayUTC.setter
    def SecIntoDayUTC(self, secIntoDay:float) -> None:
        return self._intf.set_property(IAgDate._metadata, IAgDate._set_SecIntoDayUTC_metadata, secIntoDay)

    _Add_metadata = { "name" : "Add",
            "arg_types" : (agcom.BSTR, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def Add(self, unit:str, value:float) -> "IAgDate":
        """Adds the value in the given unit and returns a new date interface."""
        return self._intf.invoke(IAgDate._metadata, IAgDate._Add_metadata, unit, value, out_arg())

    _Subtract_metadata = { "name" : "Subtract",
            "arg_types" : (agcom.BSTR, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def Subtract(self, unit:str, value:float) -> "IAgDate":
        """Subtracts the value in the given unit and returns a new date interface."""
        return self._intf.invoke(IAgDate._metadata, IAgDate._Subtract_metadata, unit, value, out_arg())

    _Span_metadata = { "name" : "Span",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgDate"), agmarshall.AgInterface_out_arg,) }
    def Span(self, date:"IAgDate") -> "IAgQuantity":
        """Subtracts the value from the IAgDate interface and returns an IAgQuantity."""
        return self._intf.invoke(IAgDate._metadata, IAgDate._Span_metadata, date, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{BFC8EA09-19BD-432A-923D-C553E8E37993}", IAgDate)
agcls.AgTypeNameMap["IAgDate"] = IAgDate

class IAgConversionUtility(object):
    """Provides conversion utilities."""
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2B04A4E2-C647-4920-88FF-DE0413252D1C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "ConvertQuantity" : 1,
                             "ConvertDate" : 2,
                             "ConvertQuantityArray" : 3,
                             "ConvertDateArray" : 4,
                             "NewQuantity" : 5,
                             "NewDate" : 6,
                             "NewPositionOnEarth" : 7,
                             "ConvertPositionArray" : 8,
                             "NewDirection" : 9,
                             "NewOrientation" : 10,
                             "NewOrbitStateOnEarth" : 11,
                             "NewPositionOnCB" : 12,
                             "NewOrbitStateOnCB" : 13,
                             "QueryDirectionCosineMatrix" : 14,
                             "QueryDirectionCosineMatrixArray" : 15,
                             "NewCartesian3Vector" : 16,
                             "NewCartesian3VectorFromDirection" : 17,
                             "NewCartesian3VectorFromPosition" : 18, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgConversionUtility._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgConversionUtility from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgConversionUtility.__dict__ and type(IAgConversionUtility.__dict__[attrname]) == property:
            return IAgConversionUtility.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgConversionUtility.")
    
    _ConvertQuantity_metadata = { "name" : "ConvertQuantity",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.DOUBLE, POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def ConvertQuantity(self, dimensionName:str, fromUnit:str, toUnit:str, fromValue:float) -> float:
        """Converts the specified quantity value from a given unit to another unit."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._ConvertQuantity_metadata, dimensionName, fromUnit, toUnit, fromValue, out_arg())

    _ConvertDate_metadata = { "name" : "ConvertDate",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def ConvertDate(self, fromUnit:str, toUnit:str, fromValue:str) -> str:
        """Converts the specified date from a given unit to another unit."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._ConvertDate_metadata, fromUnit, toUnit, fromValue, out_arg())

    _ConvertQuantityArray_metadata = { "name" : "ConvertQuantityArray",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def ConvertQuantityArray(self, dimensionName:str, fromUnit:str, toUnit:str, quantityValues:list) -> list:
        """Converts the specified quantity values from a given unit to another unit."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._ConvertQuantityArray_metadata, dimensionName, fromUnit, toUnit, quantityValues, out_arg())

    _ConvertDateArray_metadata = { "name" : "ConvertDateArray",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def ConvertDateArray(self, fromUnit:str, toUnit:str, fromValues:list) -> list:
        """Converts the specified dates from a given unit to another unit."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._ConvertDateArray_metadata, fromUnit, toUnit, fromValues, out_arg())

    _NewQuantity_metadata = { "name" : "NewQuantity",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def NewQuantity(self, dimension:str, unitAbbrv:str, value:float) -> "IAgQuantity":
        """Creates an IAgQuantity interface with the given dimension, unit and value"""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewQuantity_metadata, dimension, unitAbbrv, value, out_arg())

    _NewDate_metadata = { "name" : "NewDate",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def NewDate(self, unitAbbrv:str, value:str) -> "IAgDate":
        """Creates an IAgDate interface with the given unit and value"""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewDate_metadata, unitAbbrv, value, out_arg())

    _NewPositionOnEarth_metadata = { "name" : "NewPositionOnEarth",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def NewPositionOnEarth(self) -> "IAgPosition":
        """Creates an IAgPosition interface with earth as its central body."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewPositionOnEarth_metadata, out_arg())

    _ConvertPositionArray_metadata = { "name" : "ConvertPositionArray",
            "arg_types" : (agcom.LONG, POINTER(agcom.LPSAFEARRAY), agcom.LONG, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgEnum_arg(AgEPositionType), agmarshall.LPSAFEARRAY_arg, agmarshall.AgEnum_arg(AgEPositionType), agmarshall.LPSAFEARRAY_arg,) }
    def ConvertPositionArray(self, positionType:"AgEPositionType", positionArray:list, convertTo:"AgEPositionType") -> list:
        """Converts the specified position values from a given position type to another position type."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._ConvertPositionArray_metadata, positionType, positionArray, convertTo, out_arg())

    _NewDirection_metadata = { "name" : "NewDirection",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def NewDirection(self) -> "IAgDirection":
        """Creates an IAgDirection interface."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewDirection_metadata, out_arg())

    _NewOrientation_metadata = { "name" : "NewOrientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def NewOrientation(self) -> "IAgOrientation":
        """Creates an IAgOrientation interface."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewOrientation_metadata, out_arg())

    _NewOrbitStateOnEarth_metadata = { "name" : "NewOrbitStateOnEarth",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def NewOrbitStateOnEarth(self) -> "IAgOrbitState":
        """Creates an IAgOrbitState interface with earth as its central body."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewOrbitStateOnEarth_metadata, out_arg())

    _NewPositionOnCB_metadata = { "name" : "NewPositionOnCB",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def NewPositionOnCB(self, centralBodyName:str) -> "IAgPosition":
        """Creates an IAgPosition interface using the supplied central body."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewPositionOnCB_metadata, centralBodyName, out_arg())

    _NewOrbitStateOnCB_metadata = { "name" : "NewOrbitStateOnCB",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def NewOrbitStateOnCB(self, centralBodyName:str) -> "IAgOrbitState":
        """Creates an IAgOrbitState interface using the supplied central body."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewOrbitStateOnCB_metadata, centralBodyName, out_arg())

    _QueryDirectionCosineMatrix_metadata = { "name" : "QueryDirectionCosineMatrix",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID), POINTER(agcom.PVOID), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgOrientation"), agmarshall.AgInterface_out_arg, agmarshall.AgInterface_out_arg, agmarshall.AgInterface_out_arg,) }
    def QueryDirectionCosineMatrix(self, inputOrientation:"IAgOrientation") -> typing.Tuple[IAgCartesian3Vector, IAgCartesian3Vector, IAgCartesian3Vector]:
        """Returns a Direction Cosine Matrix (DCM)."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._QueryDirectionCosineMatrix_metadata, inputOrientation, out_arg(), out_arg(), out_arg())

    _QueryDirectionCosineMatrixArray_metadata = { "name" : "QueryDirectionCosineMatrixArray",
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgOrientation"), agmarshall.LPSAFEARRAY_arg,) }
    def QueryDirectionCosineMatrixArray(self, inputOrientation:"IAgOrientation") -> list:
        """Returns a Direction Cosine Matrix (DCM) as an array."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._QueryDirectionCosineMatrixArray_metadata, inputOrientation, out_arg())

    _NewCartesian3Vector_metadata = { "name" : "NewCartesian3Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def NewCartesian3Vector(self) -> "IAgCartesian3Vector":
        """Creates a cartesian vector."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewCartesian3Vector_metadata, out_arg())

    _NewCartesian3VectorFromDirection_metadata = { "name" : "NewCartesian3VectorFromDirection",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgDirection"), agmarshall.AgInterface_out_arg,) }
    def NewCartesian3VectorFromDirection(self, inputDirection:"IAgDirection") -> "IAgCartesian3Vector":
        """Converts the direction to cartesian vector."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewCartesian3VectorFromDirection_metadata, inputDirection, out_arg())

    _NewCartesian3VectorFromPosition_metadata = { "name" : "NewCartesian3VectorFromPosition",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgPosition"), agmarshall.AgInterface_out_arg,) }
    def NewCartesian3VectorFromPosition(self, inputPosition:"IAgPosition") -> "IAgCartesian3Vector":
        """Converts the position to cartesian vector."""
        return self._intf.invoke(IAgConversionUtility._metadata, IAgConversionUtility._NewCartesian3VectorFromPosition_metadata, inputPosition, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{2B04A4E2-C647-4920-88FF-DE0413252D1C}", IAgConversionUtility)
agcls.AgTypeNameMap["IAgConversionUtility"] = IAgConversionUtility

class IAgDoublesCollection(object):
    """Represents a collection of doubles."""
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{DEE2EB74-C19C-44C9-8825-09010A8F60BE}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Item" : 1,
                             "get_Count" : 2,
                             "get__NewEnum" : 3,
                             "Add" : 4,
                             "RemoveAt" : 5,
                             "RemoveAll" : 6,
                             "ToArray" : 7,
                             "SetAt" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgDoublesCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgDoublesCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgDoublesCollection.__dict__ and type(IAgDoublesCollection.__dict__[attrname]) == property:
            return IAgDoublesCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgDoublesCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> float:
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.DOUBLE_arg,) }
    def Item(self, index:int) -> float:
        """Returns a double at a specified position."""
        return self._intf.invoke(IAgDoublesCollection._metadata, IAgDoublesCollection._Item_metadata, index, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns the number of items in the collection."""
        return self._intf.get_property(IAgDoublesCollection._metadata, IAgDoublesCollection._get_Count_metadata)

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a collection enumerator."""
        return self._intf.get_property(IAgDoublesCollection._metadata, IAgDoublesCollection._get__NewEnum_metadata)

    _Add_metadata = { "name" : "Add",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def Add(self, value:float) -> None:
        """Add a value to the collection of doubles."""
        return self._intf.invoke(IAgDoublesCollection._metadata, IAgDoublesCollection._Add_metadata, value)

    _RemoveAt_metadata = { "name" : "RemoveAt",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.LONG_arg,) }
    def RemoveAt(self, index:int) -> None:
        """Remove an element from the collection at a specified position."""
        return self._intf.invoke(IAgDoublesCollection._metadata, IAgDoublesCollection._RemoveAt_metadata, index)

    _RemoveAll_metadata = { "name" : "RemoveAll",
            "arg_types" : (),
            "marshallers" : () }
    def RemoveAll(self) -> None:
        """Clears the collection."""
        return self._intf.invoke(IAgDoublesCollection._metadata, IAgDoublesCollection._RemoveAll_metadata, )

    _ToArray_metadata = { "name" : "ToArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def ToArray(self) -> list:
        """Returns an array of the elements in the collection"""
        return self._intf.invoke(IAgDoublesCollection._metadata, IAgDoublesCollection._ToArray_metadata, out_arg())

    _SetAt_metadata = { "name" : "SetAt",
            "arg_types" : (agcom.LONG, agcom.DOUBLE,),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.DOUBLE_arg,) }
    def SetAt(self, index:int, value:float) -> None:
        """Updates an element in the collection at a specified position."""
        return self._intf.invoke(IAgDoublesCollection._metadata, IAgDoublesCollection._SetAt_metadata, index, value)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DEE2EB74-C19C-44C9-8825-09010A8F60BE}", IAgDoublesCollection)
agcls.AgTypeNameMap["IAgDoublesCollection"] = IAgDoublesCollection



class AgExecCmdResult(IAgExecCmdResult):
    """Collection of strings returned by the ExecuteCommand."""
    def __init__(self, sourceObject=None):
        IAgExecCmdResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgExecCmdResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgExecCmdResult._get_property(self, attrname) is not None: found_prop = IAgExecCmdResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgExecCmdResult.")

agcls.AgClassCatalog.add_catalog_entry("{92FE4418-FBA3-4D69-8F6E-9F600A1BA5E0}", AgExecCmdResult)


class AgExecMultiCmdResult(IAgExecMultiCmdResult):
    """Collection of objects returned by the ExecuteMultipleCommands."""
    def __init__(self, sourceObject=None):
        IAgExecMultiCmdResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgExecMultiCmdResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgExecMultiCmdResult._get_property(self, attrname) is not None: found_prop = IAgExecMultiCmdResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgExecMultiCmdResult.")

agcls.AgClassCatalog.add_catalog_entry("{4B262721-FD3F-4DAD-BF32-4280752B7FE6}", AgExecMultiCmdResult)


class AgUnitPrefsUnit(IAgUnitPrefsUnit):
    """Object that contains info on the unit."""
    def __init__(self, sourceObject=None):
        IAgUnitPrefsUnit.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgUnitPrefsUnit._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgUnitPrefsUnit._get_property(self, attrname) is not None: found_prop = IAgUnitPrefsUnit._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgUnitPrefsUnit.")

agcls.AgClassCatalog.add_catalog_entry("{4EDA384D-4C61-4756-92FF-1CD7C8049B96}", AgUnitPrefsUnit)


class AgUnitPrefsUnitCollection(IAgUnitPrefsUnitCollection):
    """Object that contains a collection of IAgUnitPrefsUnit."""
    def __init__(self, sourceObject=None):
        IAgUnitPrefsUnitCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgUnitPrefsUnitCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgUnitPrefsUnitCollection._get_property(self, attrname) is not None: found_prop = IAgUnitPrefsUnitCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgUnitPrefsUnitCollection.")

agcls.AgClassCatalog.add_catalog_entry("{21AEACA4-B79D-455B-8DA4-89402A57A87B}", AgUnitPrefsUnitCollection)


class AgUnitPrefsDim(IAgUnitPrefsDim):
    """Object that contains info on the Dimension."""
    def __init__(self, sourceObject=None):
        IAgUnitPrefsDim.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgUnitPrefsDim._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgUnitPrefsDim._get_property(self, attrname) is not None: found_prop = IAgUnitPrefsDim._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgUnitPrefsDim.")

agcls.AgClassCatalog.add_catalog_entry("{5DB8F1AE-1240-4929-B7FD-75E0800970EB}", AgUnitPrefsDim)


class AgUnitPrefsDimCollection(IAgUnitPrefsDimCollection):
    """Object that contains a collection of dimensions."""
    def __init__(self, sourceObject=None):
        IAgUnitPrefsDimCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgUnitPrefsDimCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgUnitPrefsDimCollection._get_property(self, attrname) is not None: found_prop = IAgUnitPrefsDimCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgUnitPrefsDimCollection.")

agcls.AgClassCatalog.add_catalog_entry("{58562305-1D39-4B56-9FA8-AB49FEB68A37}", AgUnitPrefsDimCollection)


class AgConversionUtility(IAgConversionUtility):
    """Object that contains a unit conversion utility."""
    def __init__(self, sourceObject=None):
        IAgConversionUtility.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgConversionUtility._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgConversionUtility._get_property(self, attrname) is not None: found_prop = IAgConversionUtility._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgConversionUtility.")

agcls.AgClassCatalog.add_catalog_entry("{89E0FDC5-4016-47E9-96ED-0C1B05FFDADA}", AgConversionUtility)


class AgQuantity(IAgQuantity):
    """Object that contains a quantity."""
    def __init__(self, sourceObject=None):
        IAgQuantity.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgQuantity._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgQuantity._get_property(self, attrname) is not None: found_prop = IAgQuantity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgQuantity.")

agcls.AgClassCatalog.add_catalog_entry("{59806B16-8D20-4EC3-8913-9457846AC0E5}", AgQuantity)


class AgDate(IAgDate):
    """Object that contains a date."""
    def __init__(self, sourceObject=None):
        IAgDate.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDate._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgDate._get_property(self, attrname) is not None: found_prop = IAgDate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgDate.")

agcls.AgClassCatalog.add_catalog_entry("{CC2BA6FD-3A05-46D1-BAA0-68AC2D7896F1}", AgDate)


class AgPosition(IAgLocationData, IAgPosition):
    """The Position class."""
    def __init__(self, sourceObject=None):
        IAgLocationData.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgLocationData._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgLocationData._get_property(self, attrname) is not None: found_prop = IAgLocationData._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgPosition.")

agcls.AgClassCatalog.add_catalog_entry("{B3FE87C4-702C-4263-83D8-4E32C993E2D0}", AgPosition)


class AgCartesian(IAgCartesian, IAgPosition):
    """Class used to access a position using Cartesian Coordinates."""
    def __init__(self, sourceObject=None):
        IAgCartesian.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCartesian._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCartesian._get_property(self, attrname) is not None: found_prop = IAgCartesian._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCartesian.")

agcls.AgClassCatalog.add_catalog_entry("{027F342E-5989-43D1-831B-BF2E313A1CBB}", AgCartesian)


class AgGeodetic(IAgGeodetic, IAgPosition):
    """Class defining Geodetic position."""
    def __init__(self, sourceObject=None):
        IAgGeodetic.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgGeodetic._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgGeodetic._get_property(self, attrname) is not None: found_prop = IAgGeodetic._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgGeodetic.")

agcls.AgClassCatalog.add_catalog_entry("{F65DA479-6847-456B-8816-85FF3ECD4469}", AgGeodetic)


class AgGeocentric(IAgGeocentric, IAgPosition):
    """Class defining Geocentric position."""
    def __init__(self, sourceObject=None):
        IAgGeocentric.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgGeocentric._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgGeocentric._get_property(self, attrname) is not None: found_prop = IAgGeocentric._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgGeocentric.")

agcls.AgClassCatalog.add_catalog_entry("{1AC9E304-8DCE-4CD6-A5AA-B82738823556}", AgGeocentric)


class AgPlanetodetic(IAgPlanetodetic, IAgPosition):
    """Class defining Planetodetic position."""
    def __init__(self, sourceObject=None):
        IAgPlanetodetic.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPlanetodetic._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgPlanetodetic._get_property(self, attrname) is not None: found_prop = IAgPlanetodetic._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgPlanetodetic.")

agcls.AgClassCatalog.add_catalog_entry("{E06625DF-EEB4-4384-B142-C1C501F522F8}", AgPlanetodetic)


class AgPlanetocentric(IAgPlanetocentric, IAgPosition):
    """Class defining Planetocentric position."""
    def __init__(self, sourceObject=None):
        IAgPlanetocentric.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPlanetocentric._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgPlanetocentric._get_property(self, attrname) is not None: found_prop = IAgPlanetocentric._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgPlanetocentric.")

agcls.AgClassCatalog.add_catalog_entry("{DB009F3C-1FA7-4241-8A8D-D55E234CFF02}", AgPlanetocentric)


class AgSpherical(IAgSpherical, IAgPosition):
    """Class defining spherical position."""
    def __init__(self, sourceObject=None):
        IAgSpherical.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgSpherical._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgSpherical._get_property(self, attrname) is not None: found_prop = IAgSpherical._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgSpherical.")

agcls.AgClassCatalog.add_catalog_entry("{CD809FAC-48DF-46AB-A322-92947F84C7E6}", AgSpherical)


class AgCylindrical(IAgCylindrical, IAgPosition):
    """Class defining cylindrical position."""
    def __init__(self, sourceObject=None):
        IAgCylindrical.__init__(self, sourceObject)
        IAgPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCylindrical._private_init(self, intf)
        IAgPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCylindrical._get_property(self, attrname) is not None: found_prop = IAgCylindrical._get_property(self, attrname)
        if IAgPosition._get_property(self, attrname) is not None: found_prop = IAgPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCylindrical.")

agcls.AgClassCatalog.add_catalog_entry("{FF1B8082-F06B-4F7B-94B2-6D3C4D9A7D51}", AgCylindrical)


class AgDirection(IAgDirection):
    """Class defining direction options for aligned and constrained vectors."""
    def __init__(self, sourceObject=None):
        IAgDirection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgDirection._get_property(self, attrname) is not None: found_prop = IAgDirection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgDirection.")

agcls.AgClassCatalog.add_catalog_entry("{9BC95D30-4E21-4502-ADE6-2AAE9ED89903}", AgDirection)


class AgDirectionEuler(IAgDirectionEuler, IAgDirection):
    """Euler direction sequence."""
    def __init__(self, sourceObject=None):
        IAgDirectionEuler.__init__(self, sourceObject)
        IAgDirection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirectionEuler._private_init(self, intf)
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgDirectionEuler._get_property(self, attrname) is not None: found_prop = IAgDirectionEuler._get_property(self, attrname)
        if IAgDirection._get_property(self, attrname) is not None: found_prop = IAgDirection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgDirectionEuler.")

agcls.AgClassCatalog.add_catalog_entry("{A14FAC2D-C055-4FB4-9AAD-67314E647717}", AgDirectionEuler)


class AgDirectionPR(IAgDirectionPR, IAgDirection):
    """Pitch-Roll (PR) direction sequence."""
    def __init__(self, sourceObject=None):
        IAgDirectionPR.__init__(self, sourceObject)
        IAgDirection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirectionPR._private_init(self, intf)
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgDirectionPR._get_property(self, attrname) is not None: found_prop = IAgDirectionPR._get_property(self, attrname)
        if IAgDirection._get_property(self, attrname) is not None: found_prop = IAgDirection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgDirectionPR.")

agcls.AgClassCatalog.add_catalog_entry("{3EEEDD8D-FB4C-442D-8A1F-28C7A3C2C9A6}", AgDirectionPR)


class AgDirectionRADec(IAgDirectionRADec, IAgDirection):
    """Spherical direction (Right Ascension and Declination)."""
    def __init__(self, sourceObject=None):
        IAgDirectionRADec.__init__(self, sourceObject)
        IAgDirection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirectionRADec._private_init(self, intf)
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgDirectionRADec._get_property(self, attrname) is not None: found_prop = IAgDirectionRADec._get_property(self, attrname)
        if IAgDirection._get_property(self, attrname) is not None: found_prop = IAgDirection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgDirectionRADec.")

agcls.AgClassCatalog.add_catalog_entry("{EB70218F-18C4-41FE-90AC-99AFEB243666}", AgDirectionRADec)


class AgDirectionXYZ(IAgDirectionXYZ, IAgDirection):
    """Cartesian direction."""
    def __init__(self, sourceObject=None):
        IAgDirectionXYZ.__init__(self, sourceObject)
        IAgDirection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDirectionXYZ._private_init(self, intf)
        IAgDirection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgDirectionXYZ._get_property(self, attrname) is not None: found_prop = IAgDirectionXYZ._get_property(self, attrname)
        if IAgDirection._get_property(self, attrname) is not None: found_prop = IAgDirection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgDirectionXYZ.")

agcls.AgClassCatalog.add_catalog_entry("{E1AB8359-28B7-468F-BD92-378267CA0998}", AgDirectionXYZ)


class AgOrientation(IAgOrientation):
    """Class defining the orientation of an orbit."""
    def __init__(self, sourceObject=None):
        IAgOrientation.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgOrientation.")

agcls.AgClassCatalog.add_catalog_entry("{97DF3B0E-D8E0-46B1-88CB-DC7A0AF934AE}", AgOrientation)


class AgOrientationAzEl(IAgOrientationAzEl, IAgOrientation):
    """AzEl orientation method."""
    def __init__(self, sourceObject=None):
        IAgOrientationAzEl.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationAzEl._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationAzEl._get_property(self, attrname) is not None: found_prop = IAgOrientationAzEl._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgOrientationAzEl.")

agcls.AgClassCatalog.add_catalog_entry("{3CF365C4-9B79-4B72-A479-16EF921F791C}", AgOrientationAzEl)


class AgOrientationEulerAngles(IAgOrientationEulerAngles, IAgOrientation):
    """Euler Angles orientation method."""
    def __init__(self, sourceObject=None):
        IAgOrientationEulerAngles.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationEulerAngles._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationEulerAngles._get_property(self, attrname) is not None: found_prop = IAgOrientationEulerAngles._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgOrientationEulerAngles.")

agcls.AgClassCatalog.add_catalog_entry("{C3DC0E0A-690B-4C20-9134-D6C57BE46D40}", AgOrientationEulerAngles)


class AgOrientationQuaternion(IAgOrientationQuaternion, IAgOrientation):
    """Quaternion orientation method."""
    def __init__(self, sourceObject=None):
        IAgOrientationQuaternion.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationQuaternion._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationQuaternion._get_property(self, attrname) is not None: found_prop = IAgOrientationQuaternion._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgOrientationQuaternion.")

agcls.AgClassCatalog.add_catalog_entry("{8AC57BB2-C7A7-4C05-9E35-7246956759D9}", AgOrientationQuaternion)


class AgOrientationYPRAngles(IAgOrientationYPRAngles, IAgOrientation):
    """Yaw-Pitch Roll (YPR) Angles orientation system."""
    def __init__(self, sourceObject=None):
        IAgOrientationYPRAngles.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationYPRAngles._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationYPRAngles._get_property(self, attrname) is not None: found_prop = IAgOrientationYPRAngles._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgOrientationYPRAngles.")

agcls.AgClassCatalog.add_catalog_entry("{AE398C98-2D0D-4863-8097-9F7648CABC21}", AgOrientationYPRAngles)


class AgDoublesCollection(IAgDoublesCollection):
    """A collection of doubles."""
    def __init__(self, sourceObject=None):
        IAgDoublesCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgDoublesCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgDoublesCollection._get_property(self, attrname) is not None: found_prop = IAgDoublesCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgDoublesCollection.")

agcls.AgClassCatalog.add_catalog_entry("{ECD576C3-0440-44D9-9D16-B88873C3A816}", AgDoublesCollection)


class AgCartesian3Vector(IAgCartesian3Vector):
    """A 3-D cartesian vector."""
    def __init__(self, sourceObject=None):
        IAgCartesian3Vector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCartesian3Vector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCartesian3Vector._get_property(self, attrname) is not None: found_prop = IAgCartesian3Vector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCartesian3Vector.")

agcls.AgClassCatalog.add_catalog_entry("{4A70BA75-BC1A-459D-9DAD-E174F3B94002}", AgCartesian3Vector)


class AgCartesian2Vector(IAgCartesian2Vector):
    """A 2-D cartesian vector."""
    def __init__(self, sourceObject=None):
        IAgCartesian2Vector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCartesian2Vector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCartesian2Vector._get_property(self, attrname) is not None: found_prop = IAgCartesian2Vector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCartesian2Vector.")

agcls.AgClassCatalog.add_catalog_entry("{ECE2E7DF-CBF1-4124-AAAC-33700F16FAE2}", AgCartesian2Vector)


class AgPropertyInfo(IAgPropertyInfo):
    """Property Information coclass."""
    def __init__(self, sourceObject=None):
        IAgPropertyInfo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPropertyInfo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgPropertyInfo._get_property(self, attrname) is not None: found_prop = IAgPropertyInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgPropertyInfo.")

agcls.AgClassCatalog.add_catalog_entry("{92498440-7C87-495C-A8BD-0A70F85D4DC8}", AgPropertyInfo)


class AgPropertyInfoCollection(IAgPropertyInfoCollection):
    """Property Information Collection coclass."""
    def __init__(self, sourceObject=None):
        IAgPropertyInfoCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgPropertyInfoCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgPropertyInfoCollection._get_property(self, attrname) is not None: found_prop = IAgPropertyInfoCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgPropertyInfoCollection.")

agcls.AgClassCatalog.add_catalog_entry("{113B1CA1-4DD4-4915-8D7F-E1F96E18A985}", AgPropertyInfoCollection)


class AgRuntimeTypeInfo(IAgRuntimeTypeInfo):
    """Runtime Type info coclass."""
    def __init__(self, sourceObject=None):
        IAgRuntimeTypeInfo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgRuntimeTypeInfo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgRuntimeTypeInfo._get_property(self, attrname) is not None: found_prop = IAgRuntimeTypeInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgRuntimeTypeInfo.")

agcls.AgClassCatalog.add_catalog_entry("{D80F3E93-932A-49B3-8661-1A1627DCBDD1}", AgRuntimeTypeInfo)


class AgCROrientationAzEl(IAgOrientationAzEl, IAgOrientation, IAgOrientationPositionOffset):
    """AzEl orientation method."""
    def __init__(self, sourceObject=None):
        IAgOrientationAzEl.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
        IAgOrientationPositionOffset.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationAzEl._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
        IAgOrientationPositionOffset._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationAzEl._get_property(self, attrname) is not None: found_prop = IAgOrientationAzEl._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if IAgOrientationPositionOffset._get_property(self, attrname) is not None: found_prop = IAgOrientationPositionOffset._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCROrientationAzEl.")

agcls.AgClassCatalog.add_catalog_entry("{1E11E3CE-BCAA-4E1F-BAF9-B6AD3650F9BA}", AgCROrientationAzEl)


class AgCROrientationEulerAngles(IAgOrientationEulerAngles, IAgOrientation, IAgOrientationPositionOffset):
    """Euler Angles orientation method."""
    def __init__(self, sourceObject=None):
        IAgOrientationEulerAngles.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
        IAgOrientationPositionOffset.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationEulerAngles._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
        IAgOrientationPositionOffset._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationEulerAngles._get_property(self, attrname) is not None: found_prop = IAgOrientationEulerAngles._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if IAgOrientationPositionOffset._get_property(self, attrname) is not None: found_prop = IAgOrientationPositionOffset._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCROrientationEulerAngles.")

agcls.AgClassCatalog.add_catalog_entry("{D08A5BF9-5CBA-432D-8C48-3CD1CFC42636}", AgCROrientationEulerAngles)


class AgCROrientationQuaternion(IAgOrientationQuaternion, IAgOrientation, IAgOrientationPositionOffset):
    """Quaternion orientation method."""
    def __init__(self, sourceObject=None):
        IAgOrientationQuaternion.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
        IAgOrientationPositionOffset.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationQuaternion._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
        IAgOrientationPositionOffset._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationQuaternion._get_property(self, attrname) is not None: found_prop = IAgOrientationQuaternion._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if IAgOrientationPositionOffset._get_property(self, attrname) is not None: found_prop = IAgOrientationPositionOffset._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCROrientationQuaternion.")

agcls.AgClassCatalog.add_catalog_entry("{9D3BA3F8-B6F6-443B-A8AC-74C86A8B901A}", AgCROrientationQuaternion)


class AgCROrientationYPRAngles(IAgOrientationYPRAngles, IAgOrientation, IAgOrientationPositionOffset):
    """Yaw-Pitch Roll (YPR) Angles orientation system."""
    def __init__(self, sourceObject=None):
        IAgOrientationYPRAngles.__init__(self, sourceObject)
        IAgOrientation.__init__(self, sourceObject)
        IAgOrientationPositionOffset.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgOrientationYPRAngles._private_init(self, intf)
        IAgOrientation._private_init(self, intf)
        IAgOrientationPositionOffset._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgOrientationYPRAngles._get_property(self, attrname) is not None: found_prop = IAgOrientationYPRAngles._get_property(self, attrname)
        if IAgOrientation._get_property(self, attrname) is not None: found_prop = IAgOrientation._get_property(self, attrname)
        if IAgOrientationPositionOffset._get_property(self, attrname) is not None: found_prop = IAgOrientationPositionOffset._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCROrientationYPRAngles.")

agcls.AgClassCatalog.add_catalog_entry("{1FB88B69-1844-4CD9-BD44-09A9FCC4E06F}", AgCROrientationYPRAngles)


class AgCROrientationOffsetCart(IAgCartesian3Vector):
    """Orientation offset cartesian."""
    def __init__(self, sourceObject=None):
        IAgCartesian3Vector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCartesian3Vector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCartesian3Vector._get_property(self, attrname) is not None: found_prop = IAgCartesian3Vector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCROrientationOffsetCart.")

agcls.AgClassCatalog.add_catalog_entry("{462F58AA-A74F-4E42-88B6-8F2790E85FEC}", AgCROrientationOffsetCart)



################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################
