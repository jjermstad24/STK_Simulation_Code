################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################ 

__all__ = ["AgCrdnAngle", "AgCrdnAngleBetweenPlanes", "AgCrdnAngleBetweenVectors", "AgCrdnAngleDihedral", "AgCrdnAngleFactory", 
"AgCrdnAngleGroup", "AgCrdnAngleRefTo", "AgCrdnAngleRotation", "AgCrdnAngleToPlane", "AgCrdnAxes", "AgCrdnAxesAlignedAndConstrained", 
"AgCrdnAxesAngularOffset", "AgCrdnAxesAtTimeInstant", "AgCrdnAxesAttitudeFile", "AgCrdnAxesBPlane", "AgCrdnAxesCommonTasks", 
"AgCrdnAxesCustomScript", "AgCrdnAxesFactory", "AgCrdnAxesFixed", "AgCrdnAxesFixedAtEpoch", "AgCrdnAxesGroup", "AgCrdnAxesLabels", 
"AgCrdnAxesLagrangeLibration", "AgCrdnAxesModelAttach", "AgCrdnAxesOnSurface", "AgCrdnAxesPlugin", "AgCrdnAxesRefTo", "AgCrdnAxesSamplingInterval", 
"AgCrdnAxesSamplingIntervalCollection", "AgCrdnAxesSamplingResult", "AgCrdnAxesSpinning", "AgCrdnAxesTrajectory", "AgCrdnCalcScalar", 
"AgCrdnCalcScalarAngle", "AgCrdnCalcScalarConstant", "AgCrdnCalcScalarCustom", "AgCrdnCalcScalarDataElement", "AgCrdnCalcScalarDerivative", 
"AgCrdnCalcScalarDotProduct", "AgCrdnCalcScalarElapsedTime", "AgCrdnCalcScalarFactory", "AgCrdnCalcScalarFile", "AgCrdnCalcScalarFixedAtTimeInstant", 
"AgCrdnCalcScalarFunction", "AgCrdnCalcScalarFunction2Var", "AgCrdnCalcScalarGroup", "AgCrdnCalcScalarIntegral", "AgCrdnCalcScalarPlugin", 
"AgCrdnCalcScalarSurfaceDistanceBetweenPoints", "AgCrdnCalcScalarVectorComponent", "AgCrdnCalcScalarVectorMagnitude", "AgCrdnCentralBody", 
"AgCrdnCentralBodyCollection", "AgCrdnCentralBodyRefTo", "AgCrdnCollection", "AgCrdnCondition", "AgCrdnConditionCombined", 
"AgCrdnConditionFactory", "AgCrdnConditionGroup", "AgCrdnConditionPointInVolume", "AgCrdnConditionScalarBounds", "AgCrdnConditionSet", 
"AgCrdnConditionSetEvaluateResult", "AgCrdnConditionSetEvaluateWithRateResult", "AgCrdnConditionSetFactory", "AgCrdnConditionSetGroup", 
"AgCrdnConditionSetScalarThresholds", "AgCrdnConverge", "AgCrdnConvergeBasic", "AgCrdnDerivative", "AgCrdnDerivativeBasic", 
"AgCrdnEvaluateResult", "AgCrdnEvaluateWithRateResult", "AgCrdnEvent", "AgCrdnEventArray", "AgCrdnEventArrayConditionCrossings", 
"AgCrdnEventArrayExtrema", "AgCrdnEventArrayFactory", "AgCrdnEventArrayFiltered", "AgCrdnEventArrayFixedStep", "AgCrdnEventArrayFixedTimes", 
"AgCrdnEventArrayGroup", "AgCrdnEventArrayMerged", "AgCrdnEventArraySignaled", "AgCrdnEventArrayStartStopTimes", "AgCrdnEventEpoch", 
"AgCrdnEventExtremum", "AgCrdnEventFactory", "AgCrdnEventFindOccurrenceResult", "AgCrdnEventGroup", "AgCrdnEventInterval", 
"AgCrdnEventIntervalBetweenTimeInstants", "AgCrdnEventIntervalCollection", "AgCrdnEventIntervalCollectionCondition", "AgCrdnEventIntervalCollectionFactory", 
"AgCrdnEventIntervalCollectionGroup", "AgCrdnEventIntervalCollectionLighting", "AgCrdnEventIntervalCollectionOccurredResult", 
"AgCrdnEventIntervalCollectionSignaled", "AgCrdnEventIntervalFactory", "AgCrdnEventIntervalFixed", "AgCrdnEventIntervalFixedDuration", 
"AgCrdnEventIntervalFromIntervalList", "AgCrdnEventIntervalGroup", "AgCrdnEventIntervalList", "AgCrdnEventIntervalListCondition", 
"AgCrdnEventIntervalListFactory", "AgCrdnEventIntervalListFile", "AgCrdnEventIntervalListFiltered", "AgCrdnEventIntervalListFixed", 
"AgCrdnEventIntervalListGroup", "AgCrdnEventIntervalListMerged", "AgCrdnEventIntervalListScaled", "AgCrdnEventIntervalListSignaled", 
"AgCrdnEventIntervalListTimeOffset", "AgCrdnEventIntervalResult", "AgCrdnEventIntervalScaled", "AgCrdnEventIntervalSignaled", 
"AgCrdnEventIntervalSmartInterval", "AgCrdnEventIntervalTimeOffset", "AgCrdnEventSignaled", "AgCrdnEventSmartEpoch", "AgCrdnEventStartStopTime", 
"AgCrdnEventTimeOffset", "AgCrdnFindTimesResult", "AgCrdnFirstIntervalsFilter", "AgCrdnGapsFilter", "AgCrdnGeneric", "AgCrdnGridCoordinateDefinition", 
"AgCrdnGridValuesCustom", "AgCrdnGridValuesFixedNumberOfSteps", "AgCrdnGridValuesFixedStep", "AgCrdnGridValuesMethod", "AgCrdnInstance", 
"AgCrdnIntegral", "AgCrdnIntegralBasic", "AgCrdnInterp", "AgCrdnInterpBasic", "AgCrdnInterval", "AgCrdnIntervalCollection", 
"AgCrdnIntervalListResult", "AgCrdnIntervalVectorCollection", "AgCrdnIntervalsFilter", "AgCrdnIntervalsVectorResult", "AgCrdnLLAPosition", 
"AgCrdnLastIntervalsFilter", "AgCrdnLightTimeDelay", "AgCrdnMethodCallAngleFindAngleResult", "AgCrdnMethodCallAngleFindAngleWithRateResult", 
"AgCrdnMethodCallAngleFindResult", "AgCrdnMethodCallAngleFindWithRateResult", "AgCrdnMethodCallAxesFindInAxesResult", "AgCrdnMethodCallAxesFindInAxesWithRateResult", 
"AgCrdnMethodCallAxesTransformResult", "AgCrdnMethodCallAxesTransformWithRateResult", "AgCrdnMethodCallPlaneFindInAxesResult", 
"AgCrdnMethodCallPlaneFindInAxesWithRateResult", "AgCrdnMethodCallPlaneFindInSystemResult", "AgCrdnMethodCallPlaneFindInSystemWithRateResult", 
"AgCrdnMethodCallPointLocateInSystemResult", "AgCrdnMethodCallPointLocateInSystemWithRateResult", "AgCrdnMethodCallSystemFindInSystemResult", 
"AgCrdnMethodCallSystemTransformResult", "AgCrdnMethodCallSystemTransformWithRateResult", "AgCrdnMethodCallVectorFindInAxesResult", 
"AgCrdnMethodCallVectorFindInAxesWithRateResult", "AgCrdnParameterSet", "AgCrdnParameterSetAttitude", "AgCrdnParameterSetFactory", 
"AgCrdnParameterSetGroundTrajectory", "AgCrdnParameterSetGroup", "AgCrdnParameterSetOrbit", "AgCrdnParameterSetTrajectory", 
"AgCrdnParameterSetVector", "AgCrdnPlane", "AgCrdnPlaneFactory", "AgCrdnPlaneGroup", "AgCrdnPlaneLabels", "AgCrdnPlaneNormal", 
"AgCrdnPlaneQuadrant", "AgCrdnPlaneRefTo", "AgCrdnPlaneTrajectory", "AgCrdnPlaneTriad", "AgCrdnPlaneTwoVector", "AgCrdnPoint", 
"AgCrdnPointAtTimeInstant", "AgCrdnPointBPlane", "AgCrdnPointCBFixedOffset", "AgCrdnPointCentBodyIntersect", "AgCrdnPointCommonTasks", 
"AgCrdnPointCovarianceGrazing", "AgCrdnPointFactory", "AgCrdnPointFile", "AgCrdnPointFixedInSystem", "AgCrdnPointGlint", 
"AgCrdnPointGrazing", "AgCrdnPointGroup", "AgCrdnPointLagrangeLibration", "AgCrdnPointModelAttach", "AgCrdnPointOnSurface", 
"AgCrdnPointPlaneIntersection", "AgCrdnPointPlaneProjection", "AgCrdnPointPlugin", "AgCrdnPointRefTo", "AgCrdnPointSamplingInterval", 
"AgCrdnPointSamplingIntervalCollection", "AgCrdnPointSamplingResult", "AgCrdnPointSatelliteCollectionEntry", "AgCrdnProvider", 
"AgCrdnPruneFilter", "AgCrdnPruneFilterFactory", "AgCrdnRelativeSatisfactionConditionFilter", "AgCrdnRoot", "AgCrdnSampling", 
"AgCrdnSamplingBasic", "AgCrdnSamplingCurvatureTolerance", "AgCrdnSamplingFixedStep", "AgCrdnSamplingMethod", "AgCrdnSamplingMethodFactory", 
"AgCrdnSamplingRelativeTolerance", "AgCrdnSatisfactionConditionFilter", "AgCrdnSignalDelay", "AgCrdnSignalDelayBasic", "AgCrdnSystem", 
"AgCrdnSystemAssembled", "AgCrdnSystemCommonTasks", "AgCrdnSystemFactory", "AgCrdnSystemGroup", "AgCrdnSystemOnSurface", 
"AgCrdnSystemRefTo", "AgCrdnTemplate", "AgCrdnTypeInfo", "AgCrdnVector", "AgCrdnVectorAngleRate", "AgCrdnVectorAngularVelocity", 
"AgCrdnVectorApoapsis", "AgCrdnVectorConing", "AgCrdnVectorCross", "AgCrdnVectorCustomScript", "AgCrdnVectorDerivative", 
"AgCrdnVectorDirectionToStar", "AgCrdnVectorDispSurface", "AgCrdnVectorDisplacement", "AgCrdnVectorEccentricity", "AgCrdnVectorFactory", 
"AgCrdnVectorFixedAtEpoch", "AgCrdnVectorFixedAtTimeInstant", "AgCrdnVectorFixedInAxes", "AgCrdnVectorGroup", "AgCrdnVectorLineOfNodes", 
"AgCrdnVectorLinearCombination", "AgCrdnVectorModelAttach", "AgCrdnVectorOrbitAngularMomentum", "AgCrdnVectorOrbitNormal", 
"AgCrdnVectorPeriapsis", "AgCrdnVectorPlugin", "AgCrdnVectorProjectAlongVector", "AgCrdnVectorProjection", "AgCrdnVectorRefTo", 
"AgCrdnVectorReflection", "AgCrdnVectorRotationVector", "AgCrdnVectorScalarLinearCombination", "AgCrdnVectorScalarScaled", 
"AgCrdnVectorScaled", "AgCrdnVectorTwoPlanesIntersection", "AgCrdnVectorVelocityAcceleration", "AgCrdnVolume", "AgCrdnVolumeCalc", 
"AgCrdnVolumeCalcAltitude", "AgCrdnVolumeCalcAngleOffVector", "AgCrdnVolumeCalcConditionSatMetric", "AgCrdnVolumeCalcDelayRange", 
"AgCrdnVolumeCalcFactory", "AgCrdnVolumeCalcFile", "AgCrdnVolumeCalcFromScalar", "AgCrdnVolumeCalcGroup", "AgCrdnVolumeCalcRange", 
"AgCrdnVolumeCalcSolarIntensity", "AgCrdnVolumeCombined", "AgCrdnVolumeFactory", "AgCrdnVolumeFromCalc", "AgCrdnVolumeFromCondition", 
"AgCrdnVolumeFromGrid", "AgCrdnVolumeFromTimeSatisfaction", "AgCrdnVolumeGrid", "AgCrdnVolumeGridBearingAlt", "AgCrdnVolumeGridCartesian", 
"AgCrdnVolumeGridConstrained", "AgCrdnVolumeGridCylindrical", "AgCrdnVolumeGridFactory", "AgCrdnVolumeGridGroup", "AgCrdnVolumeGridLatLonAlt", 
"AgCrdnVolumeGridResult", "AgCrdnVolumeGridSpherical", "AgCrdnVolumeGroup", "AgCrdnVolumeInview", "AgCrdnVolumeLighting", 
"AgCrdnVolumeOverTime", "AgCrdnWellKnownAxes", "AgCrdnWellKnownEarthAxes", "AgCrdnWellKnownEarthSystems", "AgCrdnWellKnownSunAxes", 
"AgCrdnWellKnownSunSystems", "AgCrdnWellKnownSystems", "AgECrdnAngleType", "AgECrdnAxesType", "AgECrdnCalcScalarType", "AgECrdnConditionCombinedOperationType", 
"AgECrdnConditionSetType", "AgECrdnConditionThresholdOption", "AgECrdnConditionType", "AgECrdnDimensionInheritance", "AgECrdnDirectionType", 
"AgECrdnDisplayAxisSelector", "AgECrdnEventArrayFilterType", "AgECrdnEventArrayType", "AgECrdnEventIntervalCollectionType", 
"AgECrdnEventIntervalListType", "AgECrdnEventIntervalType", "AgECrdnEventListMergeOperation", "AgECrdnEventType", "AgECrdnExtremumConstants", 
"AgECrdnFileInterpolatorType", "AgECrdnIntegralType", "AgECrdnIntegrationWindowType", "AgECrdnInterpolatorType", "AgECrdnIntersectionSurface", 
"AgECrdnIntervalDurationKind", "AgECrdnIntervalSelection", "AgECrdnKind", "AgECrdnLagrangeLibrationPointType", "AgECrdnMeanElementTheory", 
"AgECrdnParameterSetType", "AgECrdnPlaneType", "AgECrdnPointBPlaneType", "AgECrdnPointType", "AgECrdnPruneFilter", "AgECrdnQuadrantType", 
"AgECrdnReferenceShapeType", "AgECrdnSampledReferenceTime", "AgECrdnSamplingMethod", "AgECrdnSatisfactionCrossing", "AgECrdnSaveDataOption", 
"AgECrdnSignalPathReferenceSystem", "AgECrdnSignalSense", "AgECrdnSignedAngleType", "AgECrdnSmartEpochState", "AgECrdnSmartIntervalState", 
"AgECrdnSpeedOptions", "AgECrdnStartStopOption", "AgECrdnSurfaceType", "AgECrdnSweepMode", "AgECrdnSystemType", "AgECrdnThreshConvergeSense", 
"AgECrdnTrajectoryAxesType", "AgECrdnVectorComponentType", "AgECrdnVectorScaledDimensionInheritance", "AgECrdnVectorType", 
"AgECrdnVolumeAberrationType", "AgECrdnVolumeCalcAltitudeReferenceType", "AgECrdnVolumeCalcAngleOffVectorType", "AgECrdnVolumeCalcRangeDistanceType", 
"AgECrdnVolumeCalcRangeSpeedType", "AgECrdnVolumeCalcType", "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType", "AgECrdnVolumeCalcVolumeSatisfactionDurationType", 
"AgECrdnVolumeCalcVolumeSatisfactionFilterType", "AgECrdnVolumeCalcVolumeSatisfactionMetricType", "AgECrdnVolumeClockHostType", 
"AgECrdnVolumeCombinedOperationType", "AgECrdnVolumeFromGridEdgeType", "AgECrdnVolumeGridType", "AgECrdnVolumeLightingConditionsType", 
"AgECrdnVolumeOverTimeDurationType", "AgECrdnVolumeResultVectorRequest", "AgECrdnVolumeTimeSenseType", "AgECrdnVolumeType", 
"AgECrdnVolumetricGridValuesMethodType", "IAgCrdn", "IAgCrdnAngle", "IAgCrdnAngleBetweenPlanes", "IAgCrdnAngleBetweenVectors", 
"IAgCrdnAngleDihedral", "IAgCrdnAngleFactory", "IAgCrdnAngleFindAngleResult", "IAgCrdnAngleFindAngleWithRateResult", "IAgCrdnAngleFindResult", 
"IAgCrdnAngleFindWithRateResult", "IAgCrdnAngleGroup", "IAgCrdnAngleRefTo", "IAgCrdnAngleRotation", "IAgCrdnAngleToPlane", 
"IAgCrdnAxes", "IAgCrdnAxesAlignedAndConstrained", "IAgCrdnAxesAngularOffset", "IAgCrdnAxesAtTimeInstant", "IAgCrdnAxesAttitudeFile", 
"IAgCrdnAxesBPlane", "IAgCrdnAxesCommonTasks", "IAgCrdnAxesCustomScript", "IAgCrdnAxesFactory", "IAgCrdnAxesFindInAxesResult", 
"IAgCrdnAxesFindInAxesWithRateResult", "IAgCrdnAxesFixed", "IAgCrdnAxesFixedAtEpoch", "IAgCrdnAxesGroup", "IAgCrdnAxesLabels", 
"IAgCrdnAxesLagrangeLibration", "IAgCrdnAxesModelAttach", "IAgCrdnAxesOnSurface", "IAgCrdnAxesPlugin", "IAgCrdnAxesRefTo", 
"IAgCrdnAxesSamplingInterval", "IAgCrdnAxesSamplingIntervalCollection", "IAgCrdnAxesSamplingResult", "IAgCrdnAxesSpinning", 
"IAgCrdnAxesTrajectory", "IAgCrdnAxesTransformResult", "IAgCrdnAxesTransformWithRateResult", "IAgCrdnCalcScalar", "IAgCrdnCalcScalarAngle", 
"IAgCrdnCalcScalarConstant", "IAgCrdnCalcScalarCustom", "IAgCrdnCalcScalarDataElement", "IAgCrdnCalcScalarDerivative", "IAgCrdnCalcScalarDotProduct", 
"IAgCrdnCalcScalarElapsedTime", "IAgCrdnCalcScalarFactory", "IAgCrdnCalcScalarFile", "IAgCrdnCalcScalarFixedAtTimeInstant", 
"IAgCrdnCalcScalarFunction", "IAgCrdnCalcScalarFunction2Var", "IAgCrdnCalcScalarGroup", "IAgCrdnCalcScalarIntegral", "IAgCrdnCalcScalarPlugin", 
"IAgCrdnCalcScalarSurfaceDistanceBetweenPoints", "IAgCrdnCalcScalarVectorComponent", "IAgCrdnCalcScalarVectorMagnitude", 
"IAgCrdnCentralBody", "IAgCrdnCentralBodyCollection", "IAgCrdnCentralBodyRefTo", "IAgCrdnCollection", "IAgCrdnCondition", 
"IAgCrdnConditionCombined", "IAgCrdnConditionFactory", "IAgCrdnConditionGroup", "IAgCrdnConditionPointInVolume", "IAgCrdnConditionScalarBounds", 
"IAgCrdnConditionSet", "IAgCrdnConditionSetEvaluateResult", "IAgCrdnConditionSetEvaluateWithRateResult", "IAgCrdnConditionSetFactory", 
"IAgCrdnConditionSetGroup", "IAgCrdnConditionSetScalarThresholds", "IAgCrdnContext", "IAgCrdnConverge", "IAgCrdnConvergeBasic", 
"IAgCrdnDerivative", "IAgCrdnDerivativeBasic", "IAgCrdnEvaluateResult", "IAgCrdnEvaluateWithRateResult", "IAgCrdnEvent", 
"IAgCrdnEventArray", "IAgCrdnEventArrayConditionCrossings", "IAgCrdnEventArrayExtrema", "IAgCrdnEventArrayFactory", "IAgCrdnEventArrayFiltered", 
"IAgCrdnEventArrayFixedStep", "IAgCrdnEventArrayFixedTimes", "IAgCrdnEventArrayGroup", "IAgCrdnEventArrayMerged", "IAgCrdnEventArraySignaled", 
"IAgCrdnEventArrayStartStopTimes", "IAgCrdnEventEpoch", "IAgCrdnEventExtremum", "IAgCrdnEventFactory", "IAgCrdnEventFindOccurrenceResult", 
"IAgCrdnEventGroup", "IAgCrdnEventInterval", "IAgCrdnEventIntervalBetweenTimeInstants", "IAgCrdnEventIntervalCollection", 
"IAgCrdnEventIntervalCollectionCondition", "IAgCrdnEventIntervalCollectionFactory", "IAgCrdnEventIntervalCollectionGroup", 
"IAgCrdnEventIntervalCollectionLighting", "IAgCrdnEventIntervalCollectionOccurredResult", "IAgCrdnEventIntervalCollectionSignaled", 
"IAgCrdnEventIntervalFactory", "IAgCrdnEventIntervalFixed", "IAgCrdnEventIntervalFixedDuration", "IAgCrdnEventIntervalFromIntervalList", 
"IAgCrdnEventIntervalGroup", "IAgCrdnEventIntervalList", "IAgCrdnEventIntervalListCondition", "IAgCrdnEventIntervalListFactory", 
"IAgCrdnEventIntervalListFile", "IAgCrdnEventIntervalListFiltered", "IAgCrdnEventIntervalListFixed", "IAgCrdnEventIntervalListGroup", 
"IAgCrdnEventIntervalListMerged", "IAgCrdnEventIntervalListScaled", "IAgCrdnEventIntervalListSignaled", "IAgCrdnEventIntervalListTimeOffset", 
"IAgCrdnEventIntervalResult", "IAgCrdnEventIntervalScaled", "IAgCrdnEventIntervalSignaled", "IAgCrdnEventIntervalSmartInterval", 
"IAgCrdnEventIntervalTimeOffset", "IAgCrdnEventSignaled", "IAgCrdnEventSmartEpoch", "IAgCrdnEventStartStopTime", "IAgCrdnEventTimeOffset", 
"IAgCrdnFindTimesResult", "IAgCrdnFirstIntervalsFilter", "IAgCrdnGapsFilter", "IAgCrdnGridCoordinateDefinition", "IAgCrdnGridValuesCustom", 
"IAgCrdnGridValuesFixedNumberOfSteps", "IAgCrdnGridValuesFixedStep", "IAgCrdnGridValuesMethod", "IAgCrdnInstance", "IAgCrdnIntegral", 
"IAgCrdnIntegralBasic", "IAgCrdnInterp", "IAgCrdnInterpBasic", "IAgCrdnInterval", "IAgCrdnIntervalCollection", "IAgCrdnIntervalListResult", 
"IAgCrdnIntervalVectorCollection", "IAgCrdnIntervalsFilter", "IAgCrdnIntervalsVectorResult", "IAgCrdnLLAPosition", "IAgCrdnLastIntervalsFilter", 
"IAgCrdnLightTimeDelay", "IAgCrdnMethodCallResult", "IAgCrdnParameterSet", "IAgCrdnParameterSetAttitude", "IAgCrdnParameterSetFactory", 
"IAgCrdnParameterSetGroundTrajectory", "IAgCrdnParameterSetGroup", "IAgCrdnParameterSetOrbit", "IAgCrdnParameterSetTrajectory", 
"IAgCrdnParameterSetVector", "IAgCrdnPlane", "IAgCrdnPlaneFactory", "IAgCrdnPlaneFindInAxesResult", "IAgCrdnPlaneFindInAxesWithRateResult", 
"IAgCrdnPlaneFindInSystemResult", "IAgCrdnPlaneFindInSystemWithRateResult", "IAgCrdnPlaneGroup", "IAgCrdnPlaneLabels", "IAgCrdnPlaneNormal", 
"IAgCrdnPlaneQuadrant", "IAgCrdnPlaneRefTo", "IAgCrdnPlaneTrajectory", "IAgCrdnPlaneTriad", "IAgCrdnPlaneTwoVector", "IAgCrdnPoint", 
"IAgCrdnPointAtTimeInstant", "IAgCrdnPointBPlane", "IAgCrdnPointCBFixedOffset", "IAgCrdnPointCentBodyIntersect", "IAgCrdnPointCommonTasks", 
"IAgCrdnPointCovarianceGrazing", "IAgCrdnPointFactory", "IAgCrdnPointFile", "IAgCrdnPointFixedInSystem", "IAgCrdnPointGlint", 
"IAgCrdnPointGrazing", "IAgCrdnPointGroup", "IAgCrdnPointLagrangeLibration", "IAgCrdnPointLocateInSystemResult", "IAgCrdnPointLocateInSystemWithRateResult", 
"IAgCrdnPointModelAttach", "IAgCrdnPointOnSurface", "IAgCrdnPointPlaneIntersection", "IAgCrdnPointPlaneProjection", "IAgCrdnPointPlugin", 
"IAgCrdnPointRefTo", "IAgCrdnPointSamplingInterval", "IAgCrdnPointSamplingIntervalCollection", "IAgCrdnPointSamplingResult", 
"IAgCrdnPointSatelliteCollectionEntry", "IAgCrdnProvider", "IAgCrdnPruneFilter", "IAgCrdnPruneFilterFactory", "IAgCrdnRefTo", 
"IAgCrdnRelativeSatisfactionConditionFilter", "IAgCrdnRoot", "IAgCrdnSampling", "IAgCrdnSamplingBasic", "IAgCrdnSamplingCurvatureTolerance", 
"IAgCrdnSamplingFixedStep", "IAgCrdnSamplingMethod", "IAgCrdnSamplingMethodFactory", "IAgCrdnSamplingRelativeTolerance", 
"IAgCrdnSatisfactionConditionFilter", "IAgCrdnSignalDelay", "IAgCrdnSignalDelayBasic", "IAgCrdnSystem", "IAgCrdnSystemAssembled", 
"IAgCrdnSystemCommonTasks", "IAgCrdnSystemFactory", "IAgCrdnSystemFindInSystemResult", "IAgCrdnSystemGroup", "IAgCrdnSystemOnSurface", 
"IAgCrdnSystemRefTo", "IAgCrdnSystemTransformResult", "IAgCrdnSystemTransformWithRateResult", "IAgCrdnTemplate", "IAgCrdnTimeProperties", 
"IAgCrdnTypeInfo", "IAgCrdnVector", "IAgCrdnVectorAngleRate", "IAgCrdnVectorAngularVelocity", "IAgCrdnVectorApoapsis", "IAgCrdnVectorConing", 
"IAgCrdnVectorCross", "IAgCrdnVectorCustomScript", "IAgCrdnVectorDerivative", "IAgCrdnVectorDirectionToStar", "IAgCrdnVectorDispSurface", 
"IAgCrdnVectorDisplacement", "IAgCrdnVectorEccentricity", "IAgCrdnVectorFactory", "IAgCrdnVectorFindInAxesResult", "IAgCrdnVectorFindInAxesWithRateResult", 
"IAgCrdnVectorFixedAtEpoch", "IAgCrdnVectorFixedAtTimeInstant", "IAgCrdnVectorFixedInAxes", "IAgCrdnVectorGroup", "IAgCrdnVectorLineOfNodes", 
"IAgCrdnVectorLinearCombination", "IAgCrdnVectorModelAttach", "IAgCrdnVectorOrbitAngularMomentum", "IAgCrdnVectorOrbitNormal", 
"IAgCrdnVectorPeriapsis", "IAgCrdnVectorPlugin", "IAgCrdnVectorProjectAlongVector", "IAgCrdnVectorProjection", "IAgCrdnVectorRefTo", 
"IAgCrdnVectorReflection", "IAgCrdnVectorRotationVector", "IAgCrdnVectorScalarLinearCombination", "IAgCrdnVectorScalarScaled", 
"IAgCrdnVectorScaled", "IAgCrdnVectorTwoPlanesIntersection", "IAgCrdnVectorVelocityAcceleration", "IAgCrdnVolume", "IAgCrdnVolumeCalc", 
"IAgCrdnVolumeCalcAltitude", "IAgCrdnVolumeCalcAngleOffVector", "IAgCrdnVolumeCalcConditionSatMetric", "IAgCrdnVolumeCalcDelayRange", 
"IAgCrdnVolumeCalcFactory", "IAgCrdnVolumeCalcFile", "IAgCrdnVolumeCalcFromScalar", "IAgCrdnVolumeCalcGroup", "IAgCrdnVolumeCalcRange", 
"IAgCrdnVolumeCalcSolarIntensity", "IAgCrdnVolumeCombined", "IAgCrdnVolumeFactory", "IAgCrdnVolumeFromCalc", "IAgCrdnVolumeFromCondition", 
"IAgCrdnVolumeFromGrid", "IAgCrdnVolumeFromTimeSatisfaction", "IAgCrdnVolumeGrid", "IAgCrdnVolumeGridBearingAlt", "IAgCrdnVolumeGridCartesian", 
"IAgCrdnVolumeGridConstrained", "IAgCrdnVolumeGridCylindrical", "IAgCrdnVolumeGridFactory", "IAgCrdnVolumeGridGroup", "IAgCrdnVolumeGridLatLonAlt", 
"IAgCrdnVolumeGridResult", "IAgCrdnVolumeGridSpherical", "IAgCrdnVolumeGroup", "IAgCrdnVolumeInview", "IAgCrdnVolumeLighting", 
"IAgCrdnVolumeOverTime", "IAgCrdnWellKnownAxes", "IAgCrdnWellKnownEarthAxes", "IAgCrdnWellKnownEarthSystems", "IAgCrdnWellKnownSunAxes", 
"IAgCrdnWellKnownSunSystems", "IAgCrdnWellKnownSystems"]

import typing

from ctypes   import byref, POINTER
from datetime import datetime
from enum     import IntEnum, IntFlag

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .internal  import dataanalysisutil as agdata
from .utilities import colors           as agcolor
from .internal.comutil     import IUnknown, IDispatch, IPictureDisp
from .internal.apiutil     import interface_proxy, enumerator_proxy, out_arg
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgECrdnCalcScalarType(IntEnum):
    """Defines available calculation scalar types."""
    # Unknown or unsupported calculation scalar types
    eCrdnCalcScalarTypeUnknown = -1
    # Scalar equal to angular displacement obtained from any angle in VGT.
    eCrdnCalcScalarTypeAngle = 0
    # Constant scalar created by evaluating input scalar calculation at specified reference time instant.
    eCrdnCalcScalarTypeFixedAtTimeInstant = 1
    # Constant scalar value of specified dimension.
    eCrdnCalcScalarTypeConstant = 2
    # Any time-dependent data element from STK data providers available for parent STK object.
    eCrdnCalcScalarTypeDataElement = 3
    # Derivative of input scalar calculation.
    eCrdnCalcScalarTypeDerivative = 4
    # Time elapsed since reference time instant.
    eCrdnCalcScalarTypeElapsedTime = 5
    # Tabulated scalar calculation data loaded from specified file.
    eCrdnCalcScalarTypeFile = 6
    # Defined by performing one of specified functions on input scalar.
    eCrdnCalcScalarTypeFunction = 7
    # Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types.
    eCrdnCalcScalarTypeIntegral = 8
    # Defined by performing one of specified binary operations on two scalar arguments.
    eCrdnCalcScalarTypeFunction2Var = 9
    # Scalar equal to magnitude of specified vector.
    eCrdnCalcScalarTypeVectorMagnitude = 10
    # A calc scalar plugin based on a COM object.
    eCrdnCalcScalarTypePlugin = 11
    # A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate.
    eCrdnCalcScalarTypeCustomScript = 12
    # Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude).
    eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints = 13
    # Scalar equal to the dot product between two vectors.
    eCrdnCalcScalarTypeDotProduct = 14
    # Scalar equal to the specified component of a vector when resolved in the specified axes.
    eCrdnCalcScalarTypeVectorComponent = 15

AgECrdnCalcScalarType.eCrdnCalcScalarTypeUnknown.__doc__ = "Unknown or unsupported calculation scalar types"
AgECrdnCalcScalarType.eCrdnCalcScalarTypeAngle.__doc__ = "Scalar equal to angular displacement obtained from any angle in VGT."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFixedAtTimeInstant.__doc__ = "Constant scalar created by evaluating input scalar calculation at specified reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeConstant.__doc__ = "Constant scalar value of specified dimension."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDataElement.__doc__ = "Any time-dependent data element from STK data providers available for parent STK object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDerivative.__doc__ = "Derivative of input scalar calculation."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeElapsedTime.__doc__ = "Time elapsed since reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFile.__doc__ = "Tabulated scalar calculation data loaded from specified file."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction.__doc__ = "Defined by performing one of specified functions on input scalar."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeIntegral.__doc__ = "Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction2Var.__doc__ = "Defined by performing one of specified binary operations on two scalar arguments."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorMagnitude.__doc__ = "Scalar equal to magnitude of specified vector."
AgECrdnCalcScalarType.eCrdnCalcScalarTypePlugin.__doc__ = "A calc scalar plugin based on a COM object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeCustomScript.__doc__ = "A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints.__doc__ = "Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDotProduct.__doc__ = "Scalar equal to the dot product between two vectors."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorComponent.__doc__ = "Scalar equal to the specified component of a vector when resolved in the specified axes."

agcls.AgTypeNameMap["AgECrdnCalcScalarType"] = AgECrdnCalcScalarType

class AgECrdnConditionCombinedOperationType(IntEnum):
    """Defines scalar condition combined operation types."""
    # Scalar condition combined AND operation.
    eCrdnConditionCombinedOperationTypeAND = 1
    # Scalar condition combined OR operation.
    eCrdnConditionCombinedOperationTypeOR = 2
    # Scalar condition combined XOR operation.
    eCrdnConditionCombinedOperationTypeXOR = 3
    # Scalar condition combined MINUS operation.
    eCrdnConditionCombinedOperationTypeMINUS = 4

AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeAND.__doc__ = "Scalar condition combined AND operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeOR.__doc__ = "Scalar condition combined OR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeXOR.__doc__ = "Scalar condition combined XOR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeMINUS.__doc__ = "Scalar condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnConditionCombinedOperationType"] = AgECrdnConditionCombinedOperationType

class AgECrdnConditionSetType(IntEnum):
    """Defines available condition set types."""
    # Unknown or unsupported condition set types.
    eCrdnConditionSetTypeUnknown = -1
    # Condition set placing multiple thresholds on specified scalar.
    eCrdnConditionSetTypeScalarThresholds = 0

AgECrdnConditionSetType.eCrdnConditionSetTypeUnknown.__doc__ = "Unknown or unsupported condition set types."
AgECrdnConditionSetType.eCrdnConditionSetTypeScalarThresholds.__doc__ = "Condition set placing multiple thresholds on specified scalar."

agcls.AgTypeNameMap["AgECrdnConditionSetType"] = AgECrdnConditionSetType

class AgECrdnConditionThresholdOption(IntEnum):
    """Operations for Scalar Bounds Condition"""
    # Bound is above a minimum value
    eCrdnConditionThresholdOptionAboveMin = 1
    # Bound is below a maximum value
    eCrdnConditionThresholdOptionBelowMax = 2
    # Bound is between a minimum and maximum value
    eCrdnConditionThresholdOptionInsideMinMax = 3
    # Bound is outside a minimum and maximum value
    eCrdnConditionThresholdOptionOutsideMinMax = 4

AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionAboveMin.__doc__ = "Bound is above a minimum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionBelowMax.__doc__ = "Bound is below a maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionInsideMinMax.__doc__ = "Bound is between a minimum and maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionOutsideMinMax.__doc__ = "Bound is outside a minimum and maximum value"

agcls.AgTypeNameMap["AgECrdnConditionThresholdOption"] = AgECrdnConditionThresholdOption

class AgECrdnConditionType(IntEnum):
    """Defines available condition types."""
    # Unknown or unsupported condition type
    eCrdnConditionTypeUnknown = -1
    # Condition placing bounds on specified scalar.
    eCrdnConditionTypeScalarBounds = 0
    # Multiple conditiones on specified scalar.
    eCrdnConditionTypeCombined = 1
    # Condition placing point in volume.
    eCrdnConditionTypePointInVolume = 2

AgECrdnConditionType.eCrdnConditionTypeUnknown.__doc__ = "Unknown or unsupported condition type"
AgECrdnConditionType.eCrdnConditionTypeScalarBounds.__doc__ = "Condition placing bounds on specified scalar."
AgECrdnConditionType.eCrdnConditionTypeCombined.__doc__ = "Multiple conditiones on specified scalar."
AgECrdnConditionType.eCrdnConditionTypePointInVolume.__doc__ = "Condition placing point in volume."

agcls.AgTypeNameMap["AgECrdnConditionType"] = AgECrdnConditionType

class AgECrdnDimensionInheritance(IntEnum):
    """Defines how dimension is inherited"""
    # Do not inherit dimension.
    eCrdnDimensionInheritanceNone = 0
    # Inherit dimension from X scalar.
    eCrdnDimensionInheritanceFromX = 1
    # Inherit dimension from Y scalar.
    eCrdnDimensionInheritanceFromY = 2

AgECrdnDimensionInheritance.eCrdnDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromX.__doc__ = "Inherit dimension from X scalar."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromY.__doc__ = "Inherit dimension from Y scalar."

agcls.AgTypeNameMap["AgECrdnDimensionInheritance"] = AgECrdnDimensionInheritance

class AgECrdnEventArrayFilterType(IntEnum):
    """Event array filter types."""
    # Skip time step
    eCrdnEventArrayFilterTypeSkipTimeStep = 0
    # Skip count
    eCrdnEventArrayFilterTypeSkipCount = 1
    # Intervals
    eCrdnEventArrayFilterTypeIntervals = 2

AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipTimeStep.__doc__ = "Skip time step"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipCount.__doc__ = "Skip count"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeIntervals.__doc__ = "Intervals"

agcls.AgTypeNameMap["AgECrdnEventArrayFilterType"] = AgECrdnEventArrayFilterType

class AgECrdnEventArrayType(IntEnum):
    """Defines available time array types."""
    # Unknown or unsupported time array types
    eCrdnEventArrayTypeUnknown = -1
    # Determines time of local minimum and/or maximum of specified scalar calculation.
    eCrdnEventArrayTypeExtrema = 0
    # Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array.
    eCrdnEventArrayTypeStartStopTimes = 1
    # Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays.
    eCrdnEventArrayTypeMerged = 2
    # Defined by filtering times from original time array according to specified filtering method.
    eCrdnEventArrayTypeFiltered = 3
    # Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list.
    eCrdnEventArrayTypeFixedStep = 4
    # Time array containing times at which specified condition changes its satisfaction status.
    eCrdnEventArrayTypeConditionCrossings = 5
    # Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations.
    eCrdnEventArrayTypeSignaled = 6
    # Time array containing specific times.
    eCrdnEventArrayTypeFixedTimes = 7

AgECrdnEventArrayType.eCrdnEventArrayTypeUnknown.__doc__ = "Unknown or unsupported time array types"
AgECrdnEventArrayType.eCrdnEventArrayTypeExtrema.__doc__ = "Determines time of local minimum and/or maximum of specified scalar calculation."
AgECrdnEventArrayType.eCrdnEventArrayTypeStartStopTimes.__doc__ = "Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."
AgECrdnEventArrayType.eCrdnEventArrayTypeMerged.__doc__ = "Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."
AgECrdnEventArrayType.eCrdnEventArrayTypeFiltered.__doc__ = "Defined by filtering times from original time array according to specified filtering method."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedStep.__doc__ = "Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."
AgECrdnEventArrayType.eCrdnEventArrayTypeConditionCrossings.__doc__ = "Time array containing times at which specified condition changes its satisfaction status."
AgECrdnEventArrayType.eCrdnEventArrayTypeSignaled.__doc__ = "Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedTimes.__doc__ = "Time array containing specific times."

agcls.AgTypeNameMap["AgECrdnEventArrayType"] = AgECrdnEventArrayType

class AgECrdnEventIntervalCollectionType(IntEnum):
    """Defines available interval collection types."""
    # Unknown or unsupported interval collection types
    eCrdnEventIntervalCollectionTypeUnknown = -1
    # Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies.
    eCrdnEventIntervalCollectionTypeLighting = 0
    # Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations.
    eCrdnEventIntervalCollectionTypeSignaled = 1
    # Interval collection containing intervals during which condition set is satisfied.
    eCrdnEventIntervalCollectionTypeCondition = 2

AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeUnknown.__doc__ = "Unknown or unsupported interval collection types"
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeLighting.__doc__ = "Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeSignaled.__doc__ = "Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeCondition.__doc__ = "Interval collection containing intervals during which condition set is satisfied."

agcls.AgTypeNameMap["AgECrdnEventIntervalCollectionType"] = AgECrdnEventIntervalCollectionType

class AgECrdnEventIntervalListType(IntEnum):
    """Defines available interval list types."""
    # Unknown or unsupported interval list types
    eCrdnEventIntervalListTypeUnknown = -1
    # Interval list created by merging two constituent interval lists using specified logical operation.
    eCrdnEventIntervalListTypeMerged = 1
    # Defined by filtering intervals from original interval list using specified filtering method.
    eCrdnEventIntervalListTypeFiltered = 2
    # Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction).
    eCrdnEventIntervalListTypeCondition = 3
    # Interval List defined by scaling every interval in original interval list using either absolute or relative scale.
    eCrdnEventIntervalListTypeScaled = 4
    # Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations.
    eCrdnEventIntervalListTypeSignaled = 5
    # Interval List defined by shifting specified reference interval list by fixed time offset.
    eCrdnEventIntervalListTypeTimeOffset = 6
    # Interval list loaded from specified interval file
    eCrdnEventIntervalListTypeFile = 0
    # Interval list with individual intervals defined between explicitly specified start and stop times.
    eCrdnEventIntervalListTypeFixed = 7

AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeUnknown.__doc__ = "Unknown or unsupported interval list types"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeMerged.__doc__ = "Interval list created by merging two constituent interval lists using specified logical operation."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFiltered.__doc__ = "Defined by filtering intervals from original interval list using specified filtering method."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeCondition.__doc__ = "Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeScaled.__doc__ = "Interval List defined by scaling every interval in original interval list using either absolute or relative scale."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeSignaled.__doc__ = "Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeTimeOffset.__doc__ = "Interval List defined by shifting specified reference interval list by fixed time offset."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFile.__doc__ = "Interval list loaded from specified interval file"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFixed.__doc__ = "Interval list with individual intervals defined between explicitly specified start and stop times."

agcls.AgTypeNameMap["AgECrdnEventIntervalListType"] = AgECrdnEventIntervalListType

class AgECrdnEventIntervalType(IntEnum):
    """Defines available interval types."""
    # Unknown or unsupported interval types
    eCrdnEventIntervalTypeUnknown = -1
    # Interval defined between two explicitly specified start and stop times.
    eCrdnEventIntervalTypeFixed = 0
    # Interval of fixed duration specified using start and stop offsets relative to specified reference time instant.
    eCrdnEventIntervalTypeFixedDuration = 1
    # Interval between specified start and stop time instants.
    eCrdnEventIntervalTypeBetweenTimeInstants = 2
    # Interval created from specified interval list by using one of several selection methods.
    eCrdnEventIntervalTypeFromIntervalList = 3
    # Interval defined by scaling original interval using either absolute or relative scale.
    eCrdnEventIntervalTypeScaled = 4
    # Determines an interval recorded at a target clock location by performing signal transmission.
    eCrdnEventIntervalTypeSignaled = 5
    # Interval defined by shifting specified reference interval by fixed time offset.
    eCrdnEventIntervalTypeTimeOffset = 6
    # A smart interval.
    eCrdnEventIntervalTypeSmartInterval = 7

AgECrdnEventIntervalType.eCrdnEventIntervalTypeUnknown.__doc__ = "Unknown or unsupported interval types"
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixed.__doc__ = "Interval defined between two explicitly specified start and stop times."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixedDuration.__doc__ = "Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeBetweenTimeInstants.__doc__ = "Interval between specified start and stop time instants."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFromIntervalList.__doc__ = "Interval created from specified interval list by using one of several selection methods."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeScaled.__doc__ = "Interval defined by scaling original interval using either absolute or relative scale."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSignaled.__doc__ = "Determines an interval recorded at a target clock location by performing signal transmission."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeTimeOffset.__doc__ = "Interval defined by shifting specified reference interval by fixed time offset."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSmartInterval.__doc__ = "A smart interval."

agcls.AgTypeNameMap["AgECrdnEventIntervalType"] = AgECrdnEventIntervalType

class AgECrdnEventListMergeOperation(IntEnum):
    """Defines merge operations for interval lists."""
    # Intervals both in A and B
    eCrdnEventListMergeOperationAND = 0
    # Intervals in A or B
    eCrdnEventListMergeOperationOR = 1
    # Intervals in A or B but not in both
    eCrdnEventListMergeOperationXOR = 2
    # Intervals in A and not in B
    eCrdnEventListMergeOperationMINUS = 3

AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationAND.__doc__ = "Intervals both in A and B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationOR.__doc__ = "Intervals in A or B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationXOR.__doc__ = "Intervals in A or B but not in both"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationMINUS.__doc__ = "Intervals in A and not in B"

agcls.AgTypeNameMap["AgECrdnEventListMergeOperation"] = AgECrdnEventListMergeOperation

class AgECrdnEventType(IntEnum):
    """Defines available time instant types."""
    # Unknown or unsupported time instant types
    eCrdnEventTypeUnknown = -1
    # Time instant set at specified date/time
    eCrdnEventTypeEpoch = 0
    # Determines time of global minimum or maximum of specified scalar calculation.
    eCrdnEventTypeExtremum = 1
    # Start or stop time of selected reference interval
    eCrdnEventTypeFromInterval = 2
    # Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations.
    eCrdnEventTypeSignaled = 3
    # Time instant at fixed offset from specified reference time instant
    eCrdnEventTypeTimeOffset = 4
    # A smart epoch.
    eCrdnEventTypeSmartEpoch = 5

AgECrdnEventType.eCrdnEventTypeUnknown.__doc__ = "Unknown or unsupported time instant types"
AgECrdnEventType.eCrdnEventTypeEpoch.__doc__ = "Time instant set at specified date/time"
AgECrdnEventType.eCrdnEventTypeExtremum.__doc__ = "Determines time of global minimum or maximum of specified scalar calculation."
AgECrdnEventType.eCrdnEventTypeFromInterval.__doc__ = "Start or stop time of selected reference interval"
AgECrdnEventType.eCrdnEventTypeSignaled.__doc__ = "Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."
AgECrdnEventType.eCrdnEventTypeTimeOffset.__doc__ = "Time instant at fixed offset from specified reference time instant"
AgECrdnEventType.eCrdnEventTypeSmartEpoch.__doc__ = "A smart epoch."

agcls.AgTypeNameMap["AgECrdnEventType"] = AgECrdnEventType

class AgECrdnExtremumConstants(IntFlag):
    """These constants are utilized when finding a local or global minimum or maximum, or the threshold crossing."""
    # Find the minimum value
    eCrdnExtremumMinimum = 1
    # Find the maximum value
    eCrdnExtremumMaximum = 2

AgECrdnExtremumConstants.eCrdnExtremumMinimum.__doc__ = "Find the minimum value"
AgECrdnExtremumConstants.eCrdnExtremumMaximum.__doc__ = "Find the maximum value"

agcls.AgTypeNameMap["AgECrdnExtremumConstants"] = AgECrdnExtremumConstants

class AgECrdnFileInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnFileInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnFileInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnFileInterpolatorTypeHermite = 2
    # Holds the value at the closest previous sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldPrevious = 3
    # Holds the value at the closest next sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldNext = 4
    # Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time.
    eCrdnFileInterpolatorTypeHoldNearest = 5

AgECrdnFileInterpolatorType.eCrdnFileInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHermite.__doc__ = "Hermite interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldPrevious.__doc__ = "Holds the value at the closest previous sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNext.__doc__ = "Holds the value at the closest next sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNearest.__doc__ = "Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."

agcls.AgTypeNameMap["AgECrdnFileInterpolatorType"] = AgECrdnFileInterpolatorType

class AgECrdnIntegralType(IntEnum):
    """Integral types."""
    # Simpson integral method
    eCrdnIntegralTypeFixedStepSimpson = 2
    # Trapezoidal integral method
    eCrdnIntegralTypeFixedStepTrapz = 1
    # Adaptive Lobatto integral method
    eCrdnIntegralTypeAdaptiveStep = 3

AgECrdnIntegralType.eCrdnIntegralTypeFixedStepSimpson.__doc__ = "Simpson integral method"
AgECrdnIntegralType.eCrdnIntegralTypeFixedStepTrapz.__doc__ = "Trapezoidal integral method"
AgECrdnIntegralType.eCrdnIntegralTypeAdaptiveStep.__doc__ = "Adaptive Lobatto integral method"

agcls.AgTypeNameMap["AgECrdnIntegralType"] = AgECrdnIntegralType

class AgECrdnIntegrationWindowType(IntEnum):
    """Defines the interval of times during which an integral is evaluated."""
    # Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant.
    eCrdnIntegrationWindowTypeTotal = 0
    # Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time.
    eCrdnIntegrationWindowTypeCumulativeToCurrent = 1
    # Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time.
    eCrdnIntegrationWindowTypeCumulativeFromCurrent = 2
    # Defines the integral's window as the interval of times centered around the current time with the specified front and back durations.
    eCrdnIntegrationWindowTypeSlidingWindow = 3

AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeTotal.__doc__ = "Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeToCurrent.__doc__ = "Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeFromCurrent.__doc__ = "Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeSlidingWindow.__doc__ = "Defines the integral's window as the interval of times centered around the current time with the specified front and back durations."

agcls.AgTypeNameMap["AgECrdnIntegrationWindowType"] = AgECrdnIntegrationWindowType

class AgECrdnInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnInterpolatorTypeHermite = 2

AgECrdnInterpolatorType.eCrdnInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeHermite.__doc__ = "Hermite interpolation."

agcls.AgTypeNameMap["AgECrdnInterpolatorType"] = AgECrdnInterpolatorType

class AgECrdnIntervalDurationKind(IntEnum):
    """Duration for filtering intervals or gaps from interval lists or time arrays"""
    # Filter by at least a specified number of seconds
    eCrdnIntervalDurationKindAtLeast = 0
    # Filter by at most a specified number of seconds
    eCrdnIntervalDurationKindAtMost = 1

AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtLeast.__doc__ = "Filter by at least a specified number of seconds"
AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtMost.__doc__ = "Filter by at most a specified number of seconds"

agcls.AgTypeNameMap["AgECrdnIntervalDurationKind"] = AgECrdnIntervalDurationKind

class AgECrdnIntervalSelection(IntEnum):
    """Select the method to choose an interval from an interval list"""
    # Select an interval by counting a specified number from the first interval
    eCrdnIntervalSelectionFromStart = 1
    # Select an interval by counting a specified number back from the last interval
    eCrdnIntervalSelectionFromEnd = 2
    # Select the interval with the largest duration
    eCrdnIntervalSelectionMaxDuration = 4
    # Select the interval with the smallest duration
    eCrdnIntervalSelectionMinDuration = 5
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMaxGap = 9
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMinGap = 10
    # Select the interval that is the span of the interval list
    eCrdnIntervalSelectionSpan = 100

AgECrdnIntervalSelection.eCrdnIntervalSelectionFromStart.__doc__ = "Select an interval by counting a specified number from the first interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionFromEnd.__doc__ = "Select an interval by counting a specified number back from the last interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxDuration.__doc__ = "Select the interval with the largest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinDuration.__doc__ = "Select the interval with the smallest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionSpan.__doc__ = "Select the interval that is the span of the interval list"

agcls.AgTypeNameMap["AgECrdnIntervalSelection"] = AgECrdnIntervalSelection

class AgECrdnParameterSetType(IntEnum):
    """Defines parameter set types."""
    # Unknown or unsupported parameter set
    eCrdnParameterSetTypeUnknown = -1
    # A parameter set type is defined by identifying one set of axes in reference to another.
    eCrdnParameterSetTypeAttitude = 0
    # A parameter set type is defined by identifying location in reference central body.
    eCrdnParameterSetTypeGroundTrajectory = 1
    # A parameter set type is defined by identifying location in reference coordinate system.
    eCrdnParameterSetTypeTrajectory = 2
    # A parameter set type is defined by identifying orbiting point and its central body.
    eCrdnParameterSetTypeOrbit = 3
    # A parameter set type is defined by identifying vector in reference axes.
    eCrdnParameterSetTypeVector = 4

AgECrdnParameterSetType.eCrdnParameterSetTypeUnknown.__doc__ = "Unknown or unsupported parameter set"
AgECrdnParameterSetType.eCrdnParameterSetTypeAttitude.__doc__ = "A parameter set type is defined by identifying one set of axes in reference to another."
AgECrdnParameterSetType.eCrdnParameterSetTypeGroundTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference coordinate system."
AgECrdnParameterSetType.eCrdnParameterSetTypeOrbit.__doc__ = "A parameter set type is defined by identifying orbiting point and its central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeVector.__doc__ = "A parameter set type is defined by identifying vector in reference axes."

agcls.AgTypeNameMap["AgECrdnParameterSetType"] = AgECrdnParameterSetType

class AgECrdnPruneFilter(IntEnum):
    """Specify the filter for filtering interval lists or time arrays"""
    # Unknown or unsupported prune filter
    eCrdnPruneFilterUnknown = 0
    # Selects specified number of first intervals from original list
    eCrdnPruneFilterFirstIntervals = 1
    # Selects specified number of last intervals from original list
    eCrdnPruneFilterLastIntervals = 2
    # Selects intervals which satisfy additional duration condition.
    eCrdnPruneFilterIntervals = 3
    # Selects gaps between intervals which satisfy additional duration condition.
    eCrdnPruneFilterGaps = 4
    # Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterSatisfactionIntervals = 5
    # Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterRelativeSatisfactionIntervals = 6

AgECrdnPruneFilter.eCrdnPruneFilterUnknown.__doc__ = "Unknown or unsupported prune filter"
AgECrdnPruneFilter.eCrdnPruneFilterFirstIntervals.__doc__ = "Selects specified number of first intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterLastIntervals.__doc__ = "Selects specified number of last intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterIntervals.__doc__ = "Selects intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterGaps.__doc__ = "Selects gaps between intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterSatisfactionIntervals.__doc__ = "Satisfaction Intervals selects intervals which satisfy additional condition and duration."
AgECrdnPruneFilter.eCrdnPruneFilterRelativeSatisfactionIntervals.__doc__ = "Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."

agcls.AgTypeNameMap["AgECrdnPruneFilter"] = AgECrdnPruneFilter

class AgECrdnSampledReferenceTime(IntEnum):
    """Event array reference type."""
    # Use a Time Instant as the reference time
    eCrdnSampledReferenceTimeReferenceEvent = 0
    # Use the start of each interval as the reference time
    eCrdnSampledReferenceTimeStartOfEachInterval = 1
    # Use the stop of each interval as the reference time
    eCrdnSampledReferenceTimeStopOfEachInterval = 2
    # Use the start of each interval list as the reference time
    eCrdnSampledReferenceTimeStartOfIntervalList = 3
    # Use the stop of each interval list as the reference time
    eCrdnSampledReferenceTimeStopOfIntervalList = 4

AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeReferenceEvent.__doc__ = "Use a Time Instant as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfEachInterval.__doc__ = "Use the start of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfEachInterval.__doc__ = "Use the stop of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfIntervalList.__doc__ = "Use the start of each interval list as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfIntervalList.__doc__ = "Use the stop of each interval list as the reference time"

agcls.AgTypeNameMap["AgECrdnSampledReferenceTime"] = AgECrdnSampledReferenceTime

class AgECrdnSamplingMethod(IntEnum):
    """Defines the Sampling Method"""
    # Unknown or unsupported sampling method
    eCrdnSamplingMethodUnknown = 0
    # Fixed step sampling method
    eCrdnSamplingMethodFixedStep = 1
    # Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples.
    eCrdnSamplingMethodRelativeTolerance = 2
    # Curvature tolerance also uses changes in slope between samples
    eCrdnSamplingMethodCurvatureTolerance = 3

AgECrdnSamplingMethod.eCrdnSamplingMethodUnknown.__doc__ = "Unknown or unsupported sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodFixedStep.__doc__ = "Fixed step sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodRelativeTolerance.__doc__ = "Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."
AgECrdnSamplingMethod.eCrdnSamplingMethodCurvatureTolerance.__doc__ = "Curvature tolerance also uses changes in slope between samples"

agcls.AgTypeNameMap["AgECrdnSamplingMethod"] = AgECrdnSamplingMethod

class AgECrdnSatisfactionCrossing(IntEnum):
    """Direction crossing flags."""
    # Use either off-to-on or on-to-off condition to determine satisfaction
    eCrdnSatisfactionCrossingNone = 0
    # Satisfaction occurs when crossing from off to on condition
    eCrdnSatisfactionCrossingIn = 1
    # Satisfaction occurs when crossing from on to off condition
    eCrdnSatisfactionCrossingOut = 2

AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingNone.__doc__ = "Use either off-to-on or on-to-off condition to determine satisfaction"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingIn.__doc__ = "Satisfaction occurs when crossing from off to on condition"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingOut.__doc__ = "Satisfaction occurs when crossing from on to off condition"

agcls.AgTypeNameMap["AgECrdnSatisfactionCrossing"] = AgECrdnSatisfactionCrossing

class AgECrdnSaveDataOption(IntEnum):
    """Method for saving computed data"""
    # Use the application setting to determine whether computed data should be saved/loaded.
    eCrdnSaveDataOptionApplicationSettings = -1
    # Save/load computed data.
    eCrdnSaveDataOptionYes = 100
    # Don't save computed data, recompute data on load.
    eCrdnSaveDataOptionNo = 10

AgECrdnSaveDataOption.eCrdnSaveDataOptionApplicationSettings.__doc__ = "Use the application setting to determine whether computed data should be saved/loaded."
AgECrdnSaveDataOption.eCrdnSaveDataOptionYes.__doc__ = "Save/load computed data."
AgECrdnSaveDataOption.eCrdnSaveDataOptionNo.__doc__ = "Don't save computed data, recompute data on load."

agcls.AgTypeNameMap["AgECrdnSaveDataOption"] = AgECrdnSaveDataOption

class AgECrdnSignalPathReferenceSystem(IntEnum):
    """Signal path reference system types."""
    # Use Access default system
    eCrdnSignalPathReferenceSystemUseAccessDefault = -1
    # Use central body inertial system
    eCrdnSignalPathReferenceSystemCentralBodyInertial = 0
    # Use solar system barycenter system
    eCrdnSignalPathReferenceSystemSolarSystemBarycenter = 1
    # User will specify a system
    eCrdnSignalPathReferenceSystemCustom = 2

AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemUseAccessDefault.__doc__ = "Use Access default system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCentralBodyInertial.__doc__ = "Use central body inertial system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemSolarSystemBarycenter.__doc__ = "Use solar system barycenter system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCustom.__doc__ = "User will specify a system"

agcls.AgTypeNameMap["AgECrdnSignalPathReferenceSystem"] = AgECrdnSignalPathReferenceSystem

class AgECrdnSmartEpochState(IntEnum):
    """Smart epoch states."""
    # Smart epoch is specified explicitly using a time.
    eCrdnSmartEpochStateExplicit = 0
    # Smart epoch is specified implicitly.
    eCrdnSmartEpochStateImplicit = 3

AgECrdnSmartEpochState.eCrdnSmartEpochStateExplicit.__doc__ = "Smart epoch is specified explicitly using a time."
AgECrdnSmartEpochState.eCrdnSmartEpochStateImplicit.__doc__ = "Smart epoch is specified implicitly."

agcls.AgTypeNameMap["AgECrdnSmartEpochState"] = AgECrdnSmartEpochState

class AgECrdnSmartIntervalState(IntEnum):
    """Smart interval states."""
    # Smart interval is specified explicitly using start/stop times.
    eCrdnSmartIntervalStateExplicit = 0
    # Smart interval is specified implicitly using start/stop times.
    eCrdnSmartIntervalStateImplicit = 1
    # Smart interval is specified using smart epochs.
    eCrdnSmartIntervalStateStartStop = 2
    # Smart interval is specified using a start epoch and duration.
    eCrdnSmartIntervalStateStartDuration = 4
    # Smart interval is specified using a start time and explicit duration.
    eCrdnSmartIntervalStateExplicitDuration = 3

AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicit.__doc__ = "Smart interval is specified explicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateImplicit.__doc__ = "Smart interval is specified implicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartStop.__doc__ = "Smart interval is specified using smart epochs."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartDuration.__doc__ = "Smart interval is specified using a start epoch and duration."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicitDuration.__doc__ = "Smart interval is specified using a start time and explicit duration."

agcls.AgTypeNameMap["AgECrdnSmartIntervalState"] = AgECrdnSmartIntervalState

class AgECrdnSpeedOptions(IntEnum):
    """Defines various speed options."""
    # Light transmission speed.
    eCrdnLightTransmissionSpeed = 1
    # Custom transmission speed.
    eCrdnCustomTransmissionSpeed = 2

AgECrdnSpeedOptions.eCrdnLightTransmissionSpeed.__doc__ = "Light transmission speed."
AgECrdnSpeedOptions.eCrdnCustomTransmissionSpeed.__doc__ = "Custom transmission speed."

agcls.AgTypeNameMap["AgECrdnSpeedOptions"] = AgECrdnSpeedOptions

class AgECrdnStartStopOption(IntEnum):
    """Start/stop options."""
    # Use the start time of the interval
    eCrdnStartStopOptionCountStartOnly = 1
    # Use the stop time of the interval
    eCrdnStartStopOptionCountStopOnly = 2
    # Use the start time and stop time of the interval
    eCrdnStartStopOptionCountStartStop = 3

AgECrdnStartStopOption.eCrdnStartStopOptionCountStartOnly.__doc__ = "Use the start time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStopOnly.__doc__ = "Use the stop time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStartStop.__doc__ = "Use the start time and stop time of the interval"

agcls.AgTypeNameMap["AgECrdnStartStopOption"] = AgECrdnStartStopOption

class AgECrdnThreshConvergeSense(IntEnum):
    """Specifies the desired sense of the results from threshold crossing computations."""
    # Just converge within tolerance.
    eCrdnThreshConvergeSenseSimple = 0
    # Result above or at threshold.
    eCrdnThreshConvergeSenseAbove = 1
    # Result below or at threshold.
    eCrdnThreshConvergeSenseBelow = 2

AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseSimple.__doc__ = "Just converge within tolerance."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseAbove.__doc__ = "Result above or at threshold."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseBelow.__doc__ = "Result below or at threshold."

agcls.AgTypeNameMap["AgECrdnThreshConvergeSense"] = AgECrdnThreshConvergeSense

class AgECrdnVectorComponentType(IntEnum):
    """Defines component directions for a vector."""
    # X component.
    eCrdnVectorComponentX = 0
    # Y component.
    eCrdnVectorComponentY = 1
    # Z component.
    eCrdnVectorComponentZ = 2
    # -X component.
    eCrdnVectorComponentMinusX = 3
    # -Y component.
    eCrdnVectorComponentMinusY = 4
    # -Z component.
    eCrdnVectorComponentMinusZ = 5

AgECrdnVectorComponentType.eCrdnVectorComponentX.__doc__ = "X component."
AgECrdnVectorComponentType.eCrdnVectorComponentY.__doc__ = "Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentZ.__doc__ = "Z component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusX.__doc__ = "-X component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusY.__doc__ = "-Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusZ.__doc__ = "-Z component."

agcls.AgTypeNameMap["AgECrdnVectorComponentType"] = AgECrdnVectorComponentType

class AgECrdnVolumeCalcAltitudeReferenceType(IntEnum):
    """Defines volume calc altitude reference types."""
    # Volume calc altitude above reference ellipsoid.
    eCrdnVolumeCalcAltitudeReferenceEllipsoid = 0
    # Volume calc altitude reference above terrain.
    eCrdnVolumeCalcAltitudeReferenceTerrain = 1
    # Volume calc altitude reference above mean sea level.
    eCrdnVolumeCalcAltitudeReferenceMSL = 2

AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceEllipsoid.__doc__ = "Volume calc altitude above reference ellipsoid."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceTerrain.__doc__ = "Volume calc altitude reference above terrain."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceMSL.__doc__ = "Volume calc altitude reference above mean sea level."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAltitudeReferenceType"] = AgECrdnVolumeCalcAltitudeReferenceType

class AgECrdnVolumeCalcAngleOffVectorType(IntEnum):
    """Defines volume calc angle off vector reference types."""
    # Volume calc angle off plane signed.
    eCrdnVolumeCalcAngleOffPlaneSigned = 1
    # Volume calc angle off plane unsigned.
    eCrdnVolumeCalcAngleOffPlaneUnsigned = 2
    # Volume calc angle about vector signed.
    eCrdnVolumeCalcAngleAboutVectorSigned = 4
    # Volume calc angle about vector unsigned.
    eCrdnVolumeCalcAngleAboutVectorUnsigned = 8
    # Volume calc angle off vector.
    eCrdnVolumeCalcAngleOffVector = 16

AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneSigned.__doc__ = "Volume calc angle off plane signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneUnsigned.__doc__ = "Volume calc angle off plane unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorSigned.__doc__ = "Volume calc angle about vector signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorUnsigned.__doc__ = "Volume calc angle about vector unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffVector.__doc__ = "Volume calc angle off vector."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAngleOffVectorType"] = AgECrdnVolumeCalcAngleOffVectorType

class AgECrdnVolumeCalcRangeDistanceType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceFromPoint = 0
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceAlongVectorSigned = 1
    # Volume calc range distance type along vector unsigned
    eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned = 2
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneSigned = 4
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneUnsigned = 8

AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceFromPoint.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorSigned.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned.__doc__ = "Volume calc range distance type along vector unsigned"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneSigned.__doc__ = "Volume calc range distance type plane signed"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneUnsigned.__doc__ = "Volume calc range distance type plane signed"

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeDistanceType"] = AgECrdnVolumeCalcRangeDistanceType

class AgECrdnVolumeCalcRangeSpeedType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedLight = 1
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedCustom = 2

AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedLight.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedCustom.__doc__ = "Volume calc range distance type from point."

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeSpeedType"] = AgECrdnVolumeCalcRangeSpeedType

class AgECrdnVolumeCalcType(IntEnum):
    """Defines volume calc types."""
    # Unknown or unsupported volume calc.
    eCrdnVolumeCalcTypeUnknown = -1
    # volume calc type altitude to location.
    eCrdnVolumeCalcTypeAltitude = 0
    # volume calc type angle to location.
    eCrdnVolumeCalcTypeAngleOffVector = 1
    # volume calc type File.
    eCrdnVolumeCalcTypeFile = 2
    # volume calc type scalar at location.
    eCrdnVolumeCalcTypeFromScalar = 3
    # volume calc type Solar Intensity.
    eCrdnVolumeCalcTypeSolarIntensity = 4
    # volume calc type Spatial Condition Satisfaction Metric.
    eCrdnVolumeCalcTypeVolumeSatisfactionMetric = 5
    # volume calc type Distance to Location.
    eCrdnVolumeCalcTypeRange = 6
    # volume calc type Propagation Delay to Location.
    eCrdnVolumeCalcTypeDelayRange = 7

AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeUnknown.__doc__ = "Unknown or unsupported volume calc."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAltitude.__doc__ = "volume calc type altitude to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAngleOffVector.__doc__ = "volume calc type angle to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFile.__doc__ = "volume calc type File."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFromScalar.__doc__ = "volume calc type scalar at location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeSolarIntensity.__doc__ = "volume calc type Solar Intensity."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeVolumeSatisfactionMetric.__doc__ = "volume calc type Spatial Condition Satisfaction Metric."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeRange.__doc__ = "volume calc type Distance to Location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeDelayRange.__doc__ = "volume calc type Propagation Delay to Location."

agcls.AgTypeNameMap["AgECrdnVolumeCalcType"] = AgECrdnVolumeCalcType

class AgECrdnVolumeCalcVolumeSatisfactionAccumulationType(IntEnum):
    """Defines volume calc spatial condition accumulation types."""
    # Volume calc spatial condition satisfaction accumulation type up to current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime = -1
    # Volume calc spatial condition satisfaction accumulation type current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime = 0
    # Volume calc spatial condition satisfaction accumulation type from current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime = 1
    # Volume calc spatial condition satisfaction accumulation type total.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal = 10

AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type up to current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type from current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal.__doc__ = "Volume calc spatial condition satisfaction accumulation type total."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionAccumulationType"] = AgECrdnVolumeCalcVolumeSatisfactionAccumulationType

class AgECrdnVolumeCalcVolumeSatisfactionDurationType(IntEnum):
    """Defines volume calc spatial condition duration types."""
    # Volume calc spatial condition satisfaction duration type minimum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMin = -1
    # Volume calc spatial condition satisfaction duration type sum.
    eCrdnVolumeCalcVolumeSatisfactionDurationSum = 0
    # Volume calc spatial condition satisfaction duration type maximum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMax = 1

AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMin.__doc__ = "Volume calc spatial condition satisfaction duration type minimum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationSum.__doc__ = "Volume calc spatial condition satisfaction duration type sum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMax.__doc__ = "Volume calc spatial condition satisfaction duration type maximum."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionDurationType"] = AgECrdnVolumeCalcVolumeSatisfactionDurationType

class AgECrdnVolumeCalcVolumeSatisfactionFilterType(IntEnum):
    """Defines volume calc spatial condition filter types."""
    # Volume calc spatial condition satisfaction filter type first intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals = -10
    # Volume calc spatial condition satisfaction filter type last intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals = -20
    # Volume calc spatial condition satisfaction filter type none.
    eCrdnVolumeCalcVolumeSatisfactionFilterNone = 0
    # Volume calc spatial condition satisfaction filter type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration = 1
    # Volume calc spatial condition satisfaction filter type interval duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration = 2

AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type first intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type last intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterNone.__doc__ = "Volume calc spatial condition satisfaction filter type none."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration.__doc__ = "Volume calc spatial condition satisfaction filter type gap duration."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction filter type interval duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionFilterType"] = AgECrdnVolumeCalcVolumeSatisfactionFilterType

class AgECrdnVolumeCalcVolumeSatisfactionMetricType(IntEnum):
    """Defines volume calc spatial condition satisfaction metric types."""
    # Volume calc spatial condition satisfaction metric type number of gaps.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps = -2
    # Volume calc spatial condition satisfaction metric type number of intervals.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals = -1
    # Volume calc spatial condition satisfaction metric type time since last satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction = 1
    # Volume calc spatial condition satisfaction metric type time until next satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction = 2
    # Volume calc spatial condition satisfaction metric type interbnal duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration = 10
    # Volume calc spatial condition satisfaction metric type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration = 20

AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps.__doc__ = "Volume calc spatial condition satisfaction metric type number of gaps."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals.__doc__ = "Volume calc spatial condition satisfaction metric type number of intervals."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time since last satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time until next satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction metric type interbnal duration."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration.__doc__ = "Volume calc spatial condition satisfaction metric type gap duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionMetricType"] = AgECrdnVolumeCalcVolumeSatisfactionMetricType

class AgECrdnVolumeGridType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume grid.
    eCrdnVolumeGridTypeUnknown = -1
    # volume grid type cartesian.
    eCrdnVolumeGridTypeCartesian = 0
    # volume grid type Cylindrical.
    eCrdnVolumeGridTypeCylindrical = 1
    # volume grid type Spherical.
    eCrdnVolumeGridTypeSpherical = 2
    # volume grid type Constrained.
    eCrdnVolumeGridTypeConstrained = 3
    # volume grid type LatLonAlt (Cartographic).
    eCrdnVolumeGridTypeLatLonAlt = 4
    # volume grid type BearingAlt (Surface Bearing).
    eCrdnVolumeGridTypeBearingAlt = 5

AgECrdnVolumeGridType.eCrdnVolumeGridTypeUnknown.__doc__ = "Unknown or unsupported volume grid."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCartesian.__doc__ = "volume grid type cartesian."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCylindrical.__doc__ = "volume grid type Cylindrical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeSpherical.__doc__ = "volume grid type Spherical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeConstrained.__doc__ = "volume grid type Constrained."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeLatLonAlt.__doc__ = "volume grid type LatLonAlt (Cartographic)."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeBearingAlt.__doc__ = "volume grid type BearingAlt (Surface Bearing)."

agcls.AgTypeNameMap["AgECrdnVolumeGridType"] = AgECrdnVolumeGridType

class AgECrdnVolumeResultVectorRequest(IntEnum):
    """Defines volume result vector request types."""
    # volume result vector request pos type
    eCrdnVolumeResultVectorRequestPos = 1
    # volume result vector request native pos type
    eCrdnVolumeResultVectorRequestNativePos = 2
    # volume result vector request metric type
    eCrdnVolumeResultVectorRequestMetric = 16
    # volume result vector request satisfaction type
    eCrdnVolumeResultVectorRequestSatisfaction = 32
    # volume result vector request gradient type
    eCrdnVolumeResultVectorRequestGradient = 256

AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestPos.__doc__ = "volume result vector request pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestNativePos.__doc__ = "volume result vector request native pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestMetric.__doc__ = "volume result vector request metric type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestSatisfaction.__doc__ = "volume result vector request satisfaction type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestGradient.__doc__ = "volume result vector request gradient type"

agcls.AgTypeNameMap["AgECrdnVolumeResultVectorRequest"] = AgECrdnVolumeResultVectorRequest

class AgECrdnVolumeType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume.
    eCrdnVolumeTypeUnknown = -1
    # volume type combined.
    eCrdnVolumeTypeCombined = 0
    # volume type lighting.
    eCrdnVolumeTypeLighting = 1
    # volume type over time.
    eCrdnVolumeTypeOverTime = 2
    # volume type from grid (Grid Bounding Volume).
    eCrdnVolumeTypeFromGrid = 3
    # volume type from calc (Spatial Calculation Bounds).
    eCrdnVolumeTypeFromCalc = 4
    # volume type from time satisfaction (Valid Time At Location).
    eCrdnVolumeTypeFromTimeSatisfaction = 5
    # volume type from condition (Condition At Location).
    eCrdnVolumeTypeFromCondition = 6
    # volume type Inview (Access To Location).
    eCrdnVolumeTypeInview = 7

AgECrdnVolumeType.eCrdnVolumeTypeUnknown.__doc__ = "Unknown or unsupported volume."
AgECrdnVolumeType.eCrdnVolumeTypeCombined.__doc__ = "volume type combined."
AgECrdnVolumeType.eCrdnVolumeTypeLighting.__doc__ = "volume type lighting."
AgECrdnVolumeType.eCrdnVolumeTypeOverTime.__doc__ = "volume type over time."
AgECrdnVolumeType.eCrdnVolumeTypeFromGrid.__doc__ = "volume type from grid (Grid Bounding Volume)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCalc.__doc__ = "volume type from calc (Spatial Calculation Bounds)."
AgECrdnVolumeType.eCrdnVolumeTypeFromTimeSatisfaction.__doc__ = "volume type from time satisfaction (Valid Time At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCondition.__doc__ = "volume type from condition (Condition At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeInview.__doc__ = "volume type Inview (Access To Location)."

agcls.AgTypeNameMap["AgECrdnVolumeType"] = AgECrdnVolumeType

class AgECrdnVolumeAberrationType(IntEnum):
    """Defines the model of aberration to use."""
    # Aberration type unknown.
    eCrdnVolumeAberrationUnknown = -1
    # Aberration type total.
    eCrdnVolumeAberrationTotal = 0
    # SAberration type annual.
    eCrdnVolumeAberrationAnnual = 1
    # Aberration type none.
    eCrdnVolumeAberrationNone = 2

AgECrdnVolumeAberrationType.eCrdnVolumeAberrationUnknown.__doc__ = "Aberration type unknown."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationTotal.__doc__ = "Aberration type total."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationAnnual.__doc__ = "SAberration type annual."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationNone.__doc__ = "Aberration type none."

agcls.AgTypeNameMap["AgECrdnVolumeAberrationType"] = AgECrdnVolumeAberrationType

class AgECrdnVolumeClockHostType(IntEnum):
    """Defines whether base or target of an Access instance holds the clock for Access times."""
    # Unknown
    eCrdnVolumeClockHostUnknown = -1
    # Base object holds time instance.
    eCrdnVolumeClockHostBase = 0
    # Target object holds time instance.
    eCrdnVolumeClockHostTarget = 1

AgECrdnVolumeClockHostType.eCrdnVolumeClockHostUnknown.__doc__ = "Unknown"
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostBase.__doc__ = "Base object holds time instance."
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostTarget.__doc__ = "Target object holds time instance."

agcls.AgTypeNameMap["AgECrdnVolumeClockHostType"] = AgECrdnVolumeClockHostType

class AgECrdnVolumeCombinedOperationType(IntEnum):
    """Defines spatial condition combined operation types."""
    # Spatial condition combined AND operation.
    eCrdnVolumeCombinedOperationTypeAND = 1
    # Spatial condition combined OR operation.
    eCrdnVolumeCombinedOperationTypeOR = 2
    # Spatial condition combined XOR operation.
    eCrdnVolumeCombinedOperationTypeXOR = 3
    # Spatial condition combined MINUS operation.
    eCrdnVolumeCombinedOperationTypeMINUS = 4

AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeAND.__doc__ = "Spatial condition combined AND operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeOR.__doc__ = "Spatial condition combined OR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeXOR.__doc__ = "Spatial condition combined XOR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeMINUS.__doc__ = "Spatial condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnVolumeCombinedOperationType"] = AgECrdnVolumeCombinedOperationType

class AgECrdnVolumeFromGridEdgeType(IntEnum):
    """Defines spatial condition from grid edge type."""
    # Spatial condition over time from grid edge type mask points.
    eCrdnVolumeFromGridEdgeTypeMaskPoints = 16
    # Spatial condition over time from grid edge type mask voxels.
    eCrdnVolumeFromGridEdgeTypeMaskVoxels = 32

AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskPoints.__doc__ = "Spatial condition over time from grid edge type mask points."
AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskVoxels.__doc__ = "Spatial condition over time from grid edge type mask voxels."

agcls.AgTypeNameMap["AgECrdnVolumeFromGridEdgeType"] = AgECrdnVolumeFromGridEdgeType

class AgECrdnVolumeLightingConditionsType(IntFlag):
    """Defines spatial condition lighting conditions types."""
    # Spatial condition lighting undefined.
    eCrdnVolumeLightingConditionTypeUndefined = 0
    # Spatial condition lighting sun light.
    eCrdnVolumeLightingConditionTypeSunlight = 1
    # Spatial condition lighting penumbra.
    eCrdnVolumeLightingConditionTypePenumbra = 2
    # Spatial condition lighting umbra.
    eCrdnVolumeLightingConditionTypeUmbra = 4

AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUndefined.__doc__ = "Spatial condition lighting undefined."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeSunlight.__doc__ = "Spatial condition lighting sun light."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypePenumbra.__doc__ = "Spatial condition lighting penumbra."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUmbra.__doc__ = "Spatial condition lighting umbra."

agcls.AgTypeNameMap["AgECrdnVolumeLightingConditionsType"] = AgECrdnVolumeLightingConditionsType

class AgECrdnVolumeOverTimeDurationType(IntEnum):
    """Defines spatial condition over time duration type."""
    # Spatial condition over time duration type Static.
    eCrdnVolumeOverTimeDurationTypeStatic = 0
    # Spatial condition over time duration type CumulativeToCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent = 1
    # Spatial condition over time duration type CumulativeFromCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent = 2
    # Spatial condition over time duration type SlidingWindow.
    eCrdnVolumeOverTimeDurationTypeSlidingWindow = 3

AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeStatic.__doc__ = "Spatial condition over time duration type Static."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent.__doc__ = "Spatial condition over time duration type CumulativeToCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent.__doc__ = "Spatial condition over time duration type CumulativeFromCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeSlidingWindow.__doc__ = "Spatial condition over time duration type SlidingWindow."

agcls.AgTypeNameMap["AgECrdnVolumeOverTimeDurationType"] = AgECrdnVolumeOverTimeDurationType

class AgECrdnVolumeTimeSenseType(IntEnum):
    """Defines whether object1 or object2 of an Access instance holds the clock for Access times."""
    # Unklnown
    eCrdnVolumeTimeSenseUnknown = -1
    # Position is computed in Time Sense
    eCrdnVolumeTimeSenseTransmit = 0
    # Position is computed in Receive Sense
    eCrdnVolumeTimeSenseReceive = 1

AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseUnknown.__doc__ = "Unklnown"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseTransmit.__doc__ = "Position is computed in Time Sense"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseReceive.__doc__ = "Position is computed in Receive Sense"

agcls.AgTypeNameMap["AgECrdnVolumeTimeSenseType"] = AgECrdnVolumeTimeSenseType

class AgECrdnVolumetricGridValuesMethodType(IntEnum):
    """Defines volumetric grid values method types."""
    # Unknown or unsupportedgrid values method.
    eCrdnVolumetricGridValuesMethodMethodUnknown = -1
    # Fixed number steps grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedNumSteps = 0
    # Fixed step size grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedStepSize = 1
    # Custom grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodCustomValues = 2

AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodUnknown.__doc__ = "Unknown or unsupportedgrid values method."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedNumSteps.__doc__ = "Fixed number steps grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedStepSize.__doc__ = "Fixed step size grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodCustomValues.__doc__ = "Custom grid values method for volumetric grid."

agcls.AgTypeNameMap["AgECrdnVolumetricGridValuesMethodType"] = AgECrdnVolumetricGridValuesMethodType

class AgECrdnKind(IntEnum):
    """Represents kinds of vectory geometry components."""
    # Unsupported component kind.
    eCrdnKindUnknown = -1
    # Invalid component.
    eCrdnKindInvalid = 0
    # Axes component.
    eCrdnKindAxes = 1
    # Angle component.
    eCrdnKindAngle = 2
    # Vector component.
    eCrdnKindVector = 3
    # Point component.
    eCrdnKindPoint = 4
    # Plane component.
    eCrdnKindPlane = 5
    # System component.
    eCrdnKindSystem = 6
    # An event.
    eCrdnKindEvent = 7
    # An event array.
    eCrdnKindEventArray = 8
    # An event interval.
    eCrdnKindEventInterval = 9
    # An event interval collection.
    eCrdnKindEventIntervalCollection = 10
    # A list of event intervals.
    eCrdnKindEventIntervalList = 11
    # A parameter set.
    eCrdnKindParameterSet = 12
    # A scalar.
    eCrdnKindCalcScalar = 13
    # A condition.
    eCrdnKindCondition = 14
    # A condition set.
    eCrdnKindConditionSet = 15
    # A volume grid.
    eCrdnKindVolumeGrid = 16
    # A volume.
    eCrdnKindVolume = 17
    # A volume calc.
    eCrdnKindVolumeCalc = 18

AgECrdnKind.eCrdnKindUnknown.__doc__ = "Unsupported component kind."
AgECrdnKind.eCrdnKindInvalid.__doc__ = "Invalid component."
AgECrdnKind.eCrdnKindAxes.__doc__ = "Axes component."
AgECrdnKind.eCrdnKindAngle.__doc__ = "Angle component."
AgECrdnKind.eCrdnKindVector.__doc__ = "Vector component."
AgECrdnKind.eCrdnKindPoint.__doc__ = "Point component."
AgECrdnKind.eCrdnKindPlane.__doc__ = "Plane component."
AgECrdnKind.eCrdnKindSystem.__doc__ = "System component."
AgECrdnKind.eCrdnKindEvent.__doc__ = "An event."
AgECrdnKind.eCrdnKindEventArray.__doc__ = "An event array."
AgECrdnKind.eCrdnKindEventInterval.__doc__ = "An event interval."
AgECrdnKind.eCrdnKindEventIntervalCollection.__doc__ = "An event interval collection."
AgECrdnKind.eCrdnKindEventIntervalList.__doc__ = "A list of event intervals."
AgECrdnKind.eCrdnKindParameterSet.__doc__ = "A parameter set."
AgECrdnKind.eCrdnKindCalcScalar.__doc__ = "A scalar."
AgECrdnKind.eCrdnKindCondition.__doc__ = "A condition."
AgECrdnKind.eCrdnKindConditionSet.__doc__ = "A condition set."
AgECrdnKind.eCrdnKindVolumeGrid.__doc__ = "A volume grid."
AgECrdnKind.eCrdnKindVolume.__doc__ = "A volume."
AgECrdnKind.eCrdnKindVolumeCalc.__doc__ = "A volume calc."

agcls.AgTypeNameMap["AgECrdnKind"] = AgECrdnKind

class AgECrdnAngleType(IntEnum):
    """Represents angle types."""
    # Unknown or unsupported type.
    eCrdnAngleTypeUnknown = -1
    # An angle between two vectors.
    eCrdnAngleTypeBetweenVectors = 0
    # An angle between two planes.
    eCrdnAngleTypeBetweenPlanes = 1
    # An angle between two vectors about an axis.
    eCrdnAngleTypeDihedralAngle = 2
    # Angle of the shortest rotation between the two specified axes.
    eCrdnAngleTypeRotation = 3
    # An angle between a vector and a plane.
    eCrdnAngleTypeToPlane = 4
    # Represents a VGT angle created from a template. This type of angle is not creatable.
    eCrdnAngleTypeTemplate = 5

AgECrdnAngleType.eCrdnAngleTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAngleType.eCrdnAngleTypeBetweenVectors.__doc__ = "An angle between two vectors."
AgECrdnAngleType.eCrdnAngleTypeBetweenPlanes.__doc__ = "An angle between two planes."
AgECrdnAngleType.eCrdnAngleTypeDihedralAngle.__doc__ = "An angle between two vectors about an axis."
AgECrdnAngleType.eCrdnAngleTypeRotation.__doc__ = "Angle of the shortest rotation between the two specified axes."
AgECrdnAngleType.eCrdnAngleTypeToPlane.__doc__ = "An angle between a vector and a plane."
AgECrdnAngleType.eCrdnAngleTypeTemplate.__doc__ = "Represents a VGT angle created from a template. This type of angle is not creatable."

agcls.AgTypeNameMap["AgECrdnAngleType"] = AgECrdnAngleType

class AgECrdnAxesType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported type.
    eCrdnAxesTypeUnknown = -1
    # Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type.
    eCrdnAxesTypeLagrangeLibration = 0
    # Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset.
    eCrdnAxesTypeAngularOffset = 1
    # Axes based on another set fixed at a specified epoch.
    eCrdnAxesTypeFixedAtEpoch = 2
    # B-Plane axes using the selected target body and reference vector.
    eCrdnAxesTypeBPlane = 3
    # Customized axes offset with respect to a set of reference Axes.
    eCrdnAxesTypeCustomScript = 4
    # Axes fixed in reference axes.
    eCrdnAxesTypeFixed = 6
    # Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference.
    eCrdnAxesTypeAlignedAndConstrained = 7
    # Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element.
    eCrdnAxesTypeModelAttachment = 8
    # Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset.
    eCrdnAxesTypeSpinning = 9
    # Projection of the reference point onto the central body.
    eCrdnAxesTypeOnSurface = 10
    # Axes based on trajectory of the point relative to the reference coordinate system.
    eCrdnAxesTypeTrajectory = 11
    # Represents a VGT axes created from a template. This type of axes is not creatable.
    eCrdnAxesTypeTemplate = 12
    # Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant.
    eCrdnAxesTypeAtTimeInstant = 13
    # An axes plugin point.
    eCrdnAxesTypePlugin = 14
    # Axes specified by data from a file.
    eCrdnAxesTypeFile = 5

AgECrdnAxesType.eCrdnAxesTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAxesType.eCrdnAxesTypeLagrangeLibration.__doc__ = "Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."
AgECrdnAxesType.eCrdnAxesTypeAngularOffset.__doc__ = "Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeFixedAtEpoch.__doc__ = "Axes based on another set fixed at a specified epoch."
AgECrdnAxesType.eCrdnAxesTypeBPlane.__doc__ = "B-Plane axes using the selected target body and reference vector."
AgECrdnAxesType.eCrdnAxesTypeCustomScript.__doc__ = "Customized axes offset with respect to a set of reference Axes."
AgECrdnAxesType.eCrdnAxesTypeFixed.__doc__ = "Axes fixed in reference axes."
AgECrdnAxesType.eCrdnAxesTypeAlignedAndConstrained.__doc__ = "Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."
AgECrdnAxesType.eCrdnAxesTypeModelAttachment.__doc__ = "Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."
AgECrdnAxesType.eCrdnAxesTypeSpinning.__doc__ = "Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeOnSurface.__doc__ = "Projection of the reference point onto the central body."
AgECrdnAxesType.eCrdnAxesTypeTrajectory.__doc__ = "Axes based on trajectory of the point relative to the reference coordinate system."
AgECrdnAxesType.eCrdnAxesTypeTemplate.__doc__ = "Represents a VGT axes created from a template. This type of axes is not creatable."
AgECrdnAxesType.eCrdnAxesTypeAtTimeInstant.__doc__ = "Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."
AgECrdnAxesType.eCrdnAxesTypePlugin.__doc__ = "An axes plugin point."
AgECrdnAxesType.eCrdnAxesTypeFile.__doc__ = "Axes specified by data from a file."

agcls.AgTypeNameMap["AgECrdnAxesType"] = AgECrdnAxesType

class AgECrdnPlaneType(IntEnum):
    """Represents plane types."""
    # Unknown or unsupported type.
    eCrdnPlaneTypeUnknown = -1
    # A plane normal to a vector at a given point.
    eCrdnPlaneTypeNormal = 0
    # A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system.
    eCrdnPlaneTypeQuadrant = 1
    # A plane is defined on the basis of a trajectory of a selected point with respect to a reference point.
    eCrdnPlaneTypeTrajectory = 2
    # A plane is defined by the three points.
    eCrdnPlaneTypeTriad = 3
    # Represents a VGT plane created from a template. This type of plane is not creatable.
    eCrdnPlaneTypeTemplate = 4
    # A plane passing through point and containing two given vectors.
    eCrdnPlaneTypeTwoVector = 5

AgECrdnPlaneType.eCrdnPlaneTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPlaneType.eCrdnPlaneTypeNormal.__doc__ = "A plane normal to a vector at a given point."
AgECrdnPlaneType.eCrdnPlaneTypeQuadrant.__doc__ = "A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."
AgECrdnPlaneType.eCrdnPlaneTypeTrajectory.__doc__ = "A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."
AgECrdnPlaneType.eCrdnPlaneTypeTriad.__doc__ = "A plane is defined by the three points."
AgECrdnPlaneType.eCrdnPlaneTypeTemplate.__doc__ = "Represents a VGT plane created from a template. This type of plane is not creatable."
AgECrdnPlaneType.eCrdnPlaneTypeTwoVector.__doc__ = "A plane passing through point and containing two given vectors."

agcls.AgTypeNameMap["AgECrdnPlaneType"] = AgECrdnPlaneType

class AgECrdnPointType(IntEnum):
    """Represents point types."""
    # Unknown or unsupported type.
    eCrdnPointTypeUnknown = -1
    # B-Plane point using the selected target body.
    eCrdnPointTypeBPlane = 0
    # The grazing point is the point of closest approach to the surface of the selected central body along a defined direction.
    eCrdnPointTypeGrazing = 1
    # The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option.
    eCrdnPointTypeCovarianceGrazing = 2
    # Point fixed in a reference coordinate system.
    eCrdnPointTypeFixedInSystem = 4
    # Point on central body surface that reflects from source to observer.
    eCrdnPointTypeGlint = 5
    # Point on a plane located along a given direction looking from a given origin.
    eCrdnPointTypePlaneIntersection = 6
    # Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point.
    eCrdnPointTypeModelAttachment = 7
    # The projection of a point onto a reference plane.
    eCrdnPointTypePlaneProjection = 8
    # The detic subpoint of the reference point as projected onto the central body.
    eCrdnPointTypeOnSurface = 9
    # Libration point using one primary and multiple secondary central bodies.
    eCrdnPointTypeLagrangeLibration = 10
    # Represents a VGT point created from a template. This type of point is not creatable.
    eCrdnPointTypeTemplate = 11
    # Point on central body surface along direction vector originating at source point.
    eCrdnPointTypeCentralBodyIntersect = 12
    # Point fixed relative to reference system based on another point evaluated at specified time instant.
    eCrdnPointTypeAtTimeInstant = 13
    # A point plugin point.
    eCrdnPointTypePlugin = 14
    # Point specified by data from a file.
    eCrdnPointTypeFile = 3
    # Point fixed on a central body.
    eCrdnPointTypeFixedOnCentralBody = 15
    # A point placed at the center of mass of a specified satellite of the satellite collection.
    eCrdnPointTypeSatelliteCollectionEntry = 16

AgECrdnPointType.eCrdnPointTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPointType.eCrdnPointTypeBPlane.__doc__ = "B-Plane point using the selected target body."
AgECrdnPointType.eCrdnPointTypeGrazing.__doc__ = "The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."
AgECrdnPointType.eCrdnPointTypeCovarianceGrazing.__doc__ = "The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."
AgECrdnPointType.eCrdnPointTypeFixedInSystem.__doc__ = "Point fixed in a reference coordinate system."
AgECrdnPointType.eCrdnPointTypeGlint.__doc__ = "Point on central body surface that reflects from source to observer."
AgECrdnPointType.eCrdnPointTypePlaneIntersection.__doc__ = "Point on a plane located along a given direction looking from a given origin."
AgECrdnPointType.eCrdnPointTypeModelAttachment.__doc__ = "Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."
AgECrdnPointType.eCrdnPointTypePlaneProjection.__doc__ = "The projection of a point onto a reference plane."
AgECrdnPointType.eCrdnPointTypeOnSurface.__doc__ = "The detic subpoint of the reference point as projected onto the central body."
AgECrdnPointType.eCrdnPointTypeLagrangeLibration.__doc__ = "Libration point using one primary and multiple secondary central bodies."
AgECrdnPointType.eCrdnPointTypeTemplate.__doc__ = "Represents a VGT point created from a template. This type of point is not creatable."
AgECrdnPointType.eCrdnPointTypeCentralBodyIntersect.__doc__ = "Point on central body surface along direction vector originating at source point."
AgECrdnPointType.eCrdnPointTypeAtTimeInstant.__doc__ = "Point fixed relative to reference system based on another point evaluated at specified time instant."
AgECrdnPointType.eCrdnPointTypePlugin.__doc__ = "A point plugin point."
AgECrdnPointType.eCrdnPointTypeFile.__doc__ = "Point specified by data from a file."
AgECrdnPointType.eCrdnPointTypeFixedOnCentralBody.__doc__ = "Point fixed on a central body."
AgECrdnPointType.eCrdnPointTypeSatelliteCollectionEntry.__doc__ = "A point placed at the center of mass of a specified satellite of the satellite collection."

agcls.AgTypeNameMap["AgECrdnPointType"] = AgECrdnPointType

class AgECrdnSystemType(IntEnum):
    """Represents system types."""
    # Unknown or unsupported system type.
    eCrdnSystemTypeUnknown = -1
    # A system assembled from an origin point and a set of reference axes.
    eCrdnSystemTypeAssembled = 0
    # A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle.
    eCrdnSystemTypeOnSurface = 1
    # Represents a VGT system created from a template. This type of system is not creatable.
    eCrdnSystemTypeTemplate = 2

AgECrdnSystemType.eCrdnSystemTypeUnknown.__doc__ = "Unknown or unsupported system type."
AgECrdnSystemType.eCrdnSystemTypeAssembled.__doc__ = "A system assembled from an origin point and a set of reference axes."
AgECrdnSystemType.eCrdnSystemTypeOnSurface.__doc__ = "A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."
AgECrdnSystemType.eCrdnSystemTypeTemplate.__doc__ = "Represents a VGT system created from a template. This type of system is not creatable."

agcls.AgTypeNameMap["AgECrdnSystemType"] = AgECrdnSystemType

class AgECrdnVectorType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported vector type.
    eCrdnVectorTypeUnknown = -1
    # Vector defined by its start and end points.
    eCrdnVectorTypeDisplacement = 0
    # Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeApoapsis = 1
    # Based on another vector fixed at a specified epoch.
    eCrdnVectorTypeFixedAtEpoch = 2
    # Angular velocity vector of one set of axes computed with respect to the reference set.
    eCrdnVectorTypeAngularVelocity = 3
    # Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode.
    eCrdnVectorTypeConing = 4
    # The vector cross product of two vectors.
    eCrdnVectorTypeCrossProduct = 5
    # Customized vector components defined with respect to reference axes.
    eCrdnVectorTypeCustomScript = 6
    # Derivative of a vector computed with respect to specified axes.
    eCrdnVectorTypeDerivative = 7
    # Angle rate vector perpendicular to the plane in which the angle is defined.
    eCrdnVectorTypeAngleRate = 8
    # Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeEccentricity = 9
    # Vector fixed in reference axes.
    eCrdnVectorTypeFixedInAxes = 10
    # Defined along the intersection of two planes.
    eCrdnVectorTypeTwoPlanesIntersection = 12
    # Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body.
    eCrdnVectorTypeLineOfNodes = 13
    # Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element.
    eCrdnVectorTypeModelAttachment = 14
    # Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitAngularMomentum = 15
    # Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitNormal = 16
    # Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypePeriapsis = 17
    # A projection of a vector computed with respect to a reference plane.
    eCrdnVectorTypeProjection = 18
    # Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane.
    eCrdnVectorTypeReflection = 19
    # Scaled version of the input vector.
    eCrdnVectorTypeScaled = 20
    # Defined with respect to a star object.
    eCrdnVectorTypeDirectionToStar = 21
    # Represents a VGT vector created from a template. This type of vector is not creatable.
    eCrdnVectorTypeTemplate = 22
    # Vector fixed relative to reference axes based on another vector evaluated at specified time instant.
    eCrdnVectorTypeAtTimeInstant = 23
    # Linear combination of two input vectors.
    eCrdnVectorTypeLinearCombination = 24
    # A projection of a source vector in the direction of another vector.
    eCrdnVectorTypeProjectAlong = 25
    # Linear combination of two input vectors using scalars.
    eCrdnVectorTypeScalarLinearCombination = 26
    # Scaled version of the input vector using scalar.
    eCrdnVectorTypeScalarScaled = 27
    # Velocity vector of a point in a coordinate system.
    eCrdnVectorTypeVelocity = 28
    # A vector plugin point.
    eCrdnVectorTypePlugin = 29
    # Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis.
    eCrdnVectorTypeRotationVector = 30
    # Displacement between origin and destination points using surface distance and altitude difference.
    eCrdnVectorTypeDisplacementOnSurface = 31

AgECrdnVectorType.eCrdnVectorTypeUnknown.__doc__ = "Unknown or unsupported vector type."
AgECrdnVectorType.eCrdnVectorTypeDisplacement.__doc__ = "Vector defined by its start and end points."
AgECrdnVectorType.eCrdnVectorTypeApoapsis.__doc__ = "Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedAtEpoch.__doc__ = "Based on another vector fixed at a specified epoch."
AgECrdnVectorType.eCrdnVectorTypeAngularVelocity.__doc__ = "Angular velocity vector of one set of axes computed with respect to the reference set."
AgECrdnVectorType.eCrdnVectorTypeConing.__doc__ = "Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."
AgECrdnVectorType.eCrdnVectorTypeCrossProduct.__doc__ = "The vector cross product of two vectors."
AgECrdnVectorType.eCrdnVectorTypeCustomScript.__doc__ = "Customized vector components defined with respect to reference axes."
AgECrdnVectorType.eCrdnVectorTypeDerivative.__doc__ = "Derivative of a vector computed with respect to specified axes."
AgECrdnVectorType.eCrdnVectorTypeAngleRate.__doc__ = "Angle rate vector perpendicular to the plane in which the angle is defined."
AgECrdnVectorType.eCrdnVectorTypeEccentricity.__doc__ = "Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedInAxes.__doc__ = "Vector fixed in reference axes."
AgECrdnVectorType.eCrdnVectorTypeTwoPlanesIntersection.__doc__ = "Defined along the intersection of two planes."
AgECrdnVectorType.eCrdnVectorTypeLineOfNodes.__doc__ = "Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeModelAttachment.__doc__ = "Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."
AgECrdnVectorType.eCrdnVectorTypeOrbitAngularMomentum.__doc__ = "Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeOrbitNormal.__doc__ = "Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypePeriapsis.__doc__ = "Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeProjection.__doc__ = "A projection of a vector computed with respect to a reference plane."
AgECrdnVectorType.eCrdnVectorTypeReflection.__doc__ = "Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."
AgECrdnVectorType.eCrdnVectorTypeScaled.__doc__ = "Scaled version of the input vector."
AgECrdnVectorType.eCrdnVectorTypeDirectionToStar.__doc__ = "Defined with respect to a star object."
AgECrdnVectorType.eCrdnVectorTypeTemplate.__doc__ = "Represents a VGT vector created from a template. This type of vector is not creatable."
AgECrdnVectorType.eCrdnVectorTypeAtTimeInstant.__doc__ = "Vector fixed relative to reference axes based on another vector evaluated at specified time instant."
AgECrdnVectorType.eCrdnVectorTypeLinearCombination.__doc__ = "Linear combination of two input vectors."
AgECrdnVectorType.eCrdnVectorTypeProjectAlong.__doc__ = "A projection of a source vector in the direction of another vector."
AgECrdnVectorType.eCrdnVectorTypeScalarLinearCombination.__doc__ = "Linear combination of two input vectors using scalars."
AgECrdnVectorType.eCrdnVectorTypeScalarScaled.__doc__ = "Scaled version of the input vector using scalar."
AgECrdnVectorType.eCrdnVectorTypeVelocity.__doc__ = "Velocity vector of a point in a coordinate system."
AgECrdnVectorType.eCrdnVectorTypePlugin.__doc__ = "A vector plugin point."
AgECrdnVectorType.eCrdnVectorTypeRotationVector.__doc__ = "Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."
AgECrdnVectorType.eCrdnVectorTypeDisplacementOnSurface.__doc__ = "Displacement between origin and destination points using surface distance and altitude difference."

agcls.AgTypeNameMap["AgECrdnVectorType"] = AgECrdnVectorType

class AgECrdnMeanElementTheory(IntEnum):
    """Mean element theory types for approximating motion."""
    # Osculating elements (six standard Keplerian orbital elements).
    eCrdnMeanElementTheoryOsculating = 1
    # The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377.
    eCrdnMeanElementTheoryKozai = 2
    # Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2.
    eCrdnMeanElementTheoryBrouwerLyddane_Long = 3
    # Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term.
    eCrdnMeanElementTheoryBrouwerLyddane_Short = 4

AgECrdnMeanElementTheory.eCrdnMeanElementTheoryOsculating.__doc__ = "Osculating elements (six standard Keplerian orbital elements)."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryKozai.__doc__ = "The Kozai-Iszak (KI) mean elements are based upon the paper ``The Motion of a Close earth satellite,`` Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Long.__doc__ = "Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Short.__doc__ = "Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."

agcls.AgTypeNameMap["AgECrdnMeanElementTheory"] = AgECrdnMeanElementTheory

class AgECrdnDirectionType(IntEnum):
    """Direction options."""
    # Incoming direction.
    eCrdnDirectionIncomingAsymptote = 1
    # Outgoing direction.
    eCrdnDirectionOutgoingAsymptote = 2

AgECrdnDirectionType.eCrdnDirectionIncomingAsymptote.__doc__ = "Incoming direction."
AgECrdnDirectionType.eCrdnDirectionOutgoingAsymptote.__doc__ = "Outgoing direction."

agcls.AgTypeNameMap["AgECrdnDirectionType"] = AgECrdnDirectionType

class AgECrdnLagrangeLibrationPointType(IntEnum):
    """Types of the Lagrange points, also known as libration points. Lagrange points are points in space where gravitational forces and the orbital motion of a body balance each other."""
    # A point between the Sun and Earth.
    eCrdnLagrangeLibrationPointTypeL1 = 1
    # Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth.
    eCrdnLagrangeLibrationPointTypeL2 = 2
    # L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times.
    eCrdnLagrangeLibrationPointTypeL3 = 3
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL4 = 4
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL5 = 5

AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL1.__doc__ = "A point between the Sun and Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL2.__doc__ = "Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL3.__doc__ = "L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL4.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL5.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."

agcls.AgTypeNameMap["AgECrdnLagrangeLibrationPointType"] = AgECrdnLagrangeLibrationPointType

class AgECrdnQuadrantType(IntEnum):
    """Quadrants from a reference system (e.g., XY, XZ, YZ, YX, ZX, ZY),"""
    # XY quadrant.
    eCrdnQuadrantXY = 1
    # YX quadrant.
    eCrdnQuadrantYX = 2
    # XZ quadrant.
    eCrdnQuadrantXZ = 3
    # ZX quadrant.
    eCrdnQuadrantZX = 4
    # YZ quadrant.
    eCrdnQuadrantYZ = 5
    # ZY quadrant.
    eCrdnQuadrantZY = 6

AgECrdnQuadrantType.eCrdnQuadrantXY.__doc__ = "XY quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYX.__doc__ = "YX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantXZ.__doc__ = "XZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZX.__doc__ = "ZX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYZ.__doc__ = "YZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZY.__doc__ = "ZY quadrant."

agcls.AgTypeNameMap["AgECrdnQuadrantType"] = AgECrdnQuadrantType

class AgECrdnTrajectoryAxesType(IntEnum):
    """Trajectory axes coordinate types."""
    # Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack).
    eCrdnTrajectoryAxesICR = 0
    # Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal).
    eCrdnTrajectoryAxesVNC = 1
    # Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack).
    eCrdnTrajectoryAxesRIC = 2
    # Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal).
    eCrdnTrajectoryAxesLVLH = 3
    # Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity).
    eCrdnTrajectoryAxesVVLH = 4
    # Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesBBR = 5
    # Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesEquinoctial = 6
    # Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal).
    eCrdnTrajectoryAxesNTC = 7

AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesICR.__doc__ = "Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVNC.__doc__ = "Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesRIC.__doc__ = "Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesLVLH.__doc__ = "Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVVLH.__doc__ = "Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesBBR.__doc__ = "Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesEquinoctial.__doc__ = "Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesNTC.__doc__ = "Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."

agcls.AgTypeNameMap["AgECrdnTrajectoryAxesType"] = AgECrdnTrajectoryAxesType

class AgECrdnDisplayAxisSelector(IntEnum):
    """Rotation directions."""
    # Rotate about Axis X.
    eCrdnDisplayAxisX = 0
    # Rotate about Axis Y.
    eCrdnDisplayAxisY = 1
    # Rotate about Axis Z.
    eCrdnDisplayAxisZ = 2

AgECrdnDisplayAxisSelector.eCrdnDisplayAxisX.__doc__ = "Rotate about Axis X."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisY.__doc__ = "Rotate about Axis Y."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisZ.__doc__ = "Rotate about Axis Z."

agcls.AgTypeNameMap["AgECrdnDisplayAxisSelector"] = AgECrdnDisplayAxisSelector

class AgECrdnSignedAngleType(IntEnum):
    """Defines options for computing an angle."""
    # Choose the option to use unsigned angle.
    eCrdnSignedAngleNone = 0
    # Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAnglePositive = 1
    # Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAngleNegative = 2

AgECrdnSignedAngleType.eCrdnSignedAngleNone.__doc__ = "Choose the option to use unsigned angle."
AgECrdnSignedAngleType.eCrdnSignedAnglePositive.__doc__ = "Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."
AgECrdnSignedAngleType.eCrdnSignedAngleNegative.__doc__ = "Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."

agcls.AgTypeNameMap["AgECrdnSignedAngleType"] = AgECrdnSignedAngleType

class AgECrdnPointBPlaneType(IntEnum):
    """B-Plane point types."""
    # Asymptote.
    eCrdnPointBPlaneAsymptote = 1
    # Two body.
    eCrdnPointBPlaneATwoBody = 2

AgECrdnPointBPlaneType.eCrdnPointBPlaneAsymptote.__doc__ = "Asymptote."
AgECrdnPointBPlaneType.eCrdnPointBPlaneATwoBody.__doc__ = "Two body."

agcls.AgTypeNameMap["AgECrdnPointBPlaneType"] = AgECrdnPointBPlaneType

class AgECrdnReferenceShapeType(IntEnum):
    """Surface shape types."""
    # An ellipsoid reference shape as defined by the central body (by default, it is WSG84).
    eCrdnReferenceShapeEllipsoid = 1
    # Terrain as the terrain reference.
    eCrdnReferenceShapeTerrain = 2
    # Mean Sea Level as the terrain reference.
    eCrdnReferenceShapeMSL = 3

AgECrdnReferenceShapeType.eCrdnReferenceShapeEllipsoid.__doc__ = "An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."
AgECrdnReferenceShapeType.eCrdnReferenceShapeTerrain.__doc__ = "Terrain as the terrain reference."
AgECrdnReferenceShapeType.eCrdnReferenceShapeMSL.__doc__ = "Mean Sea Level as the terrain reference."

agcls.AgTypeNameMap["AgECrdnReferenceShapeType"] = AgECrdnReferenceShapeType

class AgECrdnSurfaceType(IntEnum):
    """Surface types."""
    # Detic surface model.
    eCrdnSurfaceDetic = 1
    # Centric surface model.
    eCrdnSurfaceCentric = 2

AgECrdnSurfaceType.eCrdnSurfaceDetic.__doc__ = "Detic surface model."
AgECrdnSurfaceType.eCrdnSurfaceCentric.__doc__ = "Centric surface model."

agcls.AgTypeNameMap["AgECrdnSurfaceType"] = AgECrdnSurfaceType

class AgECrdnSweepMode(IntEnum):
    """The rotation sweeping modes."""
    # Bidirectional sweeping mode.
    eCrdnSweepModeBidirectional = 1
    # Unidirectional sweeping mode.
    eCrdnSweepModeUnidirectional = 2

AgECrdnSweepMode.eCrdnSweepModeBidirectional.__doc__ = "Bidirectional sweeping mode."
AgECrdnSweepMode.eCrdnSweepModeUnidirectional.__doc__ = "Unidirectional sweeping mode."

agcls.AgTypeNameMap["AgECrdnSweepMode"] = AgECrdnSweepMode

class AgECrdnSignalSense(IntEnum):
    """Signal sense transmission options."""
    # Signal receive.
    eCrdnSignalSenseReceive = 1
    # Signal transmit.
    eCrdnSignalSenseTransmit = 2

AgECrdnSignalSense.eCrdnSignalSenseReceive.__doc__ = "Signal receive."
AgECrdnSignalSense.eCrdnSignalSenseTransmit.__doc__ = "Signal transmit."

agcls.AgTypeNameMap["AgECrdnSignalSense"] = AgECrdnSignalSense

class AgECrdnIntersectionSurface(IntEnum):
    """Intersection surface flags."""
    # Intersection with central body ellipsoid.
    eCrdnIntersectionSurfaceAtCentralBodyEllipsoid = 0
    # Intersection at altitude.
    eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid = 1
    # Use terrain as intersection surface.
    eCrdnIntersectionSurfaceAtTerrain = 2

AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtCentralBodyEllipsoid.__doc__ = "Intersection with central body ellipsoid."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid.__doc__ = "Intersection at altitude."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtTerrain.__doc__ = "Use terrain as intersection surface."

agcls.AgTypeNameMap["AgECrdnIntersectionSurface"] = AgECrdnIntersectionSurface

class AgECrdnVectorScaledDimensionInheritance(IntEnum):
    """Dimension inheritance constants used to configure the dimension inheritance of a vector scaled by a scalar."""
    # Do not inherit dimension.
    eCrdnVectorScaledDimensionInheritanceNone = 0
    # Inherit dimension from scalar.
    eCrdnVectorScaledDimensionInheritanceFromScalar = 1
    # Inherit dimension from vector.
    eCrdnVectorScaledDimensionInheritanceFromVector = 2

AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromScalar.__doc__ = "Inherit dimension from scalar."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromVector.__doc__ = "Inherit dimension from vector."

agcls.AgTypeNameMap["AgECrdnVectorScaledDimensionInheritance"] = AgECrdnVectorScaledDimensionInheritance


class IAgCrdnIntervalCollection(object):
    """The interface represents a collection of intervals."""
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{DAE5D702-43F1-4544-8039-97E746D019AB}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_Count" : 1,
                             "Item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnIntervalCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnIntervalCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalCollection.__dict__ and type(IAgCrdnIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnIntervalCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(IAgCrdnIntervalCollection._metadata, IAgCrdnIntervalCollection._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, index:int) -> "IAgCrdnInterval":
        """Returns an interval at a specified index."""
        return self._intf.invoke(IAgCrdnIntervalCollection._metadata, IAgCrdnIntervalCollection._Item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator"""
        return self._intf.get_property(IAgCrdnIntervalCollection._metadata, IAgCrdnIntervalCollection._get__NewEnum_metadata)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DAE5D702-43F1-4544-8039-97E746D019AB}", IAgCrdnIntervalCollection)
agcls.AgTypeNameMap["IAgCrdnIntervalCollection"] = IAgCrdnIntervalCollection

class IAgCrdnInterval(object):
    """The interface represents an interval."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4A5031BC-45C0-4E75-9190-31F1802C173D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Start" : 1,
                             "get_Stop" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnInterval._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnInterval from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInterval.__dict__ and type(IAgCrdnInterval.__dict__[attrname]) == property:
            return IAgCrdnInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnInterval.")
    
    _get_Start_metadata = { "name" : "Start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Start(self) -> typing.Any:
        """The interval's start time."""
        return self._intf.get_property(IAgCrdnInterval._metadata, IAgCrdnInterval._get_Start_metadata)

    _get_Stop_metadata = { "name" : "Stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Stop(self) -> typing.Any:
        """The interval's stop time."""
        return self._intf.get_property(IAgCrdnInterval._metadata, IAgCrdnInterval._get_Stop_metadata)


agcls.AgClassCatalog.add_catalog_entry("{4A5031BC-45C0-4E75-9190-31F1802C173D}", IAgCrdnInterval)
agcls.AgTypeNameMap["IAgCrdnInterval"] = IAgCrdnInterval

class IAgCrdnPoint(object):
    """The interface defines methods and properties common to all points."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{086D1AA7-D85D-402D-9347-0B51EB552537}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "LocateInSystemWithRate" : 2,
                             "LocateInSystem" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPoint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPoint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPoint.__dict__ and type(IAgCrdnPoint.__dict__[attrname]) == property:
            return IAgCrdnPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPoint.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPointType),) }
    @property
    def Type(self) -> "AgECrdnPointType":
        """Returns a type of the point object."""
        return self._intf.get_property(IAgCrdnPoint._metadata, IAgCrdnPoint._get_Type_metadata)

    _LocateInSystemWithRate_metadata = { "name" : "LocateInSystemWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.AgInterface_out_arg,) }
    def LocateInSystemWithRate(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPointLocateInSystemWithRateResult":
        """Locates the point's position and velocity in a specified coordinate system."""
        return self._intf.invoke(IAgCrdnPoint._metadata, IAgCrdnPoint._LocateInSystemWithRate_metadata, epoch, system, out_arg())

    _LocateInSystem_metadata = { "name" : "LocateInSystem",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.AgInterface_out_arg,) }
    def LocateInSystem(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPointLocateInSystemResult":
        """Locates the point's position in a specified coordinate system."""
        return self._intf.invoke(IAgCrdnPoint._metadata, IAgCrdnPoint._LocateInSystem_metadata, epoch, system, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{086D1AA7-D85D-402D-9347-0B51EB552537}", IAgCrdnPoint)
agcls.AgTypeNameMap["IAgCrdnPoint"] = IAgCrdnPoint

class IAgCrdnVector(object):
    """The interface defines methods and properties common to all vectors."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "FindInAxes" : 2,
                             "FindInAxesWithRate" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVector.__dict__ and type(IAgCrdnVector.__dict__[attrname]) == property:
            return IAgCrdnVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVector.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVectorType),) }
    @property
    def Type(self) -> "AgECrdnVectorType":
        """Returns a type of the vector object."""
        return self._intf.get_property(IAgCrdnVector._metadata, IAgCrdnVector._get_Type_metadata)

    _FindInAxes_metadata = { "name" : "FindInAxes",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindInAxes(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnVectorFindInAxesResult":
        """Computes the vector in the specified axes."""
        return self._intf.invoke(IAgCrdnVector._metadata, IAgCrdnVector._FindInAxes_metadata, epoch, axes, out_arg())

    _FindInAxesWithRate_metadata = { "name" : "FindInAxesWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnVectorFindInAxesWithRateResult":
        """Computes the vector and its rate in the specified axes."""
        return self._intf.invoke(IAgCrdnVector._metadata, IAgCrdnVector._FindInAxesWithRate_metadata, epoch, axes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}", IAgCrdnVector)
agcls.AgTypeNameMap["IAgCrdnVector"] = IAgCrdnVector

class IAgCrdnSystem(object):
    """The interface contains methods and properties shared by all VGT systems."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{14687421-5E90-4275-9DE5-21295EC14F65}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "FindInSystem" : 2,
                             "Transform" : 3,
                             "TransformWithRate" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystem._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystem from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystem.__dict__ and type(IAgCrdnSystem.__dict__[attrname]) == property:
            return IAgCrdnSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystem.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSystemType),) }
    @property
    def Type(self) -> "AgECrdnSystemType":
        """Returns a type of the system object."""
        return self._intf.get_property(IAgCrdnSystem._metadata, IAgCrdnSystem._get_Type_metadata)

    _FindInSystem_metadata = { "name" : "FindInSystem",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.AgInterface_out_arg,) }
    def FindInSystem(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnSystemFindInSystemResult":
        """Find position, velocity, rate and orientation using the specified system."""
        return self._intf.invoke(IAgCrdnSystem._metadata, IAgCrdnSystem._FindInSystem_metadata, epoch, system, out_arg())

    _Transform_metadata = { "name" : "Transform",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.AgInterface_in_arg("IAgCartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def Transform(self, epoch:typing.Any, outputSystem:"IAgCrdnSystem", positionInMySystem:"IAgCartesian3Vector") -> "IAgCrdnSystemTransformResult":
        """Translates the position vector from this system into the output system."""
        return self._intf.invoke(IAgCrdnSystem._metadata, IAgCrdnSystem._Transform_metadata, epoch, outputSystem, positionInMySystem, out_arg())

    _TransformWithRate_metadata = { "name" : "TransformWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.AgInterface_in_arg("IAgCartesian3Vector"), agmarshall.AgInterface_in_arg("IAgCartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def TransformWithRate(self, epoch:typing.Any, outputSystem:"IAgCrdnSystem", positionInMySystem:"IAgCartesian3Vector", velocityInMySystem:"IAgCartesian3Vector") -> "IAgCrdnSystemTransformWithRateResult":
        """Translates the position and rate vectors from this system into the output system."""
        return self._intf.invoke(IAgCrdnSystem._metadata, IAgCrdnSystem._TransformWithRate_metadata, epoch, outputSystem, positionInMySystem, velocityInMySystem, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{14687421-5E90-4275-9DE5-21295EC14F65}", IAgCrdnSystem)
agcls.AgTypeNameMap["IAgCrdnSystem"] = IAgCrdnSystem

class IAgCrdnAxes(object):
    """The interface defines methods and properties common to all axes."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EE2FCF98-9315-406A-835C-40C56428C888}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "FindInAxesWithRate" : 2,
                             "FindInAxes" : 3,
                             "get_Labels" : 4,
                             "get_X" : 5,
                             "get_Y" : 6,
                             "get_Z" : 7,
                             "Transform" : 8,
                             "TransformWithRate" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxes.__dict__ and type(IAgCrdnAxes.__dict__[attrname]) == property:
            return IAgCrdnAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxes.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnAxesType),) }
    @property
    def Type(self) -> "AgECrdnAxesType":
        """Returns a type of the axes object."""
        return self._intf.get_property(IAgCrdnAxes._metadata, IAgCrdnAxes._get_Type_metadata)

    _FindInAxesWithRate_metadata = { "name" : "FindInAxesWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAxesFindInAxesWithRateResult":
        """Find an angular velocity and orientation in the specified axes."""
        return self._intf.invoke(IAgCrdnAxes._metadata, IAgCrdnAxes._FindInAxesWithRate_metadata, epoch, axes, out_arg())

    _FindInAxes_metadata = { "name" : "FindInAxes",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindInAxes(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAxesFindInAxesResult":
        """Find an orientation in the specified axes."""
        return self._intf.invoke(IAgCrdnAxes._metadata, IAgCrdnAxes._FindInAxes_metadata, epoch, axes, out_arg())

    _get_Labels_metadata = { "name" : "Labels",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Labels(self) -> "IAgCrdnAxesLabels":
        """Returns an object that allows modifying the axes labels."""
        return self._intf.get_property(IAgCrdnAxes._metadata, IAgCrdnAxes._get_Labels_metadata)

    _get_X_metadata = { "name" : "X",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def X(self) -> "IAgCrdnVector":
        """Returns the X axis of the component."""
        return self._intf.get_property(IAgCrdnAxes._metadata, IAgCrdnAxes._get_X_metadata)

    _get_Y_metadata = { "name" : "Y",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Y(self) -> "IAgCrdnVector":
        """Returns the Y axis of the component."""
        return self._intf.get_property(IAgCrdnAxes._metadata, IAgCrdnAxes._get_Y_metadata)

    _get_Z_metadata = { "name" : "Z",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Z(self) -> "IAgCrdnVector":
        """Returns the Z axis of the component."""
        return self._intf.get_property(IAgCrdnAxes._metadata, IAgCrdnAxes._get_Z_metadata)

    _Transform_metadata = { "name" : "Transform",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_in_arg("IAgCartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def Transform(self, epoch:typing.Any, outputAxes:"IAgCrdnAxes", vectorInMyAxes:"IAgCartesian3Vector") -> "IAgCrdnAxesTransformResult":
        """Transforms the input vector from this axes into the output axes."""
        return self._intf.invoke(IAgCrdnAxes._metadata, IAgCrdnAxes._Transform_metadata, epoch, outputAxes, vectorInMyAxes, out_arg())

    _TransformWithRate_metadata = { "name" : "TransformWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_in_arg("IAgCartesian3Vector"), agmarshall.AgInterface_in_arg("IAgCartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def TransformWithRate(self, epoch:typing.Any, outputAxes:"IAgCrdnAxes", vectorInMyAxes:"IAgCartesian3Vector", rateInMyAxes:"IAgCartesian3Vector") -> "IAgCrdnAxesTransformWithRateResult":
        """Transforms the input vector and vector's rate from this axes into the output axes."""
        return self._intf.invoke(IAgCrdnAxes._metadata, IAgCrdnAxes._TransformWithRate_metadata, epoch, outputAxes, vectorInMyAxes, rateInMyAxes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{EE2FCF98-9315-406A-835C-40C56428C888}", IAgCrdnAxes)
agcls.AgTypeNameMap["IAgCrdnAxes"] = IAgCrdnAxes

class IAgCrdnAngle(object):
    """The interface defines methods and properties common to all angles."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "FindAngle" : 2,
                             "FindAngleWithRate" : 3,
                             "FindCoordinates" : 4,
                             "FindCoordinatesWithRate" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngle._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngle from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngle.__dict__ and type(IAgCrdnAngle.__dict__[attrname]) == property:
            return IAgCrdnAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngle.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnAngleType),) }
    @property
    def Type(self) -> "AgECrdnAngleType":
        """Returns a type of the angle object."""
        return self._intf.get_property(IAgCrdnAngle._metadata, IAgCrdnAngle._get_Type_metadata)

    _FindAngle_metadata = { "name" : "FindAngle",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def FindAngle(self, epoch:typing.Any) -> "IAgCrdnAngleFindAngleResult":
        """Finds an angle at the specified epoch."""
        return self._intf.invoke(IAgCrdnAngle._metadata, IAgCrdnAngle._FindAngle_metadata, epoch, out_arg())

    _FindAngleWithRate_metadata = { "name" : "FindAngleWithRate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def FindAngleWithRate(self, epoch:typing.Any) -> "IAgCrdnAngleFindAngleWithRateResult":
        """Finds an angle and angle rate."""
        return self._intf.invoke(IAgCrdnAngle._metadata, IAgCrdnAngle._FindAngleWithRate_metadata, epoch, out_arg())

    _FindCoordinates_metadata = { "name" : "FindCoordinates",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindCoordinates(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAngleFindResult":
        """Finds the angle value and three vectors that define the angle in a specified input axes."""
        return self._intf.invoke(IAgCrdnAngle._metadata, IAgCrdnAngle._FindCoordinates_metadata, epoch, axes, out_arg())

    _FindCoordinatesWithRate_metadata = { "name" : "FindCoordinatesWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindCoordinatesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAngleFindWithRateResult":
        """Finds the angle value, the angle rate and three vectors that define the angle in a specified input axes."""
        return self._intf.invoke(IAgCrdnAngle._metadata, IAgCrdnAngle._FindCoordinatesWithRate_metadata, epoch, axes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}", IAgCrdnAngle)
agcls.AgTypeNameMap["IAgCrdnAngle"] = IAgCrdnAngle

class IAgCrdnPlane(object):
    """The interface defines methods and properties common to all VGT planes."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "FindInAxes" : 2,
                             "FindInAxesWithRate" : 3,
                             "FindInSystem" : 4,
                             "FindInSystemWithRate" : 5,
                             "get_Labels" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlane._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlane from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlane.__dict__ and type(IAgCrdnPlane.__dict__[attrname]) == property:
            return IAgCrdnPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlane.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPlaneType),) }
    @property
    def Type(self) -> "AgECrdnPlaneType":
        """Returns a type of the plane object."""
        return self._intf.get_property(IAgCrdnPlane._metadata, IAgCrdnPlane._get_Type_metadata)

    _FindInAxes_metadata = { "name" : "FindInAxes",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindInAxes(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnPlaneFindInAxesResult":
        """Computes the plane's axes vectors in a specified reference axes."""
        return self._intf.invoke(IAgCrdnPlane._metadata, IAgCrdnPlane._FindInAxes_metadata, epoch, axes, out_arg())

    _FindInAxesWithRate_metadata = { "name" : "FindInAxesWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnPlaneFindInAxesWithRateResult":
        """Computes the plane's axes vectors and their rates in a specified reference axes."""
        return self._intf.invoke(IAgCrdnPlane._metadata, IAgCrdnPlane._FindInAxesWithRate_metadata, epoch, axes, out_arg())

    _FindInSystem_metadata = { "name" : "FindInSystem",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.AgInterface_out_arg,) }
    def FindInSystem(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPlaneFindInSystemResult":
        """Computes the position and X and Y axes in the specified coordinate system."""
        return self._intf.invoke(IAgCrdnPlane._metadata, IAgCrdnPlane._FindInSystem_metadata, epoch, system, out_arg())

    _FindInSystemWithRate_metadata = { "name" : "FindInSystemWithRate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.AgInterface_out_arg,) }
    def FindInSystemWithRate(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPlaneFindInSystemWithRateResult":
        """Computes the position, X and Y axes and their rates of change in the specified coordinate system."""
        return self._intf.invoke(IAgCrdnPlane._metadata, IAgCrdnPlane._FindInSystemWithRate_metadata, epoch, system, out_arg())

    _get_Labels_metadata = { "name" : "Labels",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Labels(self) -> "IAgCrdnPlaneLabels":
        """Allows configuring the plane's X and Y axes labels."""
        return self._intf.get_property(IAgCrdnPlane._metadata, IAgCrdnPlane._get_Labels_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}", IAgCrdnPlane)
agcls.AgTypeNameMap["IAgCrdnPlane"] = IAgCrdnPlane

class IAgCrdnContext(object):
    """The interface represents a context associated with a VGT component. All VGT components are associated with a valid context. A context can represent a VGT instance or a VGT template."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1003D700-A64E-438C-954A-AD3AA9EA9773}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsTemplate" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnContext._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnContext from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnContext.__dict__ and type(IAgCrdnContext.__dict__[attrname]) == property:
            return IAgCrdnContext.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnContext.")
    
    _get_IsTemplate_metadata = { "name" : "IsTemplate",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsTemplate(self) -> bool:
        """Returns whether the current instance is a VGT template."""
        return self._intf.get_property(IAgCrdnContext._metadata, IAgCrdnContext._get_IsTemplate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1003D700-A64E-438C-954A-AD3AA9EA9773}", IAgCrdnContext)
agcls.AgTypeNameMap["IAgCrdnContext"] = IAgCrdnContext

class IAgCrdn(object):
    """A base interface implemented by all VGT components. The methods and properties of the interface provide type information about the VGT component."""
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Kind" : 1,
                             "get_Category" : 2,
                             "set_Category" : 3,
                             "get_Name" : 4,
                             "get_Description" : 5,
                             "get_Path" : 6,
                             "get_IsDuplicable" : 7,
                             "get_Context" : 8,
                             "get_TypeInfo" : 9,
                             "get_QualifiedPath" : 10,
                             "get_IsValid" : 11,
                             "get_IsReady" : 12,
                             "get_IsReadOnly" : 13,
                             "Duplicate" : 14,
                             "AnonymousDuplicate" : 15,
                             "DependsOn" : 16,
                             "get_EmbeddedComponents" : 17,
                             "Export" : 18,
                             "Rename" : 19, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdn._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdn from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdn.__dict__ and type(IAgCrdn.__dict__[attrname]) == property:
            return IAgCrdn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdn.")
    
    _get_Kind_metadata = { "name" : "Kind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnKind),) }
    @property
    def Kind(self) -> "AgECrdnKind":
        """Returns the component kind."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_Kind_metadata)

    _get_Category_metadata = { "name" : "Category",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Category(self) -> str:
        """Allows the user to access or change the component category (Folder)."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_Category_metadata)

    _set_Category_metadata = { "name" : "Category",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Category.setter
    def Category(self, category:str) -> None:
        return self._intf.set_property(IAgCrdn._metadata, IAgCrdn._set_Category_metadata, category)

    _get_Name_metadata = { "name" : "Name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Name(self) -> str:
        """Returns the component name."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_Name_metadata)

    _get_Description_metadata = { "name" : "Description",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Description(self) -> str:
        """Returns the component description."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_Description_metadata)

    _get_Path_metadata = { "name" : "Path",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Path(self) -> str:
        """Returns the component's fully qualified path (ie. ``CentralBody/Earth Body``, etc.)."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_Path_metadata)

    _get_IsDuplicable_metadata = { "name" : "IsDuplicable",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsDuplicable(self) -> bool:
        """Returns whether the VGT component can be duplicated."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_IsDuplicable_metadata)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns the context object associated with the instance. The returned object is either an instance of IAgCrdnInstance or IAgCrdnTemplate interface."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_Context_metadata)

    _get_TypeInfo_metadata = { "name" : "TypeInfo",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TypeInfo(self) -> "IAgCrdnTypeInfo":
        """Returns the component type information."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_TypeInfo_metadata)

    _get_QualifiedPath_metadata = { "name" : "QualifiedPath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def QualifiedPath(self) -> str:
        """An STK-conformant path to the VGT component that can be used to visualize the VGT components in 3D (i.e. ``CentralBody/Earth Body Vector``, etc.)."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_QualifiedPath_metadata)

    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Returns whether the component is valid."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_IsValid_metadata)

    _get_IsReady_metadata = { "name" : "IsReady",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsReady(self) -> bool:
        """Returns whether the component is ready. The component is ready if it's been fully initialized."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_IsReady_metadata)

    _get_IsReadOnly_metadata = { "name" : "IsReadOnly",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsReadOnly(self) -> bool:
        """Returns whether the component is modifiable."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_IsReadOnly_metadata)

    _Duplicate_metadata = { "name" : "Duplicate",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def Duplicate(self, newName:str, description:str) -> "IAgCrdn":
        """Creates a copy of the instance of a VGT component. The new component is automatically registered and will be persisted or restored when a scenario is saved or loaded."""
        return self._intf.invoke(IAgCrdn._metadata, IAgCrdn._Duplicate_metadata, newName, description, out_arg())

    _AnonymousDuplicate_metadata = { "name" : "AnonymousDuplicate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def AnonymousDuplicate(self) -> "IAgCrdn":
        """Creates an anonymous copy of the instance of a VGT component. The new component is not registered and will not be persisted nor restored when a scenario is saved or loaded."""
        return self._intf.invoke(IAgCrdn._metadata, IAgCrdn._AnonymousDuplicate_metadata, out_arg())

    _DependsOn_metadata = { "name" : "DependsOn",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdn"), agmarshall.VARIANT_BOOL_arg,) }
    def DependsOn(self, component:"IAgCrdn") -> bool:
        """Tests if the instance depends on another component."""
        return self._intf.invoke(IAgCrdn._metadata, IAgCrdn._DependsOn_metadata, component, out_arg())

    _get_EmbeddedComponents_metadata = { "name" : "EmbeddedComponents",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def EmbeddedComponents(self) -> "IAgCrdnCollection":
        """Returns a collection of embedded components."""
        return self._intf.get_property(IAgCrdn._metadata, IAgCrdn._get_EmbeddedComponents_metadata)

    _Export_metadata = { "name" : "Export",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def Export(self, filename:str, comments:str) -> None:
        """Exports the component to a file."""
        return self._intf.invoke(IAgCrdn._metadata, IAgCrdn._Export_metadata, filename, comments)

    _Rename_metadata = { "name" : "Rename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Rename(self, newName:str) -> None:
        """Renames the component."""
        return self._intf.invoke(IAgCrdn._metadata, IAgCrdn._Rename_metadata, newName)


agcls.AgClassCatalog.add_catalog_entry("{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}", IAgCrdn)
agcls.AgTypeNameMap["IAgCrdn"] = IAgCrdn

class IAgCrdnEvaluateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Value" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEvaluateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEvaluateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEvaluateResult.__dict__ and type(IAgCrdnEvaluateResult.__dict__[attrname]) == property:
            return IAgCrdnEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEvaluateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnEvaluateResult._metadata, IAgCrdnEvaluateResult._get_IsValid_metadata)

    _get_Value_metadata = { "name" : "Value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Value(self) -> float:
        """The scalar value."""
        return self._intf.get_property(IAgCrdnEvaluateResult._metadata, IAgCrdnEvaluateResult._get_Value_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}", IAgCrdnEvaluateResult)
agcls.AgTypeNameMap["IAgCrdnEvaluateResult"] = IAgCrdnEvaluateResult

class IAgCrdnEvaluateWithRateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E9B2DA30-1317-43E2-8D47-9D675A28F748}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Value" : 2,
                             "get_Rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEvaluateWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEvaluateWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEvaluateWithRateResult.__dict__ and type(IAgCrdnEvaluateWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEvaluateWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnEvaluateWithRateResult._metadata, IAgCrdnEvaluateWithRateResult._get_IsValid_metadata)

    _get_Value_metadata = { "name" : "Value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Value(self) -> float:
        """Computed scalar value."""
        return self._intf.get_property(IAgCrdnEvaluateWithRateResult._metadata, IAgCrdnEvaluateWithRateResult._get_Value_metadata)

    _get_Rate_metadata = { "name" : "Rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Rate(self) -> float:
        """A rate of change of the computed scalar value."""
        return self._intf.get_property(IAgCrdnEvaluateWithRateResult._metadata, IAgCrdnEvaluateWithRateResult._get_Rate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{E9B2DA30-1317-43E2-8D47-9D675A28F748}", IAgCrdnEvaluateWithRateResult)
agcls.AgTypeNameMap["IAgCrdnEvaluateWithRateResult"] = IAgCrdnEvaluateWithRateResult

class IAgCrdnEventIntervalResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Interval" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalResult.__dict__ and type(IAgCrdnEventIntervalResult.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnEventIntervalResult._metadata, IAgCrdnEventIntervalResult._get_IsValid_metadata)

    _get_Interval_metadata = { "name" : "Interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Interval(self) -> "IAgCrdnInterval":
        """An interval."""
        return self._intf.get_property(IAgCrdnEventIntervalResult._metadata, IAgCrdnEventIntervalResult._get_Interval_metadata)


agcls.AgClassCatalog.add_catalog_entry("{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}", IAgCrdnEventIntervalResult)
agcls.AgTypeNameMap["IAgCrdnEventIntervalResult"] = IAgCrdnEventIntervalResult

class IAgCrdnEventFindOccurrenceResult(object):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{20F964F0-8466-415E-9344-D6FBA53AF8B0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Epoch" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventFindOccurrenceResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventFindOccurrenceResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventFindOccurrenceResult.__dict__ and type(IAgCrdnEventFindOccurrenceResult.__dict__[attrname]) == property:
            return IAgCrdnEventFindOccurrenceResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventFindOccurrenceResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnEventFindOccurrenceResult._metadata, IAgCrdnEventFindOccurrenceResult._get_IsValid_metadata)

    _get_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Epoch(self) -> typing.Any:
        """The epoch at which the event occurs."""
        return self._intf.get_property(IAgCrdnEventFindOccurrenceResult._metadata, IAgCrdnEventFindOccurrenceResult._get_Epoch_metadata)


agcls.AgClassCatalog.add_catalog_entry("{20F964F0-8466-415E-9344-D6FBA53AF8B0}", IAgCrdnEventFindOccurrenceResult)
agcls.AgTypeNameMap["IAgCrdnEventFindOccurrenceResult"] = IAgCrdnEventFindOccurrenceResult

class IAgCrdnFindTimesResult(object):
    """Returns a collection of intervals and an array of times."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F7B644F0-0728-434D-8C86-C6267B625860}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Intervals" : 2,
                             "get_Start" : 3,
                             "get_Stop" : 4,
                             "get_Times" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnFindTimesResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnFindTimesResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnFindTimesResult.__dict__ and type(IAgCrdnFindTimesResult.__dict__[attrname]) == property:
            return IAgCrdnFindTimesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnFindTimesResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnFindTimesResult._metadata, IAgCrdnFindTimesResult._get_IsValid_metadata)

    _get_Intervals_metadata = { "name" : "Intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Intervals(self) -> "IAgCrdnIntervalCollection":
        """A collection of found intervals."""
        return self._intf.get_property(IAgCrdnFindTimesResult._metadata, IAgCrdnFindTimesResult._get_Intervals_metadata)

    _get_Start_metadata = { "name" : "Start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Start(self) -> typing.Any:
        """The start time of the entire interval span."""
        return self._intf.get_property(IAgCrdnFindTimesResult._metadata, IAgCrdnFindTimesResult._get_Start_metadata)

    _get_Stop_metadata = { "name" : "Stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Stop(self) -> typing.Any:
        """The stop time of the entire interval span."""
        return self._intf.get_property(IAgCrdnFindTimesResult._metadata, IAgCrdnFindTimesResult._get_Stop_metadata)

    _get_Times_metadata = { "name" : "Times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Times(self) -> list:
        """An array of found times."""
        return self._intf.get_property(IAgCrdnFindTimesResult._metadata, IAgCrdnFindTimesResult._get_Times_metadata)


agcls.AgClassCatalog.add_catalog_entry("{F7B644F0-0728-434D-8C86-C6267B625860}", IAgCrdnFindTimesResult)
agcls.AgTypeNameMap["IAgCrdnFindTimesResult"] = IAgCrdnFindTimesResult

class IAgCrdnIntervalsVectorResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{87F76F41-61FB-4DFF-A76E-25270023BE34}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_IntervalCollections" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnIntervalsVectorResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnIntervalsVectorResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalsVectorResult.__dict__ and type(IAgCrdnIntervalsVectorResult.__dict__[attrname]) == property:
            return IAgCrdnIntervalsVectorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnIntervalsVectorResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnIntervalsVectorResult._metadata, IAgCrdnIntervalsVectorResult._get_IsValid_metadata)

    _get_IntervalCollections_metadata = { "name" : "IntervalCollections",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def IntervalCollections(self) -> "IAgCrdnIntervalVectorCollection":
        """A collection of interval collections."""
        return self._intf.get_property(IAgCrdnIntervalsVectorResult._metadata, IAgCrdnIntervalsVectorResult._get_IntervalCollections_metadata)


agcls.AgClassCatalog.add_catalog_entry("{87F76F41-61FB-4DFF-A76E-25270023BE34}", IAgCrdnIntervalsVectorResult)
agcls.AgTypeNameMap["IAgCrdnIntervalsVectorResult"] = IAgCrdnIntervalsVectorResult

class IAgCrdnEventIntervalCollectionOccurredResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A829181E-A9CD-452D-AC81-19C2DA96C490}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Index" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalCollectionOccurredResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalCollectionOccurredResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionOccurredResult.__dict__ and type(IAgCrdnEventIntervalCollectionOccurredResult.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionOccurredResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalCollectionOccurredResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionOccurredResult._metadata, IAgCrdnEventIntervalCollectionOccurredResult._get_IsValid_metadata)

    _get_Index_metadata = { "name" : "Index",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Index(self) -> int:
        """Index of an interval in the collection."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionOccurredResult._metadata, IAgCrdnEventIntervalCollectionOccurredResult._get_Index_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A829181E-A9CD-452D-AC81-19C2DA96C490}", IAgCrdnEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap["IAgCrdnEventIntervalCollectionOccurredResult"] = IAgCrdnEventIntervalCollectionOccurredResult

class IAgCrdnIntervalListResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D0FDA46F-8B86-4052-8EC7-1448284EABCF}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnIntervalListResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnIntervalListResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalListResult.__dict__ and type(IAgCrdnIntervalListResult.__dict__[attrname]) == property:
            return IAgCrdnIntervalListResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnIntervalListResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnIntervalListResult._metadata, IAgCrdnIntervalListResult._get_IsValid_metadata)

    _get_Intervals_metadata = { "name" : "Intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Intervals(self) -> "IAgCrdnIntervalCollection":
        """A list of intervals."""
        return self._intf.get_property(IAgCrdnIntervalListResult._metadata, IAgCrdnIntervalListResult._get_Intervals_metadata)


agcls.AgClassCatalog.add_catalog_entry("{D0FDA46F-8B86-4052-8EC7-1448284EABCF}", IAgCrdnIntervalListResult)
agcls.AgTypeNameMap["IAgCrdnIntervalListResult"] = IAgCrdnIntervalListResult

class IAgCrdnIntervalVectorCollection(object):
    """A collection of interval collections."""
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_Count" : 1,
                             "Item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnIntervalVectorCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnIntervalVectorCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalVectorCollection.__dict__ and type(IAgCrdnIntervalVectorCollection.__dict__[attrname]) == property:
            return IAgCrdnIntervalVectorCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnIntervalVectorCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnIntervalCollection":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(IAgCrdnIntervalVectorCollection._metadata, IAgCrdnIntervalVectorCollection._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, index:int) -> "IAgCrdnIntervalCollection":
        """Accesses an element at the specified position."""
        return self._intf.invoke(IAgCrdnIntervalVectorCollection._metadata, IAgCrdnIntervalVectorCollection._Item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnIntervalVectorCollection._metadata, IAgCrdnIntervalVectorCollection._get__NewEnum_metadata)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}", IAgCrdnIntervalVectorCollection)
agcls.AgTypeNameMap["IAgCrdnIntervalVectorCollection"] = IAgCrdnIntervalVectorCollection

class IAgCrdnEventGroup(object):
    """Access or create VGT events associated with an object."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventGroup.__dict__ and type(IAgCrdnEventGroup.__dict__[attrname]) == property:
            return IAgCrdnEventGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnEvent":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnEventFactory":
        """Returns a Factory object used to create custom events."""
        return self._intf.get_property(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEvent":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnEvent":
        """Retrieves an event from the collection by index."""
        return self._intf.invoke(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnEvent":
        """Retrieves an event from the collection by name."""
        return self._intf.invoke(IAgCrdnEventGroup._metadata, IAgCrdnEventGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}", IAgCrdnEventGroup)
agcls.AgTypeNameMap["IAgCrdnEventGroup"] = IAgCrdnEventGroup

class IAgCrdnEventIntervalGroup(object):
    """Access or create VGT event intervals associated with an object."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalGroup.__dict__ and type(IAgCrdnEventIntervalGroup.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnEventInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventIntervalName:str) -> None:
        """Removes an element by name."""
        return self._intf.invoke(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._Remove_metadata, eventIntervalName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnEventIntervalFactory":
        """Returns a Factory object used to create custom event intervals."""
        return self._intf.get_property(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventInterval":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnEventInterval":
        """Retrieves an event interval from the collection by index."""
        return self._intf.invoke(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnEventInterval":
        """Retrieves an event interval from the collection by name."""
        return self._intf.invoke(IAgCrdnEventIntervalGroup._metadata, IAgCrdnEventIntervalGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}", IAgCrdnEventIntervalGroup)
agcls.AgTypeNameMap["IAgCrdnEventIntervalGroup"] = IAgCrdnEventIntervalGroup

class IAgCrdnEventIntervalListGroup(object):
    """Access or create VGT event interval lists associated with an object."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{E5721039-AE57-448A-9891-048ECB8BDC63}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListGroup.__dict__ and type(IAgCrdnEventIntervalListGroup.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnEventIntervalList":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnEventIntervalListFactory":
        """Returns a factory object used to create custom event interval lists."""
        return self._intf.get_property(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventIntervalList":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnEventIntervalList":
        """Retrieves an event interval list from the collection by index."""
        return self._intf.invoke(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnEventIntervalList":
        """Retrieves an event interval list from the collection by name."""
        return self._intf.invoke(IAgCrdnEventIntervalListGroup._metadata, IAgCrdnEventIntervalListGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{E5721039-AE57-448A-9891-048ECB8BDC63}", IAgCrdnEventIntervalListGroup)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListGroup"] = IAgCrdnEventIntervalListGroup

class IAgCrdnEventArrayGroup(object):
    """Access or create VGT event arrays associated with an object."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{37A14DB3-3A49-4A6B-B238-922B59737548}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayGroup.__dict__ and type(IAgCrdnEventArrayGroup.__dict__[attrname]) == property:
            return IAgCrdnEventArrayGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnEventArray":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnEventArrayFactory":
        """Returns a Factory object used to create event arrays."""
        return self._intf.get_property(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventArray":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnEventArray":
        """Retrieves an event array from the collection by index."""
        return self._intf.invoke(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnEventArray":
        """Retrieves an event array from the collection by name."""
        return self._intf.invoke(IAgCrdnEventArrayGroup._metadata, IAgCrdnEventArrayGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{37A14DB3-3A49-4A6B-B238-922B59737548}", IAgCrdnEventArrayGroup)
agcls.AgTypeNameMap["IAgCrdnEventArrayGroup"] = IAgCrdnEventArrayGroup

class IAgCrdnCalcScalarGroup(object):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarGroup.__dict__ and type(IAgCrdnCalcScalarGroup.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnCalcScalar":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnCalcScalarFactory":
        """Returns a factory object used to create calc scalar components."""
        return self._intf.get_property(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnCalcScalar":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnCalcScalar":
        """Retrieves an element from the collection by index."""
        return self._intf.invoke(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnCalcScalar":
        """Retrieves an element from the collection by name."""
        return self._intf.invoke(IAgCrdnCalcScalarGroup._metadata, IAgCrdnCalcScalarGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}", IAgCrdnCalcScalarGroup)
agcls.AgTypeNameMap["IAgCrdnCalcScalarGroup"] = IAgCrdnCalcScalarGroup

class IAgCrdnEventIntervalCollectionGroup(object):
    """Access or create VGT event interval collections associated with an object."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{0166467D-9328-4E1B-A982-D9B1396A025E}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalCollectionGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalCollectionGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionGroup.__dict__ and type(IAgCrdnEventIntervalCollectionGroup.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalCollectionGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnEventIntervalCollection":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnEventIntervalCollectionFactory":
        """Returns a factory object used to create calc scalar components."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventIntervalCollection":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnEventIntervalCollection":
        """Retrieves an event interval from the collection by index."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnEventIntervalCollection":
        """Retrieves an event interval from the collection by name."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionGroup._metadata, IAgCrdnEventIntervalCollectionGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{0166467D-9328-4E1B-A982-D9B1396A025E}", IAgCrdnEventIntervalCollectionGroup)
agcls.AgTypeNameMap["IAgCrdnEventIntervalCollectionGroup"] = IAgCrdnEventIntervalCollectionGroup

class IAgCrdnParameterSetGroup(object):
    """Access or create VGT parameter sets associated with an object or a central body."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSetGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSetGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetGroup.__dict__ and type(IAgCrdnParameterSetGroup.__dict__[attrname]) == property:
            return IAgCrdnParameterSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSetGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnParameterSet":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnParameterSetFactory":
        """Returns a factory object used to create calc scalar components."""
        return self._intf.get_property(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnParameterSet":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnParameterSet":
        """Retrieves an element from the collection by index."""
        return self._intf.invoke(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnParameterSet":
        """Retrieves an element from the collection by name."""
        return self._intf.invoke(IAgCrdnParameterSetGroup._metadata, IAgCrdnParameterSetGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}", IAgCrdnParameterSetGroup)
agcls.AgTypeNameMap["IAgCrdnParameterSetGroup"] = IAgCrdnParameterSetGroup

class IAgCrdnConditionGroup(object):
    """Access or create VGT conditions associated with an object or a central body."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionGroup.__dict__ and type(IAgCrdnConditionGroup.__dict__[attrname]) == property:
            return IAgCrdnConditionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnCondition":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnConditionFactory":
        """Returns a factory object used to create calc scalar components."""
        return self._intf.get_property(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnCondition":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnCondition":
        """Retrieves a condition from the collection by index."""
        return self._intf.invoke(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnCondition":
        """Retrieves a condition from the collection by name."""
        return self._intf.invoke(IAgCrdnConditionGroup._metadata, IAgCrdnConditionGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}", IAgCrdnConditionGroup)
agcls.AgTypeNameMap["IAgCrdnConditionGroup"] = IAgCrdnConditionGroup

class IAgCrdnConditionSetGroup(object):
    """Allows accessing and creating condition set components."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionSetGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionSetGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetGroup.__dict__ and type(IAgCrdnConditionSetGroup.__dict__[attrname]) == property:
            return IAgCrdnConditionSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionSetGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnConditionSet":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnConditionSetFactory":
        """Returns a factory object used to create condition set components."""
        return self._intf.get_property(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnConditionSet":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnConditionSet":
        """Retrieves a condition set from the collection by index."""
        return self._intf.invoke(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnConditionSet":
        """Retrieves a condition set from the collection by name."""
        return self._intf.invoke(IAgCrdnConditionSetGroup._metadata, IAgCrdnConditionSetGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}", IAgCrdnConditionSetGroup)
agcls.AgTypeNameMap["IAgCrdnConditionSetGroup"] = IAgCrdnConditionSetGroup

class IAgCrdnConditionSetEvaluateResult(object):
    """Represents the results returned by ConditionSet.Evaluate."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Values" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionSetEvaluateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionSetEvaluateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetEvaluateResult.__dict__ and type(IAgCrdnConditionSetEvaluateResult.__dict__[attrname]) == property:
            return IAgCrdnConditionSetEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionSetEvaluateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnConditionSetEvaluateResult._metadata, IAgCrdnConditionSetEvaluateResult._get_IsValid_metadata)

    _get_Values_metadata = { "name" : "Values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Values(self) -> list:
        """Computed values."""
        return self._intf.get_property(IAgCrdnConditionSetEvaluateResult._metadata, IAgCrdnConditionSetEvaluateResult._get_Values_metadata)


agcls.AgClassCatalog.add_catalog_entry("{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}", IAgCrdnConditionSetEvaluateResult)
agcls.AgTypeNameMap["IAgCrdnConditionSetEvaluateResult"] = IAgCrdnConditionSetEvaluateResult

class IAgCrdnConditionSetEvaluateWithRateResult(object):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{39814D49-3CF5-42B0-A46C-766781F45AB7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Values" : 2,
                             "get_Rates" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionSetEvaluateWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionSetEvaluateWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetEvaluateWithRateResult.__dict__ and type(IAgCrdnConditionSetEvaluateWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnConditionSetEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionSetEvaluateWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnConditionSetEvaluateWithRateResult._metadata, IAgCrdnConditionSetEvaluateWithRateResult._get_IsValid_metadata)

    _get_Values_metadata = { "name" : "Values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Values(self) -> list:
        """Computed values."""
        return self._intf.get_property(IAgCrdnConditionSetEvaluateWithRateResult._metadata, IAgCrdnConditionSetEvaluateWithRateResult._get_Values_metadata)

    _get_Rates_metadata = { "name" : "Rates",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Rates(self) -> list:
        """Computed rates."""
        return self._intf.get_property(IAgCrdnConditionSetEvaluateWithRateResult._metadata, IAgCrdnConditionSetEvaluateWithRateResult._get_Rates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{39814D49-3CF5-42B0-A46C-766781F45AB7}", IAgCrdnConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap["IAgCrdnConditionSetEvaluateWithRateResult"] = IAgCrdnConditionSetEvaluateWithRateResult

class IAgCrdnVolumeGridGroup(object):
    """Access or create VGT volume grids associated with an object or a central body."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridGroup.__dict__ and type(IAgCrdnVolumeGridGroup.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnVolumeGrid":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnVolumeGridFactory":
        """Returns a factory object used to create volume grid components."""
        return self._intf.get_property(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVolumeGrid":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnVolumeGrid":
        """Retrieves a volume grid from the collection by index."""
        return self._intf.invoke(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnVolumeGrid":
        """Retrieves a volume grid from the collection by name."""
        return self._intf.invoke(IAgCrdnVolumeGridGroup._metadata, IAgCrdnVolumeGridGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}", IAgCrdnVolumeGridGroup)
agcls.AgTypeNameMap["IAgCrdnVolumeGridGroup"] = IAgCrdnVolumeGridGroup

class IAgCrdnVolumeGroup(object):
    """Access or create spatial conditions associated with a volume grid."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGroup.__dict__ and type(IAgCrdnVolumeGroup.__dict__[attrname]) == property:
            return IAgCrdnVolumeGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnVolume":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnVolumeFactory":
        """Returns a factory object used to create spatial condition components."""
        return self._intf.get_property(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVolume":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnVolume":
        """Retrieves an volume from the collection by index."""
        return self._intf.invoke(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnVolume":
        """Retrieves volume from the collection by name."""
        return self._intf.invoke(IAgCrdnVolumeGroup._metadata, IAgCrdnVolumeGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}", IAgCrdnVolumeGroup)
agcls.AgTypeNameMap["IAgCrdnVolumeGroup"] = IAgCrdnVolumeGroup

class IAgCrdnVolumeCalcGroup(object):
    """Access or create VGT volume calcs associated with an object or a central body."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{02991465-35ec-486a-913d-bf204afc9fb6}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcGroup.__dict__ and type(IAgCrdnVolumeCalcGroup.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnVolumeCalc":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        return self._intf.invoke(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._Remove_metadata, eventName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnVolumeCalcFactory":
        """Returns a factory object used to create volume calc components."""
        return self._intf.get_property(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVolumeCalc":
        """Returns an element by name or at a specified position."""
        return self._intf.invoke(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnVolumeCalc":
        """Retrieves a volume calculation from the collection by index."""
        return self._intf.invoke(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnVolumeCalc":
        """Retrieves a volume calculation from the collection by name."""
        return self._intf.invoke(IAgCrdnVolumeCalcGroup._metadata, IAgCrdnVolumeCalcGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{02991465-35ec-486a-913d-bf204afc9fb6}", IAgCrdnVolumeCalcGroup)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcGroup"] = IAgCrdnVolumeCalcGroup

class IAgCrdnCalcScalar(object):
    """Any scalar calculation that is not constant by construction."""
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{55A75307-E283-4146-A456-732D08E47070}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "Evaluate" : 2,
                             "QuickEvaluate" : 3,
                             "EvaluateWithRate" : 4,
                             "QuickEvaluateWithRate" : 5,
                             "GetAvailability" : 6,
                             "get_UnitOfMeasure" : 7,
                             "QuickEvaluateArray" : 8,
                             "QuickEvaluateWithRateArray" : 9,
                             "QuickEvaluateEventArray" : 10,
                             "QuickEvaluateWithRateEventArray" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalar._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalar from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalar.__dict__ and type(IAgCrdnCalcScalar.__dict__[attrname]) == property:
            return IAgCrdnCalcScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalar.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnCalcScalarType),) }
    @property
    def Type(self) -> "AgECrdnCalcScalarType":
        """Returns the scalar calculation type."""
        return self._intf.get_property(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._get_Type_metadata)

    _Evaluate_metadata = { "name" : "Evaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Evaluate(self, epoch:typing.Any) -> "IAgCrdnEvaluateResult":
        """Evaluates the scalar calculation at the specified time instant."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._Evaluate_metadata, epoch, out_arg())

    _QuickEvaluate_metadata = { "name" : "QuickEvaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def QuickEvaluate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with two elements, the first element being of boolean type indicating whether the computation succeeded, followed by a double-precision value representing..."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._QuickEvaluate_metadata, epoch, out_arg())

    _EvaluateWithRate_metadata = { "name" : "EvaluateWithRate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def EvaluateWithRate(self, epoch:typing.Any) -> "IAgCrdnEvaluateWithRateResult":
        """Evaluates the scalar calculation at the specified time instant. The result is a scalar value and its rate of change."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._EvaluateWithRate_metadata, epoch, out_arg())

    _QuickEvaluateWithRate_metadata = { "name" : "QuickEvaluateWithRate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def QuickEvaluateWithRate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with three elements, the first element being of boolean type indicating whether the computation succeeded, followed by two double-precision values one rep..."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._QuickEvaluateWithRate_metadata, epoch, out_arg())

    _GetAvailability_metadata = { "name" : "GetAvailability",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetAvailability(self) -> "IAgCrdnIntervalCollection":
        """Returns a list of availability intervals."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._GetAvailability_metadata, out_arg())

    _get_UnitOfMeasure_metadata = { "name" : "UnitOfMeasure",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def UnitOfMeasure(self) -> str:
        """Returns calc scalar's unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        return self._intf.get_property(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._get_UnitOfMeasure_metadata)

    _QuickEvaluateArray_metadata = { "name" : "QuickEvaluateArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def QuickEvaluateArray(self, times:list) -> list:
        """Evaluates the scalar calculation, and rate, over an array of times, entered as strings in the Scenario date unit. It returns an array corresponding to the input times..."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._QuickEvaluateArray_metadata, times, out_arg())

    _QuickEvaluateWithRateArray_metadata = { "name" : "QuickEvaluateWithRateArray",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def QuickEvaluateWithRateArray(self, times:list) -> list:
        """Evaluates the scalar calculation over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._QuickEvaluateWithRateArray_metadata, times, out_arg())

    _QuickEvaluateEventArray_metadata = { "name" : "QuickEvaluateEventArray",
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventArray"), agmarshall.LPSAFEARRAY_arg,) }
    def QuickEvaluateEventArray(self, refArray:"IAgCrdnEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._QuickEvaluateEventArray_metadata, refArray, out_arg())

    _QuickEvaluateWithRateEventArray_metadata = { "name" : "QuickEvaluateWithRateEventArray",
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventArray"), agmarshall.LPSAFEARRAY_arg,) }
    def QuickEvaluateWithRateEventArray(self, refArray:"IAgCrdnEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(IAgCrdnCalcScalar._metadata, IAgCrdnCalcScalar._QuickEvaluateWithRateEventArray_metadata, refArray, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{55A75307-E283-4146-A456-732D08E47070}", IAgCrdnCalcScalar)
agcls.AgTypeNameMap["IAgCrdnCalcScalar"] = IAgCrdnCalcScalar

class IAgCrdnCalcScalarAngle(object):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{52FB9533-9332-44D2-92B2-8AA2D8633112}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_InputAngle" : 1,
                             "set_InputAngle" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarAngle._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarAngle from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarAngle.__dict__ and type(IAgCrdnCalcScalarAngle.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarAngle.")
    
    _get_InputAngle_metadata = { "name" : "InputAngle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputAngle(self) -> "IAgCrdnAngle":
        """The input angle, which is a VGT angle component. Note angle computation in VGT may involve more than just angular displacement value: in VGT angles may be drawn in 3D which requires knowledge and evaluation of supporting vectors."""
        return self._intf.get_property(IAgCrdnCalcScalarAngle._metadata, IAgCrdnCalcScalarAngle._get_InputAngle_metadata)

    _set_InputAngle_metadata = { "name" : "InputAngle",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAngle"),) }
    @InputAngle.setter
    def InputAngle(self, inputAngle:"IAgCrdnAngle") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarAngle._metadata, IAgCrdnCalcScalarAngle._set_InputAngle_metadata, inputAngle)


agcls.AgClassCatalog.add_catalog_entry("{52FB9533-9332-44D2-92B2-8AA2D8633112}", IAgCrdnCalcScalarAngle)
agcls.AgTypeNameMap["IAgCrdnCalcScalarAngle"] = IAgCrdnCalcScalarAngle

class IAgCrdnCalcScalarConstant(object):
    """Constant scalar value of specified dimension."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{96A1ABA9-663C-4CCC-A066-0166E285C3C2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Value" : 1,
                             "set_Value" : 2,
                             "get_Dimension" : 3,
                             "set_Dimension" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarConstant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarConstant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarConstant.__dict__ and type(IAgCrdnCalcScalarConstant.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarConstant.")
    
    _get_Value_metadata = { "name" : "Value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Value(self) -> float:
        """A value which can be in any STK supported unit available for selected dimension."""
        return self._intf.get_property(IAgCrdnCalcScalarConstant._metadata, IAgCrdnCalcScalarConstant._get_Value_metadata)

    _set_Value_metadata = { "name" : "Value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Value.setter
    def Value(self, value:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarConstant._metadata, IAgCrdnCalcScalarConstant._set_Value_metadata, value)

    _get_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Dimension(self) -> str:
        """The dimension of the constant value, this can be any of the STK supported dimensions."""
        return self._intf.get_property(IAgCrdnCalcScalarConstant._metadata, IAgCrdnCalcScalarConstant._get_Dimension_metadata)

    _set_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarConstant._metadata, IAgCrdnCalcScalarConstant._set_Dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{96A1ABA9-663C-4CCC-A066-0166E285C3C2}", IAgCrdnCalcScalarConstant)
agcls.AgTypeNameMap["IAgCrdnCalcScalarConstant"] = IAgCrdnCalcScalarConstant

class IAgCrdnCalcScalarCustom(object):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6267B685-4486-4B11-A2CA-056D6A9B558C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Filename" : 1,
                             "set_Filename" : 2,
                             "Reload" : 3,
                             "get_InvalidateOnExecError" : 4,
                             "set_InvalidateOnExecError" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarCustom._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarCustom from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarCustom.__dict__ and type(IAgCrdnCalcScalarCustom.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarCustom.")
    
    _get_Filename_metadata = { "name" : "Filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Filename(self) -> str:
        """A path to MATLAB (.m or .dll), Perl or VBScript file."""
        return self._intf.get_property(IAgCrdnCalcScalarCustom._metadata, IAgCrdnCalcScalarCustom._get_Filename_metadata)

    _set_Filename_metadata = { "name" : "Filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Filename.setter
    def Filename(self, filename:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarCustom._metadata, IAgCrdnCalcScalarCustom._set_Filename_metadata, filename)

    _Reload_metadata = { "name" : "Reload",
            "arg_types" : (),
            "marshallers" : () }
    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        return self._intf.invoke(IAgCrdnCalcScalarCustom._metadata, IAgCrdnCalcScalarCustom._Reload_metadata, )

    _get_InvalidateOnExecError_metadata = { "name" : "InvalidateOnExecError",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def InvalidateOnExecError(self) -> bool:
        """Specifies InvalidOnExecError flag for a custom scalar."""
        return self._intf.get_property(IAgCrdnCalcScalarCustom._metadata, IAgCrdnCalcScalarCustom._get_InvalidateOnExecError_metadata)

    _set_InvalidateOnExecError_metadata = { "name" : "InvalidateOnExecError",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @InvalidateOnExecError.setter
    def InvalidateOnExecError(self, invalidateOnExecError:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarCustom._metadata, IAgCrdnCalcScalarCustom._set_InvalidateOnExecError_metadata, invalidateOnExecError)


agcls.AgClassCatalog.add_catalog_entry("{6267B685-4486-4B11-A2CA-056D6A9B558C}", IAgCrdnCalcScalarCustom)
agcls.AgTypeNameMap["IAgCrdnCalcScalarCustom"] = IAgCrdnCalcScalarCustom

class IAgCrdnCalcScalarDataElement(object):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_DataProvider" : 1,
                             "get_ElementName" : 2,
                             "get_Group" : 3,
                             "get_Interpolation" : 4,
                             "set_Interpolation" : 5,
                             "get_Sampling" : 6,
                             "set_Sampling" : 7,
                             "get_UseSamples" : 8,
                             "set_UseSamples" : 9,
                             "get_SaveDataOption" : 10,
                             "set_SaveDataOption" : 11,
                             "Set" : 12,
                             "SetWithGroup" : 13,
                             "get_InvalidDataIndicator" : 14,
                             "set_InvalidDataIndicator" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarDataElement._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarDataElement from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarDataElement.__dict__ and type(IAgCrdnCalcScalarDataElement.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarDataElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarDataElement.")
    
    _get_DataProvider_metadata = { "name" : "DataProvider",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def DataProvider(self) -> str:
        """The name of the data provider."""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_DataProvider_metadata)

    _get_ElementName_metadata = { "name" : "ElementName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ElementName(self) -> str:
        """The name of the data element within the data provider."""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_ElementName_metadata)

    _get_Group_metadata = { "name" : "Group",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Group(self) -> str:
        """A group name the data element is a part of. If the element is not a part of a group, the property will return an empty string."""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_Group_metadata)

    _get_Interpolation_metadata = { "name" : "Interpolation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Interpolation(self) -> "IAgCrdnInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_Interpolation_metadata)

    _set_Interpolation_metadata = { "name" : "Interpolation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnInterp"),) }
    @Interpolation.setter
    def Interpolation(self, interpolation:"IAgCrdnInterp") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._set_Interpolation_metadata, interpolation)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """Relative tolerance uses a combination of relative and absolute changes in scalar values between samples. Curvature tolerance also uses changes in slope between samples."""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._set_Sampling_metadata, sampling)

    _get_UseSamples_metadata = { "name" : "UseSamples",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseSamples(self) -> bool:
        """If set to true, selected data provider is presampled over its entire availability span using sampling method specified in Advanced options..."""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_UseSamples_metadata)

    _set_UseSamples_metadata = { "name" : "UseSamples",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseSamples.setter
    def UseSamples(self, useSamples:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._set_UseSamples_metadata, useSamples)

    _get_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed samples are saved/loaded, otherwise if using samples they are recomputed on load."""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_SaveDataOption_metadata)

    _set_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._set_SaveDataOption_metadata, saveDataOption)

    _Set_metadata = { "name" : "Set",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def Set(self, dataProvider:str, elementName:str) -> None:
        """Set the data provider and the element name."""
        return self._intf.invoke(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._Set_metadata, dataProvider, elementName)

    _SetWithGroup_metadata = { "name" : "SetWithGroup",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def SetWithGroup(self, dataProvider:str, typeName:str, elementName:str) -> None:
        """Set the data provider name, the element name, and data provider type name."""
        return self._intf.invoke(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._SetWithGroup_metadata, dataProvider, typeName, elementName)

    _get_InvalidDataIndicator_metadata = { "name" : "InvalidDataIndicator",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def InvalidDataIndicator(self) -> float:
        """Sets the value to display in a report or graph when the actual value is not a valid real number"""
        return self._intf.get_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._get_InvalidDataIndicator_metadata)

    _set_InvalidDataIndicator_metadata = { "name" : "InvalidDataIndicator",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @InvalidDataIndicator.setter
    def InvalidDataIndicator(self, invalidDataIndicator:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDataElement._metadata, IAgCrdnCalcScalarDataElement._set_InvalidDataIndicator_metadata, invalidDataIndicator)


agcls.AgClassCatalog.add_catalog_entry("{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}", IAgCrdnCalcScalarDataElement)
agcls.AgTypeNameMap["IAgCrdnCalcScalarDataElement"] = IAgCrdnCalcScalarDataElement

class IAgCrdnCalcScalarDerivative(object):
    """Derivative of an input scalar calculation."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Scalar" : 1,
                             "set_Scalar" : 2,
                             "get_DifferencingTimeStep" : 3,
                             "set_DifferencingTimeStep" : 4,
                             "get_ForceUseOfNumericalDifferences" : 5,
                             "set_ForceUseOfNumericalDifferences" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarDerivative._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarDerivative from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarDerivative.__dict__ and type(IAgCrdnCalcScalarDerivative.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarDerivative.")
    
    _get_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar component used to compute the derivative."""
        return self._intf.get_property(IAgCrdnCalcScalarDerivative._metadata, IAgCrdnCalcScalarDerivative._get_Scalar_metadata)

    _set_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDerivative._metadata, IAgCrdnCalcScalarDerivative._set_Scalar_metadata, scalar)

    _get_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def DifferencingTimeStep(self) -> float:
        """The time step used, if necessary, in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IAgCrdnCalcScalarDerivative._metadata, IAgCrdnCalcScalarDerivative._get_DifferencingTimeStep_metadata)

    _set_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDerivative._metadata, IAgCrdnCalcScalarDerivative._set_DifferencingTimeStep_metadata, differencingTimeStep)

    _get_ForceUseOfNumericalDifferences_metadata = { "name" : "ForceUseOfNumericalDifferences",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        return self._intf.get_property(IAgCrdnCalcScalarDerivative._metadata, IAgCrdnCalcScalarDerivative._get_ForceUseOfNumericalDifferences_metadata)

    _set_ForceUseOfNumericalDifferences_metadata = { "name" : "ForceUseOfNumericalDifferences",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDerivative._metadata, IAgCrdnCalcScalarDerivative._set_ForceUseOfNumericalDifferences_metadata, forceUseOfNumericalDifferences)


agcls.AgClassCatalog.add_catalog_entry("{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}", IAgCrdnCalcScalarDerivative)
agcls.AgTypeNameMap["IAgCrdnCalcScalarDerivative"] = IAgCrdnCalcScalarDerivative

class IAgCrdnCalcScalarDotProduct(object):
    """Dot product between two vectors."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ffb69fa2-d123-413e-bb34-db750b7775ea}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_VectorA" : 1,
                             "set_VectorA" : 2,
                             "get_NormalizeVectorA" : 3,
                             "set_NormalizeVectorA" : 4,
                             "get_VectorB" : 5,
                             "set_VectorB" : 6,
                             "get_NormalizeVectorB" : 7,
                             "set_NormalizeVectorB" : 8,
                             "get_Dimension" : 9,
                             "set_Dimension" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarDotProduct._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarDotProduct from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarDotProduct.__dict__ and type(IAgCrdnCalcScalarDotProduct.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarDotProduct.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarDotProduct.")
    
    _get_VectorA_metadata = { "name" : "VectorA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorA(self) -> "IAgCrdnVector":
        """First vector."""
        return self._intf.get_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._get_VectorA_metadata)

    _set_VectorA_metadata = { "name" : "VectorA",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @VectorA.setter
    def VectorA(self, vectorA:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._set_VectorA_metadata, vectorA)

    _get_NormalizeVectorA_metadata = { "name" : "NormalizeVectorA",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._get_NormalizeVectorA_metadata)

    _set_NormalizeVectorA_metadata = { "name" : "NormalizeVectorA",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._set_NormalizeVectorA_metadata, normalizeVectorA)

    _get_VectorB_metadata = { "name" : "VectorB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorB(self) -> "IAgCrdnVector":
        """Second vector."""
        return self._intf.get_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._get_VectorB_metadata)

    _set_VectorB_metadata = { "name" : "VectorB",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @VectorB.setter
    def VectorB(self, vectorB:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._set_VectorB_metadata, vectorB)

    _get_NormalizeVectorB_metadata = { "name" : "NormalizeVectorB",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._get_NormalizeVectorB_metadata)

    _set_NormalizeVectorB_metadata = { "name" : "NormalizeVectorB",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._set_NormalizeVectorB_metadata, normalizeVectorB)

    _get_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'Angle', 'Distance', etc."""
        return self._intf.get_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._get_Dimension_metadata)

    _set_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarDotProduct._metadata, IAgCrdnCalcScalarDotProduct._set_Dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{ffb69fa2-d123-413e-bb34-db750b7775ea}", IAgCrdnCalcScalarDotProduct)
agcls.AgTypeNameMap["IAgCrdnCalcScalarDotProduct"] = IAgCrdnCalcScalarDotProduct

class IAgCrdnCalcScalarElapsedTime(object):
    """Time elapsed since the reference time instant. Negative if in the past."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{81238610-6A1B-499A-8C43-12337F64BC42}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceTimeInstant" : 1,
                             "set_ReferenceTimeInstant" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarElapsedTime._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarElapsedTime from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarElapsedTime.__dict__ and type(IAgCrdnCalcScalarElapsedTime.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarElapsedTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarElapsedTime.")
    
    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        return self._intf.get_property(IAgCrdnCalcScalarElapsedTime._metadata, IAgCrdnCalcScalarElapsedTime._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarElapsedTime._metadata, IAgCrdnCalcScalarElapsedTime._set_ReferenceTimeInstant_metadata, referenceTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{81238610-6A1B-499A-8C43-12337F64BC42}", IAgCrdnCalcScalarElapsedTime)
agcls.AgTypeNameMap["IAgCrdnCalcScalarElapsedTime"] = IAgCrdnCalcScalarElapsedTime

class IAgCrdnCalcScalarFactory(object):
    """The factory creates scalar calculation components."""
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_AvailableCalcScalarPluginDisplayNames" : 1,
                             "Create" : 2,
                             "CreateCalcScalarAngle" : 3,
                             "CreateCalcScalarFixedAtTimeInstant" : 4,
                             "CreateCalcScalarConstant" : 5,
                             "CreateCalcScalarDataElement" : 6,
                             "CreateCalcScalarDataElementWithGroup" : 7,
                             "CreateCalcScalarDerivative" : 8,
                             "CreateCalcScalarElapsedTime" : 9,
                             "CreateCalcScalarFile" : 10,
                             "CreateCalcScalarFunction" : 11,
                             "CreateCalcScalarIntegral" : 12,
                             "CreateCalcScalarFunction2Var" : 13,
                             "CreateCalcScalarVectorMagnitude" : 14,
                             "CreateCalcScalarPluginFromDisplayName" : 15,
                             "IsTypeSupported" : 16,
                             "CreateCalcScalarFromCustomScript" : 17,
                             "CreateCalcScalarSurfaceDistanceBetweenPoints" : 18,
                             "CreateCalcScalarDotProduct" : 19,
                             "CreateCalcScalarVectorComponent" : 20, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFactory.__dict__ and type(IAgCrdnCalcScalarFactory.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarFactory.")
    
    _get_AvailableCalcScalarPluginDisplayNames_metadata = { "name" : "AvailableCalcScalarPluginDisplayNames",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableCalcScalarPluginDisplayNames(self) -> list:
        """An array of display names associated with available scalar calculation plugins. The elements of the array are strings. Display names are used to create Calc scalars based on COM plugins using CreateCalcScalarPluginFromDisplayName method."""
        return self._intf.get_property(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._get_AvailableCalcScalarPluginDisplayNames_metadata)

    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnCalcScalarType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnCalcScalarType") -> "IAgCrdnCalcScalar":
        """Creates and registers a scalar calculation using specified name, description, and type."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._Create_metadata, name, description, type, out_arg())

    _CreateCalcScalarAngle_metadata = { "name" : "CreateCalcScalarAngle",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarAngle(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation equal to angular displacement obtained from any angle in VGT."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarAngle_metadata, name, description, out_arg())

    _CreateCalcScalarFixedAtTimeInstant_metadata = { "name" : "CreateCalcScalarFixedAtTimeInstant",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarFixedAtTimeInstant(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation defined by evaluating the input scalar calculation at the specified reference time instant."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarFixedAtTimeInstant_metadata, name, description, out_arg())

    _CreateCalcScalarConstant_metadata = { "name" : "CreateCalcScalarConstant",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarConstant(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation of constant value of the specified dimension."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarConstant_metadata, name, description, out_arg())

    _CreateCalcScalarDataElement_metadata = { "name" : "CreateCalcScalarDataElement",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarDataElement(self, name:str, description:str, dataProvider:str, elementName:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarDataElement_metadata, name, description, dataProvider, elementName, out_arg())

    _CreateCalcScalarDataElementWithGroup_metadata = { "name" : "CreateCalcScalarDataElementWithGroup",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarDataElementWithGroup(self, name:str, description:str, dataProvider:str, groupName:str, elementName:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarDataElementWithGroup_metadata, name, description, dataProvider, groupName, elementName, out_arg())

    _CreateCalcScalarDerivative_metadata = { "name" : "CreateCalcScalarDerivative",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarDerivative(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is the derivative of an input scalar calculation."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarDerivative_metadata, name, description, out_arg())

    _CreateCalcScalarElapsedTime_metadata = { "name" : "CreateCalcScalarElapsedTime",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarElapsedTime(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is the time elapsed since a reference time instant."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarElapsedTime_metadata, name, description, out_arg())

    _CreateCalcScalarFile_metadata = { "name" : "CreateCalcScalarFile",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarFile(self, name:str, description:str, filepath:str) -> "IAgCrdnCalcScalar":
        """Create scalar calculation specified by external data file."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarFile_metadata, name, description, filepath, out_arg())

    _CreateCalcScalarFunction_metadata = { "name" : "CreateCalcScalarFunction",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarFunction(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by performing the specified function on the input scalar or time instant."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarFunction_metadata, name, description, out_arg())

    _CreateCalcScalarIntegral_metadata = { "name" : "CreateCalcScalarIntegral",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarIntegral(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is the integral of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarIntegral_metadata, name, description, out_arg())

    _CreateCalcScalarFunction2Var_metadata = { "name" : "CreateCalcScalarFunction2Var",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarFunction2Var(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by performing a function(x,y) on two scalar arguments."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarFunction2Var_metadata, name, description, out_arg())

    _CreateCalcScalarVectorMagnitude_metadata = { "name" : "CreateCalcScalarVectorMagnitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarVectorMagnitude(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation equal to the magnitude of a specified vector."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarVectorMagnitude_metadata, name, description, out_arg())

    _CreateCalcScalarPluginFromDisplayName_metadata = { "name" : "CreateCalcScalarPluginFromDisplayName",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarPluginFromDisplayName(self, name:str, description:str, displayName:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation based on a COM plugin. For information how to implement and register VGT plugins, see <topic name='Engine Plugins: COM-based Engine Plugin Components'>COM-based Engine Plugins.</topic>."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarPluginFromDisplayName_metadata, name, description, displayName, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnCalcScalarType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnCalcScalarType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._IsTypeSupported_metadata, eType, out_arg())

    _CreateCalcScalarFromCustomScript_metadata = { "name" : "CreateCalcScalarFromCustomScript",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarFromCustomScript(self, name:str, description:str, filepath:str) -> "IAgCrdnCalcScalar":
        """Create a calc scalar calculation that uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarFromCustomScript_metadata, name, description, filepath, out_arg())

    _CreateCalcScalarSurfaceDistanceBetweenPoints_metadata = { "name" : "CreateCalcScalarSurfaceDistanceBetweenPoints",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarSurfaceDistanceBetweenPoints(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a calc scalar calculation that is surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarSurfaceDistanceBetweenPoints_metadata, name, description, out_arg())

    _CreateCalcScalarDotProduct_metadata = { "name" : "CreateCalcScalarDotProduct",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarDotProduct(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by a dot product between two vectors."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarDotProduct_metadata, name, description, out_arg())

    _CreateCalcScalarVectorComponent_metadata = { "name" : "CreateCalcScalarVectorComponent",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCalcScalarVectorComponent(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by a specified component of a vector when resolved in specified axes."""
        return self._intf.invoke(IAgCrdnCalcScalarFactory._metadata, IAgCrdnCalcScalarFactory._CreateCalcScalarVectorComponent_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}", IAgCrdnCalcScalarFactory)
agcls.AgTypeNameMap["IAgCrdnCalcScalarFactory"] = IAgCrdnCalcScalarFactory

class IAgCrdnCalcScalarFile(object):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{98BC97CE-DA0B-4783-BB98-A988CA16447A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Filename" : 1,
                             "set_Filename" : 2,
                             "Reload" : 3,
                             "GetFileSpan" : 4,
                             "get_FileInterpolationType" : 5,
                             "set_FileInterpolationType" : 6,
                             "get_FileInterpolationOrder" : 7,
                             "set_FileInterpolationOrder" : 8,
                             "get_UseNativeFileInterpolationSettings" : 9,
                             "set_UseNativeFileInterpolationSettings" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarFile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarFile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFile.__dict__ and type(IAgCrdnCalcScalarFile.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarFile.")
    
    _get_Filename_metadata = { "name" : "Filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Filename(self) -> str:
        """The path to an ASCII file with .csc extension."""
        return self._intf.get_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._get_Filename_metadata)

    _set_Filename_metadata = { "name" : "Filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Filename.setter
    def Filename(self, filename:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._set_Filename_metadata, filename)

    _Reload_metadata = { "name" : "Reload",
            "arg_types" : (),
            "marshallers" : () }
    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        return self._intf.invoke(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._Reload_metadata, )

    _GetFileSpan_metadata = { "name" : "GetFileSpan",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetFileSpan(self) -> "IAgCrdnEventIntervalResult":
        """Computes the interval time span of the file."""
        return self._intf.invoke(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._GetFileSpan_metadata, out_arg())

    _get_FileInterpolationType_metadata = { "name" : "FileInterpolationType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType),) }
    @property
    def FileInterpolationType(self) -> "AgECrdnFileInterpolatorType":
        """The interpolation method used with the data."""
        return self._intf.get_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._get_FileInterpolationType_metadata)

    _set_FileInterpolationType_metadata = { "name" : "FileInterpolationType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType),) }
    @FileInterpolationType.setter
    def FileInterpolationType(self, fileInterpolationType:"AgECrdnFileInterpolatorType") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._set_FileInterpolationType_metadata, fileInterpolationType)

    _get_FileInterpolationOrder_metadata = { "name" : "FileInterpolationOrder",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def FileInterpolationOrder(self) -> int:
        """The interpolation order used with the interpolation method to interrogate the data."""
        return self._intf.get_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._get_FileInterpolationOrder_metadata)

    _set_FileInterpolationOrder_metadata = { "name" : "FileInterpolationOrder",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @FileInterpolationOrder.setter
    def FileInterpolationOrder(self, fileInterpolationOrder:int) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._set_FileInterpolationOrder_metadata, fileInterpolationOrder)

    _get_UseNativeFileInterpolationSettings_metadata = { "name" : "UseNativeFileInterpolationSettings",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseNativeFileInterpolationSettings(self) -> bool:
        """Flag indicating whether the interpolation method and order settings specified within the file, if any, will be honored."""
        return self._intf.get_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._get_UseNativeFileInterpolationSettings_metadata)

    _set_UseNativeFileInterpolationSettings_metadata = { "name" : "UseNativeFileInterpolationSettings",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseNativeFileInterpolationSettings.setter
    def UseNativeFileInterpolationSettings(self, useNativeFileInterpolationSettings:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFile._metadata, IAgCrdnCalcScalarFile._set_UseNativeFileInterpolationSettings_metadata, useNativeFileInterpolationSettings)


agcls.AgClassCatalog.add_catalog_entry("{98BC97CE-DA0B-4783-BB98-A988CA16447A}", IAgCrdnCalcScalarFile)
agcls.AgTypeNameMap["IAgCrdnCalcScalarFile"] = IAgCrdnCalcScalarFile

class IAgCrdnCalcScalarFixedAtTimeInstant(object):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_InputScalar" : 1,
                             "set_InputScalar" : 2,
                             "get_ReferenceTimeInstant" : 3,
                             "set_ReferenceTimeInstant" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarFixedAtTimeInstant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarFixedAtTimeInstant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFixedAtTimeInstant.__dict__ and type(IAgCrdnCalcScalarFixedAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarFixedAtTimeInstant.")
    
    _get_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar component."""
        return self._intf.get_property(IAgCrdnCalcScalarFixedAtTimeInstant._metadata, IAgCrdnCalcScalarFixedAtTimeInstant._get_InputScalar_metadata)

    _set_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFixedAtTimeInstant._metadata, IAgCrdnCalcScalarFixedAtTimeInstant._set_InputScalar_metadata, inputScalar)

    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        return self._intf.get_property(IAgCrdnCalcScalarFixedAtTimeInstant._metadata, IAgCrdnCalcScalarFixedAtTimeInstant._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFixedAtTimeInstant._metadata, IAgCrdnCalcScalarFixedAtTimeInstant._set_ReferenceTimeInstant_metadata, referenceTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}", IAgCrdnCalcScalarFixedAtTimeInstant)
agcls.AgTypeNameMap["IAgCrdnCalcScalarFixedAtTimeInstant"] = IAgCrdnCalcScalarFixedAtTimeInstant

class IAgCrdnCalcScalarFunction(object):
    """Defined by performing the specified function on the input scalar or time instant."""
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_UseScalar" : 1,
                             "set_UseScalar" : 2,
                             "get_InputScalar" : 3,
                             "set_InputScalar" : 4,
                             "get_InputTime" : 5,
                             "set_InputTime" : 6,
                             "get_InputUnit" : 7,
                             "set_InputUnit" : 8,
                             "get_A" : 9,
                             "set_A" : 10,
                             "get_B" : 11,
                             "set_B" : 12,
                             "get_C" : 13,
                             "set_C" : 14,
                             "get_D" : 15,
                             "set_D" : 16,
                             "get_Coefficients" : 17,
                             "set_Coefficients" : 18,
                             "get_SelectedFunction" : 19,
                             "set_SelectedFunction" : 20,
                             "get_AvailableFunctions" : 21,
                             "get_InheritDimensionFromInput" : 22,
                             "set_InheritDimensionFromInput" : 23,
                             "get_OutputDimension" : 24,
                             "set_OutputDimension" : 25,
                             "get_OutputUnit" : 26,
                             "set_OutputUnit" : 27,
                             "get_Sampling" : 28,
                             "set_Sampling" : 29,
                             "get_Convergence" : 30,
                             "set_Convergence" : 31, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarFunction._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarFunction from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFunction.__dict__ and type(IAgCrdnCalcScalarFunction.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarFunction.")
    
    _get_UseScalar_metadata = { "name" : "UseScalar",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseScalar(self) -> bool:
        """Specify whether to use the input scalar calculation or the time elapsed from the input time instant. Set to true to use the scalar."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_UseScalar_metadata)

    _set_UseScalar_metadata = { "name" : "UseScalar",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseScalar.setter
    def UseScalar(self, useScalar:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_UseScalar_metadata, useScalar)

    _get_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar calculation (used if UseScalar is true). The UseScalar property should be set to true before this property can be set."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_InputScalar_metadata)

    _set_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_InputScalar_metadata, inputScalar)

    _get_InputTime_metadata = { "name" : "InputTime",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputTime(self) -> "IAgCrdnEvent":
        """The input time instant (used if UseScalar is false)."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_InputTime_metadata)

    _set_InputTime_metadata = { "name" : "InputTime",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @InputTime.setter
    def InputTime(self, inputTime:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_InputTime_metadata, inputTime)

    _get_InputUnit_metadata = { "name" : "InputUnit",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def InputUnit(self) -> str:
        """The input time unit to interpret input time."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_InputUnit_metadata)

    _set_InputUnit_metadata = { "name" : "InputUnit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @InputUnit.setter
    def InputUnit(self, inputUnit:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_InputUnit_metadata, inputUnit)

    _get_A_metadata = { "name" : "A",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def A(self) -> float:
        """The constant coefficient A."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_A_metadata)

    _set_A_metadata = { "name" : "A",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @A.setter
    def A(self, a:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_A_metadata, a)

    _get_B_metadata = { "name" : "B",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def B(self) -> float:
        """The constant coefficient B."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_B_metadata)

    _set_B_metadata = { "name" : "B",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @B.setter
    def B(self, b:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_B_metadata, b)

    _get_C_metadata = { "name" : "C",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def C(self) -> float:
        """The constant coefficient C."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_C_metadata)

    _set_C_metadata = { "name" : "C",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @C.setter
    def C(self, c:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_C_metadata, c)

    _get_D_metadata = { "name" : "D",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def D(self) -> float:
        """The constant coefficient D."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_D_metadata)

    _set_D_metadata = { "name" : "D",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @D.setter
    def D(self, d:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_D_metadata, d)

    _get_Coefficients_metadata = { "name" : "Coefficients",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Coefficients(self) -> list:
        """The array of constant coefficients, whose dimension and units are determined by those of input and output."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_Coefficients_metadata)

    _set_Coefficients_metadata = { "name" : "Coefficients",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @Coefficients.setter
    def Coefficients(self, coefficients:list) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_Coefficients_metadata, coefficients)

    _get_SelectedFunction_metadata = { "name" : "SelectedFunction",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def SelectedFunction(self) -> str:
        """The function which will use the input scalar or time instant in some combination with the constant coefficients A, B, C, D."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_SelectedFunction_metadata)

    _set_SelectedFunction_metadata = { "name" : "SelectedFunction",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_SelectedFunction_metadata, selectedFunction)

    _get_AvailableFunctions_metadata = { "name" : "AvailableFunctions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableFunctions(self) -> list:
        """Get the available function names."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_AvailableFunctions_metadata)

    _get_InheritDimensionFromInput_metadata = { "name" : "InheritDimensionFromInput",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def InheritDimensionFromInput(self) -> bool:
        """Specify whether to inherit the output dimension from the input scalar or time instant."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_InheritDimensionFromInput_metadata)

    _set_InheritDimensionFromInput_metadata = { "name" : "InheritDimensionFromInput",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @InheritDimensionFromInput.setter
    def InheritDimensionFromInput(self, inheritDimensionFromInput:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_InheritDimensionFromInput_metadata, inheritDimensionFromInput)

    _get_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if InheritDimensionFromInput is false. The InheritDimensionFromInput property should be set to false before this property can be fixed."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_OutputDimension_metadata)

    _set_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_OutputDimension_metadata, outputDimension)

    _get_OutputUnit_metadata = { "name" : "OutputUnit",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def OutputUnit(self) -> str:
        """Specify a unit for the selected output dimension. This is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_OutputUnit_metadata)

    _set_OutputUnit_metadata = { "name" : "OutputUnit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_OutputUnit_metadata, outputUnit)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_Sampling_metadata, sampling)

    _get_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._get_Convergence_metadata)

    _set_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConverge"),) }
    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction._metadata, IAgCrdnCalcScalarFunction._set_Convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}", IAgCrdnCalcScalarFunction)
agcls.AgTypeNameMap["IAgCrdnCalcScalarFunction"] = IAgCrdnCalcScalarFunction

class IAgCrdnCalcScalarFunction2Var(object):
    """Defined by performing a function(x,y) on two scalar arguments."""
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E56D021E-AD96-4ABE-857E-708CDCC4FF14}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_X" : 1,
                             "set_X" : 2,
                             "get_UnitX" : 3,
                             "set_UnitX" : 4,
                             "get_A" : 5,
                             "set_A" : 6,
                             "get_Y" : 7,
                             "set_Y" : 8,
                             "get_UnitY" : 9,
                             "set_UnitY" : 10,
                             "get_B" : 11,
                             "set_B" : 12,
                             "get_C" : 13,
                             "set_C" : 14,
                             "get_OutputDimensionInheritance" : 15,
                             "set_OutputDimensionInheritance" : 16,
                             "get_OutputDimension" : 17,
                             "set_OutputDimension" : 18,
                             "get_AvailableFunctions" : 19,
                             "get_SelectedFunction" : 20,
                             "set_SelectedFunction" : 21,
                             "get_OutputUnit" : 22,
                             "set_OutputUnit" : 23, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarFunction2Var._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarFunction2Var from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFunction2Var.__dict__ and type(IAgCrdnCalcScalarFunction2Var.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFunction2Var.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarFunction2Var.")
    
    _get_X_metadata = { "name" : "X",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def X(self) -> "IAgCrdnCalcScalar":
        """The scalar argument X."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_X_metadata)

    _set_X_metadata = { "name" : "X",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @X.setter
    def X(self, x:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_X_metadata, x)

    _get_UnitX_metadata = { "name" : "UnitX",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def UnitX(self) -> str:
        """The unit used to interpret numerical values of scalar argument X."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_UnitX_metadata)

    _set_UnitX_metadata = { "name" : "UnitX",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @UnitX.setter
    def UnitX(self, unitX:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_UnitX_metadata, unitX)

    _get_A_metadata = { "name" : "A",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def A(self) -> float:
        """The constant coefficient A."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_A_metadata)

    _set_A_metadata = { "name" : "A",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @A.setter
    def A(self, a:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_A_metadata, a)

    _get_Y_metadata = { "name" : "Y",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Y(self) -> "IAgCrdnCalcScalar":
        """The scalar argument Y."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_Y_metadata)

    _set_Y_metadata = { "name" : "Y",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @Y.setter
    def Y(self, y:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_Y_metadata, y)

    _get_UnitY_metadata = { "name" : "UnitY",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def UnitY(self) -> str:
        """The unit used to interpret numerical values of scalar argument Y."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_UnitY_metadata)

    _set_UnitY_metadata = { "name" : "UnitY",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @UnitY.setter
    def UnitY(self, unitY:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_UnitY_metadata, unitY)

    _get_B_metadata = { "name" : "B",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def B(self) -> float:
        """The constant coefficient B."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_B_metadata)

    _set_B_metadata = { "name" : "B",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @B.setter
    def B(self, b:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_B_metadata, b)

    _get_C_metadata = { "name" : "C",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def C(self) -> float:
        """The constant coefficient C."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_C_metadata)

    _set_C_metadata = { "name" : "C",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @C.setter
    def C(self, c:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_C_metadata, c)

    _get_OutputDimensionInheritance_metadata = { "name" : "OutputDimensionInheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDimensionInheritance),) }
    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Specifies whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_OutputDimensionInheritance_metadata)

    _set_OutputDimensionInheritance_metadata = { "name" : "OutputDimensionInheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDimensionInheritance),) }
    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_OutputDimensionInheritance_metadata, outputDimensionInheritance)

    _get_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if OutputDimensionInheritance is false."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_OutputDimension_metadata)

    _set_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_OutputDimension_metadata, outputDimension)

    _get_AvailableFunctions_metadata = { "name" : "AvailableFunctions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableFunctions(self) -> list:
        """The available functions. A function(x,y) uses some combination of two scalar arguments x and y as well as one to three constant coefficients a, b, c."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_AvailableFunctions_metadata)

    _get_SelectedFunction_metadata = { "name" : "SelectedFunction",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def SelectedFunction(self) -> str:
        """The selected function."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_SelectedFunction_metadata)

    _set_SelectedFunction_metadata = { "name" : "SelectedFunction",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_SelectedFunction_metadata, selectedFunction)

    _get_OutputUnit_metadata = { "name" : "OutputUnit",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def OutputUnit(self) -> str:
        """The unit for the selected dimension. The unit is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        return self._intf.get_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._get_OutputUnit_metadata)

    _set_OutputUnit_metadata = { "name" : "OutputUnit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarFunction2Var._metadata, IAgCrdnCalcScalarFunction2Var._set_OutputUnit_metadata, outputUnit)


agcls.AgClassCatalog.add_catalog_entry("{E56D021E-AD96-4ABE-857E-708CDCC4FF14}", IAgCrdnCalcScalarFunction2Var)
agcls.AgTypeNameMap["IAgCrdnCalcScalarFunction2Var"] = IAgCrdnCalcScalarFunction2Var

class IAgCrdnCalcScalarIntegral(object):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_InputScalar" : 1,
                             "set_InputScalar" : 2,
                             "get_ComputeAsAverage" : 3,
                             "set_ComputeAsAverage" : 4,
                             "get_IntegrationWindowType" : 5,
                             "set_IntegrationWindowType" : 6,
                             "get_StartOffset" : 7,
                             "set_StartOffset" : 8,
                             "get_StopOffset" : 9,
                             "set_StopOffset" : 10,
                             "get_UseCustomTimeLimits" : 11,
                             "set_UseCustomTimeLimits" : 12,
                             "get_CustomTimeLimits" : 13,
                             "set_CustomTimeLimits" : 14,
                             "get_SaveDataOption" : 15,
                             "set_SaveDataOption" : 16,
                             "get_Interpolation" : 17,
                             "set_Interpolation" : 18,
                             "get_Sampling" : 19,
                             "set_Sampling" : 20,
                             "get_Integral" : 21,
                             "set_Integral" : 22,
                             "get_KeepConstantOutsideTimeLimits" : 23,
                             "set_KeepConstantOutsideTimeLimits" : 24,
                             "SetOffsets" : 25, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarIntegral._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarIntegral from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarIntegral.__dict__ and type(IAgCrdnCalcScalarIntegral.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarIntegral.")
    
    _get_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar calculation."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_InputScalar_metadata)

    _set_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_InputScalar_metadata, inputScalar)

    _get_ComputeAsAverage_metadata = { "name" : "ComputeAsAverage",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ComputeAsAverage(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_ComputeAsAverage_metadata)

    _set_ComputeAsAverage_metadata = { "name" : "ComputeAsAverage",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ComputeAsAverage.setter
    def ComputeAsAverage(self, computeAsAverage:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_ComputeAsAverage_metadata, computeAsAverage)

    _get_IntegrationWindowType_metadata = { "name" : "IntegrationWindowType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType),) }
    @property
    def IntegrationWindowType(self) -> "AgECrdnIntegrationWindowType":
        """The integration window, or accumulation, type."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_IntegrationWindowType_metadata)

    _set_IntegrationWindowType_metadata = { "name" : "IntegrationWindowType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType),) }
    @IntegrationWindowType.setter
    def IntegrationWindowType(self, integrationWindowType:"AgECrdnIntegrationWindowType") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_IntegrationWindowType_metadata, integrationWindowType)

    _get_StartOffset_metadata = { "name" : "StartOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_StartOffset_metadata)

    _set_StartOffset_metadata = { "name" : "StartOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_StartOffset_metadata, startOffset)

    _get_StopOffset_metadata = { "name" : "StopOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_StopOffset_metadata)

    _set_StopOffset_metadata = { "name" : "StopOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_StopOffset_metadata, stopOffset)

    _get_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_UseCustomTimeLimits_metadata)

    _set_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_UseCustomTimeLimits_metadata, useCustomTimeLimits)

    _get_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_CustomTimeLimits_metadata)

    _set_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_CustomTimeLimits_metadata, customTimeLimits)

    _get_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_SaveDataOption_metadata)

    _set_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_SaveDataOption_metadata, saveDataOption)

    _get_Interpolation_metadata = { "name" : "Interpolation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Interpolation(self) -> "IAgCrdnInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_Interpolation_metadata)

    _set_Interpolation_metadata = { "name" : "Interpolation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnInterp"),) }
    @Interpolation.setter
    def Interpolation(self, interpolation:"IAgCrdnInterp") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_Interpolation_metadata, interpolation)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_Sampling_metadata, sampling)

    _get_Integral_metadata = { "name" : "Integral",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Integral(self) -> "IAgCrdnIntegral":
        """The numerical integration method."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_Integral_metadata)

    _set_Integral_metadata = { "name" : "Integral",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnIntegral"),) }
    @Integral.setter
    def Integral(self, integral:"IAgCrdnIntegral") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_Integral_metadata, integral)

    _get_KeepConstantOutsideTimeLimits_metadata = { "name" : "KeepConstantOutsideTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def KeepConstantOutsideTimeLimits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        return self._intf.get_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._get_KeepConstantOutsideTimeLimits_metadata)

    _set_KeepConstantOutsideTimeLimits_metadata = { "name" : "KeepConstantOutsideTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @KeepConstantOutsideTimeLimits.setter
    def KeepConstantOutsideTimeLimits(self, keepConstantOutsideTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._set_KeepConstantOutsideTimeLimits_metadata, keepConstantOutsideTimeLimits)

    _SetOffsets_metadata = { "name" : "SetOffsets",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def SetOffsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.invoke(IAgCrdnCalcScalarIntegral._metadata, IAgCrdnCalcScalarIntegral._SetOffsets_metadata, startOffset, stopOffset)


agcls.AgClassCatalog.add_catalog_entry("{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}", IAgCrdnCalcScalarIntegral)
agcls.AgTypeNameMap["IAgCrdnCalcScalarIntegral"] = IAgCrdnCalcScalarIntegral

class IAgCrdnCalcScalarPlugin(object):
    """Use a scalar calculation plugin."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1459313C-59BD-42FF-9F0D-AF4604F13D4C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ProgID" : 1,
                             "get_DisplayName" : 2,
                             "get_AvailableProperties" : 3,
                             "Reset" : 4,
                             "SetProperty" : 5,
                             "GetProperty" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarPlugin._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarPlugin from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarPlugin.__dict__ and type(IAgCrdnCalcScalarPlugin.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarPlugin.")
    
    _get_ProgID_metadata = { "name" : "ProgID",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(IAgCrdnCalcScalarPlugin._metadata, IAgCrdnCalcScalarPlugin._get_ProgID_metadata)

    _get_DisplayName_metadata = { "name" : "DisplayName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def DisplayName(self) -> str:
        """The plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(IAgCrdnCalcScalarPlugin._metadata, IAgCrdnCalcScalarPlugin._get_DisplayName_metadata)

    _get_AvailableProperties_metadata = { "name" : "AvailableProperties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(IAgCrdnCalcScalarPlugin._metadata, IAgCrdnCalcScalarPlugin._get_AvailableProperties_metadata)

    _Reset_metadata = { "name" : "Reset",
            "arg_types" : (),
            "marshallers" : () }
    def Reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(IAgCrdnCalcScalarPlugin._metadata, IAgCrdnCalcScalarPlugin._Reset_metadata, )

    _SetProperty_metadata = { "name" : "SetProperty",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, an invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(IAgCrdnCalcScalarPlugin._metadata, IAgCrdnCalcScalarPlugin._SetProperty_metadata, name, value)

    _GetProperty_metadata = { "name" : "GetProperty",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(IAgCrdnCalcScalarPlugin._metadata, IAgCrdnCalcScalarPlugin._GetProperty_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{1459313C-59BD-42FF-9F0D-AF4604F13D4C}", IAgCrdnCalcScalarPlugin)
agcls.AgTypeNameMap["IAgCrdnCalcScalarPlugin"] = IAgCrdnCalcScalarPlugin

class IAgCrdnCalcScalarSurfaceDistanceBetweenPoints(object):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DC5C0166-111F-4E8A-9650-012CE6A57911}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Point1" : 1,
                             "set_Point1" : 2,
                             "get_Point2" : 3,
                             "set_Point2" : 4,
                             "get_SurfaceCentralBody" : 5,
                             "set_SurfaceCentralBody" : 6,
                             "get_DifferencingTimeStep" : 7,
                             "set_DifferencingTimeStep" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarSurfaceDistanceBetweenPoints from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__ and type(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.")
    
    _get_Point1_metadata = { "name" : "Point1",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Point1(self) -> "IAgCrdnPoint":
        """Starting point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        return self._intf.get_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_Point1_metadata)

    _set_Point1_metadata = { "name" : "Point1",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @Point1.setter
    def Point1(self, point1:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._set_Point1_metadata, point1)

    _get_Point2_metadata = { "name" : "Point2",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Point2(self) -> "IAgCrdnPoint":
        """Terminating point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        return self._intf.get_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_Point2_metadata)

    _set_Point2_metadata = { "name" : "Point2",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @Point2.setter
    def Point2(self, point2:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._set_Point2_metadata, point2)

    _get_SurfaceCentralBody_metadata = { "name" : "SurfaceCentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def SurfaceCentralBody(self) -> str:
        """Central body on which the surface distance between points is to be calculated."""
        return self._intf.get_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_SurfaceCentralBody_metadata)

    _set_SurfaceCentralBody_metadata = { "name" : "SurfaceCentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._set_SurfaceCentralBody_metadata, surfaceCentralBody)

    _get_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of scalar calculation time rate of change (derivatives using central differencing)."""
        return self._intf.get_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_DifferencingTimeStep_metadata)

    _set_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._metadata, IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._set_DifferencingTimeStep_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{DC5C0166-111F-4E8A-9650-012CE6A57911}", IAgCrdnCalcScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap["IAgCrdnCalcScalarSurfaceDistanceBetweenPoints"] = IAgCrdnCalcScalarSurfaceDistanceBetweenPoints

class IAgCrdnCalcScalarVectorComponent(object):
    """The specified component of a vector when resolved in the specified axes."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2adb8ac1-7836-45af-b7f1-77b13a9db586}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_InputVector" : 1,
                             "set_InputVector" : 2,
                             "get_ReferenceAxes" : 3,
                             "set_ReferenceAxes" : 4,
                             "get_Component" : 5,
                             "set_Component" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarVectorComponent._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarVectorComponent from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarVectorComponent.__dict__ and type(IAgCrdnCalcScalarVectorComponent.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarVectorComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarVectorComponent.")
    
    _get_InputVector_metadata = { "name" : "InputVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputVector(self) -> "IAgCrdnVector":
        """Vector."""
        return self._intf.get_property(IAgCrdnCalcScalarVectorComponent._metadata, IAgCrdnCalcScalarVectorComponent._get_InputVector_metadata)

    _set_InputVector_metadata = { "name" : "InputVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @InputVector.setter
    def InputVector(self, inputVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarVectorComponent._metadata, IAgCrdnCalcScalarVectorComponent._set_InputVector_metadata, inputVector)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """Axes used to resolve the vector's components."""
        return self._intf.get_property(IAgCrdnCalcScalarVectorComponent._metadata, IAgCrdnCalcScalarVectorComponent._get_ReferenceAxes_metadata)

    _set_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarVectorComponent._metadata, IAgCrdnCalcScalarVectorComponent._set_ReferenceAxes_metadata, referenceAxes)

    _get_Component_metadata = { "name" : "Component",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVectorComponentType),) }
    @property
    def Component(self) -> "AgECrdnVectorComponentType":
        """The component of the vector to return as the value of the scalar."""
        return self._intf.get_property(IAgCrdnCalcScalarVectorComponent._metadata, IAgCrdnCalcScalarVectorComponent._get_Component_metadata)

    _set_Component_metadata = { "name" : "Component",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVectorComponentType),) }
    @Component.setter
    def Component(self, component:"AgECrdnVectorComponentType") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarVectorComponent._metadata, IAgCrdnCalcScalarVectorComponent._set_Component_metadata, component)


agcls.AgClassCatalog.add_catalog_entry("{2adb8ac1-7836-45af-b7f1-77b13a9db586}", IAgCrdnCalcScalarVectorComponent)
agcls.AgTypeNameMap["IAgCrdnCalcScalarVectorComponent"] = IAgCrdnCalcScalarVectorComponent

class IAgCrdnCalcScalarVectorMagnitude(object):
    """Scalar equal to the magnitude of a specified vector."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{57FC76A1-A63F-4A25-A3A6-3953275A15E4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_InputVector" : 1,
                             "set_InputVector" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCalcScalarVectorMagnitude._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCalcScalarVectorMagnitude from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarVectorMagnitude.__dict__ and type(IAgCrdnCalcScalarVectorMagnitude.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarVectorMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCalcScalarVectorMagnitude.")
    
    _get_InputVector_metadata = { "name" : "InputVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputVector(self) -> "IAgCrdnVector":
        """Specify any vector in VGT. Note that its magnitude is reference axes independent which is why it is not specified."""
        return self._intf.get_property(IAgCrdnCalcScalarVectorMagnitude._metadata, IAgCrdnCalcScalarVectorMagnitude._get_InputVector_metadata)

    _set_InputVector_metadata = { "name" : "InputVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @InputVector.setter
    def InputVector(self, inputVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnCalcScalarVectorMagnitude._metadata, IAgCrdnCalcScalarVectorMagnitude._set_InputVector_metadata, inputVector)


agcls.AgClassCatalog.add_catalog_entry("{57FC76A1-A63F-4A25-A3A6-3953275A15E4}", IAgCrdnCalcScalarVectorMagnitude)
agcls.AgTypeNameMap["IAgCrdnCalcScalarVectorMagnitude"] = IAgCrdnCalcScalarVectorMagnitude

class IAgCrdnCondition(object):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8CA43B7E-6345-4F97-97B2-A4C4517739C8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "Evaluate" : 2,
                             "EvaluateWithRate" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCondition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCondition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCondition.__dict__ and type(IAgCrdnCondition.__dict__[attrname]) == property:
            return IAgCrdnCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCondition.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionType),) }
    @property
    def Type(self) -> "AgECrdnConditionType":
        """Returns the type of condition."""
        return self._intf.get_property(IAgCrdnCondition._metadata, IAgCrdnCondition._get_Type_metadata)

    _Evaluate_metadata = { "name" : "Evaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Evaluate(self, epoch:typing.Any) -> "IAgCrdnEvaluateResult":
        """Returns result of evaluating continuously varying condition metric at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(IAgCrdnCondition._metadata, IAgCrdnCondition._Evaluate_metadata, epoch, out_arg())

    _EvaluateWithRate_metadata = { "name" : "EvaluateWithRate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def EvaluateWithRate(self, epoch:typing.Any) -> "IAgCrdnEvaluateWithRateResult":
        """Returns result of evaluating continuously varying condition metric and its rate of change at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(IAgCrdnCondition._metadata, IAgCrdnCondition._EvaluateWithRate_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{8CA43B7E-6345-4F97-97B2-A4C4517739C8}", IAgCrdnCondition)
agcls.AgTypeNameMap["IAgCrdnCondition"] = IAgCrdnCondition

class IAgCrdnConditionCombined(object):
    """Defines a condition which combines multiple conditions."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB19E942-0C28-4AB9-B2C0-D31693564C99}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CombineOperation" : 1,
                             "set_CombineOperation" : 2,
                             "get_ConditionCount" : 3,
                             "GetAllConditions" : 4,
                             "SetAllConditions" : 5,
                             "GetCondition" : 6,
                             "SetCondition" : 7,
                             "RemoveCondition" : 8,
                             "AddCondition" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionCombined._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionCombined from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionCombined.__dict__ and type(IAgCrdnConditionCombined.__dict__[attrname]) == property:
            return IAgCrdnConditionCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionCombined.")
    
    _get_CombineOperation_metadata = { "name" : "CombineOperation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType),) }
    @property
    def CombineOperation(self) -> "AgECrdnConditionCombinedOperationType":
        """Get the operation from the condition that determines how the conditions are combined. The operation can be set to AND, OR, XOR, MINUS."""
        return self._intf.get_property(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._get_CombineOperation_metadata)

    _set_CombineOperation_metadata = { "name" : "CombineOperation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType),) }
    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnConditionCombinedOperationType") -> None:
        return self._intf.set_property(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._set_CombineOperation_metadata, combineOperation)

    _get_ConditionCount_metadata = { "name" : "ConditionCount",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def ConditionCount(self) -> int:
        """Gets the number of conditions in the combined condition."""
        return self._intf.get_property(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._get_ConditionCount_metadata)

    _GetAllConditions_metadata = { "name" : "GetAllConditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def GetAllConditions(self) -> list:
        """Get all conditions that are being combined."""
        return self._intf.invoke(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._GetAllConditions_metadata, out_arg())

    _SetAllConditions_metadata = { "name" : "SetAllConditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def SetAllConditions(self, conditions:list) -> None:
        """Set all conditions to be combined."""
        return self._intf.invoke(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._SetAllConditions_metadata, conditions)

    _GetCondition_metadata = { "name" : "GetCondition",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetCondition(self, pos:int) -> "IAgCrdnCondition":
        """Get the condition at the position specified."""
        return self._intf.invoke(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._GetCondition_metadata, pos, out_arg())

    _SetCondition_metadata = { "name" : "SetCondition",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCondition"), agmarshall.INT_arg,) }
    def SetCondition(self, ref:"IAgCrdnCondition", pos:int) -> None:
        """Set the condition at the position specified."""
        return self._intf.invoke(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._SetCondition_metadata, ref, pos)

    _RemoveCondition_metadata = { "name" : "RemoveCondition",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    def RemoveCondition(self, pos:int) -> None:
        """Remove the condition at the position specified."""
        return self._intf.invoke(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._RemoveCondition_metadata, pos)

    _AddCondition_metadata = { "name" : "AddCondition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCondition"),) }
    def AddCondition(self, ref:"IAgCrdnCondition") -> None:
        """Adds a condition at the end of the list."""
        return self._intf.invoke(IAgCrdnConditionCombined._metadata, IAgCrdnConditionCombined._AddCondition_metadata, ref)


agcls.AgClassCatalog.add_catalog_entry("{EB19E942-0C28-4AB9-B2C0-D31693564C99}", IAgCrdnConditionCombined)
agcls.AgTypeNameMap["IAgCrdnConditionCombined"] = IAgCrdnConditionCombined

class IAgCrdnConditionFactory(object):
    """The factory creates condition components."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateConditionScalarBounds" : 2,
                             "IsTypeSupported" : 3,
                             "CreateConditionCombined" : 4,
                             "CreateConditionPointInVolume" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionFactory.__dict__ and type(IAgCrdnConditionFactory.__dict__[attrname]) == property:
            return IAgCrdnConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnConditionType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnConditionType") -> "IAgCrdnCondition":
        """Creates and registers a condition using specified name, description and type."""
        return self._intf.invoke(IAgCrdnConditionFactory._metadata, IAgCrdnConditionFactory._Create_metadata, name, description, type, out_arg())

    _CreateConditionScalarBounds_metadata = { "name" : "CreateConditionScalarBounds",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateConditionScalarBounds(self, name:str, description:str) -> "IAgCrdnCondition":
        """Creates a condition placing bounds on specified scalar."""
        return self._intf.invoke(IAgCrdnConditionFactory._metadata, IAgCrdnConditionFactory._CreateConditionScalarBounds_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnConditionType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnConditionFactory._metadata, IAgCrdnConditionFactory._IsTypeSupported_metadata, eType, out_arg())

    _CreateConditionCombined_metadata = { "name" : "CreateConditionCombined",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateConditionCombined(self, name:str, description:str) -> "IAgCrdnCondition":
        """Creates a condition which combines multiple conditions."""
        return self._intf.invoke(IAgCrdnConditionFactory._metadata, IAgCrdnConditionFactory._CreateConditionCombined_metadata, name, description, out_arg())

    _CreateConditionPointInVolume_metadata = { "name" : "CreateConditionPointInVolume",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateConditionPointInVolume(self, name:str, description:str) -> "IAgCrdnCondition":
        """Creates a condition for point in volume."""
        return self._intf.invoke(IAgCrdnConditionFactory._metadata, IAgCrdnConditionFactory._CreateConditionPointInVolume_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}", IAgCrdnConditionFactory)
agcls.AgTypeNameMap["IAgCrdnConditionFactory"] = IAgCrdnConditionFactory

class IAgCrdnConditionPointInVolume(object):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3C354DF9-E914-4542-9E21-F70A637C4EA4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Point" : 1,
                             "set_Point" : 2,
                             "get_Constraint" : 3,
                             "set_Constraint" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionPointInVolume._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionPointInVolume from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionPointInVolume.__dict__ and type(IAgCrdnConditionPointInVolume.__dict__[attrname]) == property:
            return IAgCrdnConditionPointInVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionPointInVolume.")
    
    _get_Point_metadata = { "name" : "Point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Point(self) -> "IAgCrdnPoint":
        """Get the trajectory point from the condition."""
        return self._intf.get_property(IAgCrdnConditionPointInVolume._metadata, IAgCrdnConditionPointInVolume._get_Point_metadata)

    _set_Point_metadata = { "name" : "Point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @Point.setter
    def Point(self, point:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnConditionPointInVolume._metadata, IAgCrdnConditionPointInVolume._set_Point_metadata, point)

    _get_Constraint_metadata = { "name" : "Constraint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Constraint(self) -> "IAgCrdnVolume":
        """Get the volume constraint on trajectory point."""
        return self._intf.get_property(IAgCrdnConditionPointInVolume._metadata, IAgCrdnConditionPointInVolume._get_Constraint_metadata)

    _set_Constraint_metadata = { "name" : "Constraint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolume"),) }
    @Constraint.setter
    def Constraint(self, constraint:"IAgCrdnVolume") -> None:
        return self._intf.set_property(IAgCrdnConditionPointInVolume._metadata, IAgCrdnConditionPointInVolume._set_Constraint_metadata, constraint)


agcls.AgClassCatalog.add_catalog_entry("{3C354DF9-E914-4542-9E21-F70A637C4EA4}", IAgCrdnConditionPointInVolume)
agcls.AgTypeNameMap["IAgCrdnConditionPointInVolume"] = IAgCrdnConditionPointInVolume

class IAgCrdnConditionScalarBounds(object):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FE3FB52B-9784-4707-8266-28F1E13B79D1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Scalar" : 1,
                             "set_Scalar" : 2,
                             "get_Operation" : 3,
                             "set_Operation" : 4,
                             "GetMinimum" : 5,
                             "SetMinimum" : 6,
                             "GetMaximum" : 7,
                             "SetMaximum" : 8,
                             "Set" : 9,
                             "GetMinimumUnitless" : 10,
                             "SetMinimumUnitless" : 11,
                             "GetMaximumUnitless" : 12,
                             "SetMaximumUnitless" : 13,
                             "SetUnitless" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionScalarBounds._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionScalarBounds from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionScalarBounds.__dict__ and type(IAgCrdnConditionScalarBounds.__dict__[attrname]) == property:
            return IAgCrdnConditionScalarBounds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionScalarBounds.")
    
    _get_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """Get the scalar calculation from the condition."""
        return self._intf.get_property(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._get_Scalar_metadata)

    _set_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._set_Scalar_metadata, scalar)

    _get_Operation_metadata = { "name" : "Operation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption),) }
    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        return self._intf.get_property(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._get_Operation_metadata)

    _set_Operation_metadata = { "name" : "Operation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption),) }
    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        return self._intf.set_property(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._set_Operation_metadata, operation)

    _GetMinimum_metadata = { "name" : "GetMinimum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetMinimum(self) -> "IAgQuantity":
        """Get the minimum bound value from the condition. Call SetMinimum to apply changes."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._GetMinimum_metadata, out_arg())

    _SetMinimum_metadata = { "name" : "SetMinimum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    def SetMinimum(self, value:"IAgQuantity") -> None:
        """Set the minimum bound value for the condition."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._SetMinimum_metadata, value)

    _GetMaximum_metadata = { "name" : "GetMaximum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetMaximum(self) -> "IAgQuantity":
        """Get the maximum bound value from the condition. Call SetMaximum to apply changes."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._GetMaximum_metadata, out_arg())

    _SetMaximum_metadata = { "name" : "SetMaximum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    def SetMaximum(self, value:"IAgQuantity") -> None:
        """Set the maximum bound value for the condition."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._SetMaximum_metadata, value)

    _Set_metadata = { "name" : "Set",
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    def Set(self, min:"IAgQuantity", max:"IAgQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._Set_metadata, min, max)

    _GetMinimumUnitless_metadata = { "name" : "GetMinimumUnitless",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def GetMinimumUnitless(self) -> float:
        """Get the unitless minimum bound value from the condition. Call SetMinimum to apply changes."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._GetMinimumUnitless_metadata, out_arg())

    _SetMinimumUnitless_metadata = { "name" : "SetMinimumUnitless",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def SetMinimumUnitless(self, value:float) -> None:
        """Set the unitless minimum bound value for the condition."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._SetMinimumUnitless_metadata, value)

    _GetMaximumUnitless_metadata = { "name" : "GetMaximumUnitless",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def GetMaximumUnitless(self) -> float:
        """Get the unitless maximum bound value from the condition. Call SetMaximum to apply changes."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._GetMaximumUnitless_metadata, out_arg())

    _SetMaximumUnitless_metadata = { "name" : "SetMaximumUnitless",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def SetMaximumUnitless(self, value:float) -> None:
        """Set the unitless maximum bound value for the condition."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._SetMaximumUnitless_metadata, value)

    _SetUnitless_metadata = { "name" : "SetUnitless",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def SetUnitless(self, min:float, max:float) -> None:
        """Set the unitless min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(IAgCrdnConditionScalarBounds._metadata, IAgCrdnConditionScalarBounds._SetUnitless_metadata, min, max)


agcls.AgClassCatalog.add_catalog_entry("{FE3FB52B-9784-4707-8266-28F1E13B79D1}", IAgCrdnConditionScalarBounds)
agcls.AgTypeNameMap["IAgCrdnConditionScalarBounds"] = IAgCrdnConditionScalarBounds

class IAgCrdnConditionSet(object):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "Evaluate" : 2,
                             "EvaluateWithRate" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionSet._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionSet from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSet.__dict__ and type(IAgCrdnConditionSet.__dict__[attrname]) == property:
            return IAgCrdnConditionSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionSet.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionSetType),) }
    @property
    def Type(self) -> "AgECrdnConditionSetType":
        """Returns the type of condition set."""
        return self._intf.get_property(IAgCrdnConditionSet._metadata, IAgCrdnConditionSet._get_Type_metadata)

    _Evaluate_metadata = { "name" : "Evaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Evaluate(self, epoch:typing.Any) -> "IAgCrdnConditionSetEvaluateResult":
        """Returns an array of results of evaluating continuously varying condition metrics, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(IAgCrdnConditionSet._metadata, IAgCrdnConditionSet._Evaluate_metadata, epoch, out_arg())

    _EvaluateWithRate_metadata = { "name" : "EvaluateWithRate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def EvaluateWithRate(self, epoch:typing.Any) -> "IAgCrdnConditionSetEvaluateWithRateResult":
        """Returns an array of results of evaluating continuously varying condition metrics and their rates of change, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(IAgCrdnConditionSet._metadata, IAgCrdnConditionSet._EvaluateWithRate_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}", IAgCrdnConditionSet)
agcls.AgTypeNameMap["IAgCrdnConditionSet"] = IAgCrdnConditionSet

class IAgCrdnConditionSetFactory(object):
    """The factory creates condition set components."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{698D592C-B264-426D-8577-AC7087E3EE44}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateScalarThresholds" : 2,
                             "IsTypeSupported" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionSetFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionSetFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetFactory.__dict__ and type(IAgCrdnConditionSetFactory.__dict__[attrname]) == property:
            return IAgCrdnConditionSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionSetFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnConditionSetType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnConditionSetType") -> "IAgCrdnConditionSet":
        """Creates and registers a condition set using specified name, description, and type."""
        return self._intf.invoke(IAgCrdnConditionSetFactory._metadata, IAgCrdnConditionSetFactory._Create_metadata, name, description, type, out_arg())

    _CreateScalarThresholds_metadata = { "name" : "CreateScalarThresholds",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateScalarThresholds(self, name:str, description:str) -> "IAgCrdnConditionSet":
        """Create a scalar thresholds condition set."""
        return self._intf.invoke(IAgCrdnConditionSetFactory._metadata, IAgCrdnConditionSetFactory._CreateScalarThresholds_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionSetType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnConditionSetType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnConditionSetFactory._metadata, IAgCrdnConditionSetFactory._IsTypeSupported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{698D592C-B264-426D-8577-AC7087E3EE44}", IAgCrdnConditionSetFactory)
agcls.AgTypeNameMap["IAgCrdnConditionSetFactory"] = IAgCrdnConditionSetFactory

class IAgCrdnConditionSetScalarThresholds(object):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{57392078-7821-4910-B734-76B5C70CB6D9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Scalar" : 1,
                             "set_Scalar" : 2,
                             "get_Thresholds" : 3,
                             "get_ThresholdLabels" : 4,
                             "get_IncludeAboveHighestThreshold" : 5,
                             "set_IncludeAboveHighestThreshold" : 6,
                             "get_IncludeBelowLowestThreshold" : 7,
                             "set_IncludeBelowLowestThreshold" : 8,
                             "SetThresholdsAndLabels" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConditionSetScalarThresholds._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConditionSetScalarThresholds from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetScalarThresholds.__dict__ and type(IAgCrdnConditionSetScalarThresholds.__dict__[attrname]) == property:
            return IAgCrdnConditionSetScalarThresholds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConditionSetScalarThresholds.")
    
    _get_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar calculation."""
        return self._intf.get_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._get_Scalar_metadata)

    _set_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._set_Scalar_metadata, scalar)

    _get_Thresholds_metadata = { "name" : "Thresholds",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Thresholds(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        return self._intf.get_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._get_Thresholds_metadata)

    _get_ThresholdLabels_metadata = { "name" : "ThresholdLabels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def ThresholdLabels(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        return self._intf.get_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._get_ThresholdLabels_metadata)

    _get_IncludeAboveHighestThreshold_metadata = { "name" : "IncludeAboveHighestThreshold",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IncludeAboveHighestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions above the highest threhsold."""
        return self._intf.get_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._get_IncludeAboveHighestThreshold_metadata)

    _set_IncludeAboveHighestThreshold_metadata = { "name" : "IncludeAboveHighestThreshold",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IncludeAboveHighestThreshold.setter
    def IncludeAboveHighestThreshold(self, includeAboveHighestThreshold:bool) -> None:
        return self._intf.set_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._set_IncludeAboveHighestThreshold_metadata, includeAboveHighestThreshold)

    _get_IncludeBelowLowestThreshold_metadata = { "name" : "IncludeBelowLowestThreshold",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IncludeBelowLowestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions below the lowest threhsolds."""
        return self._intf.get_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._get_IncludeBelowLowestThreshold_metadata)

    _set_IncludeBelowLowestThreshold_metadata = { "name" : "IncludeBelowLowestThreshold",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IncludeBelowLowestThreshold.setter
    def IncludeBelowLowestThreshold(self, includeBelowLowestThreshold:bool) -> None:
        return self._intf.set_property(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._set_IncludeBelowLowestThreshold_metadata, includeBelowLowestThreshold)

    _SetThresholdsAndLabels_metadata = { "name" : "SetThresholdsAndLabels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def SetThresholdsAndLabels(self, thresholds:list, thresholdLabels:list) -> None:
        """Set thresholds and threshold labels."""
        return self._intf.invoke(IAgCrdnConditionSetScalarThresholds._metadata, IAgCrdnConditionSetScalarThresholds._SetThresholdsAndLabels_metadata, thresholds, thresholdLabels)


agcls.AgClassCatalog.add_catalog_entry("{57392078-7821-4910-B734-76B5C70CB6D9}", IAgCrdnConditionSetScalarThresholds)
agcls.AgTypeNameMap["IAgCrdnConditionSetScalarThresholds"] = IAgCrdnConditionSetScalarThresholds

class IAgCrdnConverge(object):
    """Represents a base class for convergence definitions."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{28B17124-9BE6-4437-A7ED-0DDC24353430}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConverge._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConverge from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConverge.__dict__ and type(IAgCrdnConverge.__dict__[attrname]) == property:
            return IAgCrdnConverge.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConverge.")
    

agcls.AgClassCatalog.add_catalog_entry("{28B17124-9BE6-4437-A7ED-0DDC24353430}", IAgCrdnConverge)
agcls.AgTypeNameMap["IAgCrdnConverge"] = IAgCrdnConverge

class IAgCrdnConvergeBasic(object):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Sense" : 1,
                             "set_Sense" : 2,
                             "get_TimeTolerance" : 3,
                             "set_TimeTolerance" : 4,
                             "get_AbsoluteTolerance" : 5,
                             "set_AbsoluteTolerance" : 6,
                             "get_RelativeTolerance" : 7,
                             "set_RelativeTolerance" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnConvergeBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnConvergeBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConvergeBasic.__dict__ and type(IAgCrdnConvergeBasic.__dict__[attrname]) == property:
            return IAgCrdnConvergeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnConvergeBasic.")
    
    _get_Sense_metadata = { "name" : "Sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense),) }
    @property
    def Sense(self) -> "AgECrdnThreshConvergeSense":
        """Get the convergence sense which determines whether the converged value should be limited to just within or just outside of condition boundaries."""
        return self._intf.get_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._get_Sense_metadata)

    _set_Sense_metadata = { "name" : "Sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense),) }
    @Sense.setter
    def Sense(self, sense:"AgECrdnThreshConvergeSense") -> None:
        return self._intf.set_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._set_Sense_metadata, sense)

    _get_TimeTolerance_metadata = { "name" : "TimeTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeTolerance(self) -> float:
        """Get the time tolerance which determines the time accuracy of the converged value."""
        return self._intf.get_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._get_TimeTolerance_metadata)

    _set_TimeTolerance_metadata = { "name" : "TimeTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeTolerance.setter
    def TimeTolerance(self, timeTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._set_TimeTolerance_metadata, timeTolerance)

    _get_AbsoluteTolerance_metadata = { "name" : "AbsoluteTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines the distance between the value and the boundaries within which the value is considered converged."""
        return self._intf.get_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._get_AbsoluteTolerance_metadata)

    _set_AbsoluteTolerance_metadata = { "name" : "AbsoluteTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._set_AbsoluteTolerance_metadata, absoluteTolerance)

    _get_RelativeTolerance_metadata = { "name" : "RelativeTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines the relative distance between the value and the boundaries within which the value is considered converged."""
        return self._intf.get_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._get_RelativeTolerance_metadata)

    _set_RelativeTolerance_metadata = { "name" : "RelativeTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnConvergeBasic._metadata, IAgCrdnConvergeBasic._set_RelativeTolerance_metadata, relativeTolerance)


agcls.AgClassCatalog.add_catalog_entry("{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}", IAgCrdnConvergeBasic)
agcls.AgTypeNameMap["IAgCrdnConvergeBasic"] = IAgCrdnConvergeBasic

class IAgCrdnDerivative(object):
    """Represents a base class for derivative definitions."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{737042BD-D873-4CF6-B5D5-6769849156FD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnDerivative._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnDerivative from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnDerivative.__dict__ and type(IAgCrdnDerivative.__dict__[attrname]) == property:
            return IAgCrdnDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnDerivative.")
    

agcls.AgClassCatalog.add_catalog_entry("{737042BD-D873-4CF6-B5D5-6769849156FD}", IAgCrdnDerivative)
agcls.AgTypeNameMap["IAgCrdnDerivative"] = IAgCrdnDerivative

class IAgCrdnDerivativeBasic(object):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CD450BBA-9F54-4F15-B067-C5A80C970FA9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TimeStep" : 1,
                             "set_TimeStep" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnDerivativeBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnDerivativeBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnDerivativeBasic.__dict__ and type(IAgCrdnDerivativeBasic.__dict__[attrname]) == property:
            return IAgCrdnDerivativeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnDerivativeBasic.")
    
    _get_TimeStep_metadata = { "name" : "TimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeStep(self) -> float:
        """Get the time step used for numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IAgCrdnDerivativeBasic._metadata, IAgCrdnDerivativeBasic._get_TimeStep_metadata)

    _set_TimeStep_metadata = { "name" : "TimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        return self._intf.set_property(IAgCrdnDerivativeBasic._metadata, IAgCrdnDerivativeBasic._set_TimeStep_metadata, timeStep)


agcls.AgClassCatalog.add_catalog_entry("{CD450BBA-9F54-4F15-B067-C5A80C970FA9}", IAgCrdnDerivativeBasic)
agcls.AgTypeNameMap["IAgCrdnDerivativeBasic"] = IAgCrdnDerivativeBasic

class IAgCrdnEvent(object):
    """Defines an event (time instant)."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "get_Today" : 2,
                             "get_Tomorrow" : 3,
                             "get_NoonToday" : 4,
                             "get_NoonTomorrow" : 5,
                             "FindOccurrence" : 6,
                             "OccursBefore" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEvent._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEvent from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEvent.__dict__ and type(IAgCrdnEvent.__dict__[attrname]) == property:
            return IAgCrdnEvent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEvent.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventType),) }
    @property
    def Type(self) -> "AgECrdnEventType":
        """Return the type of time instant."""
        return self._intf.get_property(IAgCrdnEvent._metadata, IAgCrdnEvent._get_Type_metadata)

    _get_Today_metadata = { "name" : "Today",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Today(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to today's GMT midnight."""
        return self._intf.get_property(IAgCrdnEvent._metadata, IAgCrdnEvent._get_Today_metadata)

    _get_Tomorrow_metadata = { "name" : "Tomorrow",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Tomorrow(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to tomorrow's GMT midnight."""
        return self._intf.get_property(IAgCrdnEvent._metadata, IAgCrdnEvent._get_Tomorrow_metadata)

    _get_NoonToday_metadata = { "name" : "NoonToday",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def NoonToday(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to today's GMT noon."""
        return self._intf.get_property(IAgCrdnEvent._metadata, IAgCrdnEvent._get_NoonToday_metadata)

    _get_NoonTomorrow_metadata = { "name" : "NoonTomorrow",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def NoonTomorrow(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to tomorrow's GMT noon."""
        return self._intf.get_property(IAgCrdnEvent._metadata, IAgCrdnEvent._get_NoonTomorrow_metadata)

    _FindOccurrence_metadata = { "name" : "FindOccurrence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def FindOccurrence(self) -> "IAgCrdnEventFindOccurrenceResult":
        """Return computed time instance if it occurs."""
        return self._intf.invoke(IAgCrdnEvent._metadata, IAgCrdnEvent._FindOccurrence_metadata, out_arg())

    _OccursBefore_metadata = { "name" : "OccursBefore",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def OccursBefore(self, epoch:typing.Any) -> bool:
        """Return true if computed time instance occurs before or at specified time, return false otherwise."""
        return self._intf.invoke(IAgCrdnEvent._metadata, IAgCrdnEvent._OccursBefore_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}", IAgCrdnEvent)
agcls.AgTypeNameMap["IAgCrdnEvent"] = IAgCrdnEvent

class IAgCrdnEventArray(object):
    """An ordered array of times, which may or may not be evenly spaced."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "FindTimes" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArray._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArray from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArray.__dict__ and type(IAgCrdnEventArray.__dict__[attrname]) == property:
            return IAgCrdnEventArray.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArray.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventArrayType),) }
    @property
    def Type(self) -> "AgECrdnEventArrayType":
        """Return the type of time array."""
        return self._intf.get_property(IAgCrdnEventArray._metadata, IAgCrdnEventArray._get_Type_metadata)

    _FindTimes_metadata = { "name" : "FindTimes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def FindTimes(self) -> "IAgCrdnFindTimesResult":
        """Return computed array of times."""
        return self._intf.invoke(IAgCrdnEventArray._metadata, IAgCrdnEventArray._FindTimes_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}", IAgCrdnEventArray)
agcls.AgTypeNameMap["IAgCrdnEventArray"] = IAgCrdnEventArray

class IAgCrdnEventArrayConditionCrossings(object):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SatisfactionCrossing" : 1,
                             "set_SatisfactionCrossing" : 2,
                             "get_Condition" : 3,
                             "set_Condition" : 4,
                             "get_CustomTimeLimits" : 5,
                             "set_CustomTimeLimits" : 6,
                             "get_UseCustomTimeLimits" : 7,
                             "set_UseCustomTimeLimits" : 8,
                             "get_SaveDataOption" : 9,
                             "set_SaveDataOption" : 10,
                             "get_Sampling" : 11,
                             "set_Sampling" : 12,
                             "get_Convergence" : 13,
                             "set_Convergence" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayConditionCrossings._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayConditionCrossings from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayConditionCrossings.__dict__ and type(IAgCrdnEventArrayConditionCrossings.__dict__[attrname]) == property:
            return IAgCrdnEventArrayConditionCrossings.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayConditionCrossings.")
    
    _get_SatisfactionCrossing_metadata = { "name" : "SatisfactionCrossing",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing),) }
    @property
    def SatisfactionCrossing(self) -> "AgECrdnSatisfactionCrossing":
        """The direction of interest for satisfaction crossing."""
        return self._intf.get_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._get_SatisfactionCrossing_metadata)

    _set_SatisfactionCrossing_metadata = { "name" : "SatisfactionCrossing",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing),) }
    @SatisfactionCrossing.setter
    def SatisfactionCrossing(self, satisfactionCrossing:"AgECrdnSatisfactionCrossing") -> None:
        return self._intf.set_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._set_SatisfactionCrossing_metadata, satisfactionCrossing)

    _get_Condition_metadata = { "name" : "Condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """The condition component."""
        return self._intf.get_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._get_Condition_metadata)

    _set_Condition_metadata = { "name" : "Condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCondition"),) }
    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        return self._intf.set_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._set_Condition_metadata, condition)

    _get_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """Specify the interval list within which satisfaction crossing times are sought. The default is set to overall availability of host object. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._get_CustomTimeLimits_metadata)

    _set_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._set_CustomTimeLimits_metadata, customTimeLimits)

    _get_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._get_UseCustomTimeLimits_metadata)

    _set_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._set_UseCustomTimeLimits_metadata, useCustomTimeLimits)

    _get_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed satisfaction crossing times are saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._get_SaveDataOption_metadata)

    _set_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        return self._intf.set_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._set_SaveDataOption_metadata, saveDataOption)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._set_Sampling_metadata, sampling)

    _get_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when crossing times are found."""
        return self._intf.get_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._get_Convergence_metadata)

    _set_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConverge"),) }
    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        return self._intf.set_property(IAgCrdnEventArrayConditionCrossings._metadata, IAgCrdnEventArrayConditionCrossings._set_Convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}", IAgCrdnEventArrayConditionCrossings)
agcls.AgTypeNameMap["IAgCrdnEventArrayConditionCrossings"] = IAgCrdnEventArrayConditionCrossings

class IAgCrdnEventArrayExtrema(object):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{664C3048-BB87-4841-988A-0580F2976C0D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ExtremumType" : 1,
                             "set_ExtremumType" : 2,
                             "get_IsGlobal" : 3,
                             "set_IsGlobal" : 4,
                             "get_Calculation" : 5,
                             "set_Calculation" : 6,
                             "get_CustomTimeLimits" : 7,
                             "set_CustomTimeLimits" : 8,
                             "get_UseCustomTimeLimits" : 9,
                             "set_UseCustomTimeLimits" : 10,
                             "get_SaveDataOption" : 11,
                             "set_SaveDataOption" : 12,
                             "get_Sampling" : 13,
                             "set_Sampling" : 14,
                             "get_Convergence" : 15,
                             "set_Convergence" : 16, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayExtrema._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayExtrema from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayExtrema.__dict__ and type(IAgCrdnEventArrayExtrema.__dict__[attrname]) == property:
            return IAgCrdnEventArrayExtrema.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayExtrema.")
    
    _get_ExtremumType_metadata = { "name" : "ExtremumType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnExtremumConstants),) }
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_ExtremumType_metadata)

    _set_ExtremumType_metadata = { "name" : "ExtremumType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnExtremumConstants),) }
    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_ExtremumType_metadata, extremumType)

    _get_IsGlobal_metadata = { "name" : "IsGlobal",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsGlobal(self) -> bool:
        """Indicates whether to perform local or global search. The default is false."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_IsGlobal_metadata)

    _set_IsGlobal_metadata = { "name" : "IsGlobal",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IsGlobal.setter
    def IsGlobal(self, isGlobal:bool) -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_IsGlobal_metadata, isGlobal)

    _get_Calculation_metadata = { "name" : "Calculation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Calculation(self) -> "IAgCrdnCalcScalar":
        """The scalar calculation."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_Calculation_metadata)

    _set_Calculation_metadata = { "name" : "Calculation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @Calculation.setter
    def Calculation(self, calculation:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_Calculation_metadata, calculation)

    _get_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_CustomTimeLimits_metadata)

    _set_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_CustomTimeLimits_metadata, customTimeLimits)

    _get_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_UseCustomTimeLimits_metadata)

    _set_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_UseCustomTimeLimits_metadata, useCustomTimeLimits)

    _get_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Specify whether computed times of extrema are saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_SaveDataOption_metadata)

    _set_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_SaveDataOption_metadata, saveDataOption)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_Sampling_metadata, sampling)

    _get_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        return self._intf.get_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._get_Convergence_metadata)

    _set_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConverge"),) }
    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        return self._intf.set_property(IAgCrdnEventArrayExtrema._metadata, IAgCrdnEventArrayExtrema._set_Convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{664C3048-BB87-4841-988A-0580F2976C0D}", IAgCrdnEventArrayExtrema)
agcls.AgTypeNameMap["IAgCrdnEventArrayExtrema"] = IAgCrdnEventArrayExtrema

class IAgCrdnEventArrayFactory(object):
    """The factory creates event arrays."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CE43C07E-4626-4CEA-A625-C42052111CDE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateEventArrayExtrema" : 2,
                             "CreateEventArrayStartStopTimes" : 3,
                             "CreateEventArrayMerged" : 4,
                             "CreateEventArrayFiltered" : 5,
                             "CreateEventArrayFixedStep" : 6,
                             "CreateEventArrayConditionCrossings" : 7,
                             "CreateEventArraySignaled" : 8,
                             "IsTypeSupported" : 9,
                             "CreateEventArrayFixedTimes" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFactory.__dict__ and type(IAgCrdnEventArrayFactory.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnEventArrayType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnEventArrayType") -> "IAgCrdnEventArray":
        """Create and register an event array using specified name, description, and type."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._Create_metadata, name, description, type, out_arg())

    _CreateEventArrayExtrema_metadata = { "name" : "CreateEventArrayExtrema",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArrayExtrema(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by determining times of local minimum and/or maximum of specified scalar calculation."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArrayExtrema_metadata, name, description, out_arg())

    _CreateEventArrayStartStopTimes_metadata = { "name" : "CreateEventArrayStartStopTimes",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArrayStartStopTimes(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by taking start and/or stop times of every interval in the specified reference interval list and adding them to array."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArrayStartStopTimes_metadata, name, description, out_arg())

    _CreateEventArrayMerged_metadata = { "name" : "CreateEventArrayMerged",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArrayMerged(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArrayMerged_metadata, name, description, out_arg())

    _CreateEventArrayFiltered_metadata = { "name" : "CreateEventArrayFiltered",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArrayFiltered(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by filtering times from an original time array according to specified filtering method."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArrayFiltered_metadata, name, description, out_arg())

    _CreateEventArrayFixedStep_metadata = { "name" : "CreateEventArrayFixedStep",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArrayFixedStep(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array using fixed time steps from the specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArrayFixedStep_metadata, name, description, out_arg())

    _CreateEventArrayConditionCrossings_metadata = { "name" : "CreateEventArrayConditionCrossings",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArrayConditionCrossings(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array containing times at which the specified condition will change its satisfaction status."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArrayConditionCrossings_metadata, name, description, out_arg())

    _CreateEventArraySignaled_metadata = { "name" : "CreateEventArraySignaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArraySignaled(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArraySignaled_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventArrayType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnEventArrayType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._IsTypeSupported_metadata, eType, out_arg())

    _CreateEventArrayFixedTimes_metadata = { "name" : "CreateEventArrayFixedTimes",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventArrayFixedTimes(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array using specified times."""
        return self._intf.invoke(IAgCrdnEventArrayFactory._metadata, IAgCrdnEventArrayFactory._CreateEventArrayFixedTimes_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{CE43C07E-4626-4CEA-A625-C42052111CDE}", IAgCrdnEventArrayFactory)
agcls.AgTypeNameMap["IAgCrdnEventArrayFactory"] = IAgCrdnEventArrayFactory

class IAgCrdnEventArrayFiltered(object):
    """Defined by filtering times from original time array according to specified filtering method."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalTimeArray" : 1,
                             "set_OriginalTimeArray" : 2,
                             "get_FilterType" : 3,
                             "set_FilterType" : 4,
                             "get_Count" : 5,
                             "set_Count" : 6,
                             "get_Step" : 7,
                             "set_Step" : 8,
                             "get_IncludeIntervalStopTimes" : 9,
                             "set_IncludeIntervalStopTimes" : 10,
                             "get_FilterIntervalList" : 11,
                             "set_FilterIntervalList" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayFiltered._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayFiltered from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFiltered.__dict__ and type(IAgCrdnEventArrayFiltered.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayFiltered.")
    
    _get_OriginalTimeArray_metadata = { "name" : "OriginalTimeArray",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalTimeArray(self) -> "IAgCrdnEventArray":
        """The original time array."""
        return self._intf.get_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._get_OriginalTimeArray_metadata)

    _set_OriginalTimeArray_metadata = { "name" : "OriginalTimeArray",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventArray"),) }
    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"IAgCrdnEventArray") -> None:
        return self._intf.set_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._set_OriginalTimeArray_metadata, originalTimeArray)

    _get_FilterType_metadata = { "name" : "FilterType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType),) }
    @property
    def FilterType(self) -> "AgECrdnEventArrayFilterType":
        """Skip Time Steps filter type omits from filtered time array any times that fall within specified time step of last accepted time sample. Skip Count filter type omits specified number of time samples since last accepted time sample..."""
        return self._intf.get_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._get_FilterType_metadata)

    _set_FilterType_metadata = { "name" : "FilterType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType),) }
    @FilterType.setter
    def FilterType(self, filterType:"AgECrdnEventArrayFilterType") -> None:
        return self._intf.set_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._set_FilterType_metadata, filterType)

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def Count(self) -> int:
        """Specify the number of times skipped between accepted samples when FilterType is set to Skip Count..."""
        return self._intf.get_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._get_Count_metadata)

    _set_Count_metadata = { "name" : "Count",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @Count.setter
    def Count(self, count:int) -> None:
        return self._intf.set_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._set_Count_metadata, count)

    _get_Step_metadata = { "name" : "Step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Step(self) -> float:
        """The number of steps skipped between accepted samples when FilterType is set to Skip Time Steps."""
        return self._intf.get_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._get_Step_metadata)

    _set_Step_metadata = { "name" : "Step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Step.setter
    def Step(self, step:float) -> None:
        return self._intf.set_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._set_Step_metadata, step)

    _get_IncludeIntervalStopTimes_metadata = { "name" : "IncludeIntervalStopTimes",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IncludeIntervalStopTimes(self) -> bool:
        """If set to true, includes stop times of each interval from original time array."""
        return self._intf.get_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._get_IncludeIntervalStopTimes_metadata)

    _set_IncludeIntervalStopTimes_metadata = { "name" : "IncludeIntervalStopTimes",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IncludeIntervalStopTimes.setter
    def IncludeIntervalStopTimes(self, includeIntervalStopTimes:bool) -> None:
        return self._intf.set_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._set_IncludeIntervalStopTimes_metadata, includeIntervalStopTimes)

    _get_FilterIntervalList_metadata = { "name" : "FilterIntervalList",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FilterIntervalList(self) -> "IAgCrdnEventIntervalList":
        """The interval list used to filter samples when FilterType is set to Skip Intervals."""
        return self._intf.get_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._get_FilterIntervalList_metadata)

    _set_FilterIntervalList_metadata = { "name" : "FilterIntervalList",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @FilterIntervalList.setter
    def FilterIntervalList(self, filterIntervalList:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventArrayFiltered._metadata, IAgCrdnEventArrayFiltered._set_FilterIntervalList_metadata, filterIntervalList)


agcls.AgClassCatalog.add_catalog_entry("{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}", IAgCrdnEventArrayFiltered)
agcls.AgTypeNameMap["IAgCrdnEventArrayFiltered"] = IAgCrdnEventArrayFiltered

class IAgCrdnEventArrayFixedStep(object):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_BoundingIntervalList" : 1,
                             "set_BoundingIntervalList" : 2,
                             "get_SamplingTimeStep" : 3,
                             "set_SamplingTimeStep" : 4,
                             "get_IncludeIntervalEdges" : 5,
                             "set_IncludeIntervalEdges" : 6,
                             "get_ReferenceType" : 7,
                             "set_ReferenceType" : 8,
                             "get_ReferenceTimeInstant" : 9,
                             "set_ReferenceTimeInstant" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayFixedStep._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayFixedStep from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFixedStep.__dict__ and type(IAgCrdnEventArrayFixedStep.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayFixedStep.")
    
    _get_BoundingIntervalList_metadata = { "name" : "BoundingIntervalList",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def BoundingIntervalList(self) -> "IAgCrdnEventIntervalList":
        """The bounding interval list."""
        return self._intf.get_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._get_BoundingIntervalList_metadata)

    _set_BoundingIntervalList_metadata = { "name" : "BoundingIntervalList",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @BoundingIntervalList.setter
    def BoundingIntervalList(self, boundingIntervalList:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._set_BoundingIntervalList_metadata, boundingIntervalList)

    _get_SamplingTimeStep_metadata = { "name" : "SamplingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def SamplingTimeStep(self) -> float:
        """The sampling time step."""
        return self._intf.get_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._get_SamplingTimeStep_metadata)

    _set_SamplingTimeStep_metadata = { "name" : "SamplingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @SamplingTimeStep.setter
    def SamplingTimeStep(self, samplingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._set_SamplingTimeStep_metadata, samplingTimeStep)

    _get_IncludeIntervalEdges_metadata = { "name" : "IncludeIntervalEdges",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IncludeIntervalEdges(self) -> bool:
        """Specify whether to include interval edges."""
        return self._intf.get_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._get_IncludeIntervalEdges_metadata)

    _set_IncludeIntervalEdges_metadata = { "name" : "IncludeIntervalEdges",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IncludeIntervalEdges.setter
    def IncludeIntervalEdges(self, includeIntervalEdges:bool) -> None:
        return self._intf.set_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._set_IncludeIntervalEdges_metadata, includeIntervalEdges)

    _get_ReferenceType_metadata = { "name" : "ReferenceType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime),) }
    @property
    def ReferenceType(self) -> "AgECrdnSampledReferenceTime":
        """Specify the time reference from which fixed sampling time steps are taken. Note: selecting Start/Stop of each Interval resets the time reference for each interval, whereas other types maintain single reference for entire array."""
        return self._intf.get_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._get_ReferenceType_metadata)

    _set_ReferenceType_metadata = { "name" : "ReferenceType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime),) }
    @ReferenceType.setter
    def ReferenceType(self, referenceType:"AgECrdnSampledReferenceTime") -> None:
        return self._intf.set_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._set_ReferenceType_metadata, referenceType)

    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant. Only applicable if the ReferenceType is set to time instant."""
        return self._intf.get_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnEventArrayFixedStep._metadata, IAgCrdnEventArrayFixedStep._set_ReferenceTimeInstant_metadata, referenceTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}", IAgCrdnEventArrayFixedStep)
agcls.AgTypeNameMap["IAgCrdnEventArrayFixedStep"] = IAgCrdnEventArrayFixedStep

class IAgCrdnEventArrayFixedTimes(object):
    """Array defined by time ordered instants each explicitly specified."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ArrayTimes" : 1,
                             "SetArrayTimes" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayFixedTimes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayFixedTimes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFixedTimes.__dict__ and type(IAgCrdnEventArrayFixedTimes.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFixedTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayFixedTimes.")
    
    _get_ArrayTimes_metadata = { "name" : "ArrayTimes",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def ArrayTimes(self) -> list:
        """The array of times."""
        return self._intf.get_property(IAgCrdnEventArrayFixedTimes._metadata, IAgCrdnEventArrayFixedTimes._get_ArrayTimes_metadata)

    _SetArrayTimes_metadata = { "name" : "SetArrayTimes",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def SetArrayTimes(self, times:list) -> None:
        """Sets array of times."""
        return self._intf.invoke(IAgCrdnEventArrayFixedTimes._metadata, IAgCrdnEventArrayFixedTimes._SetArrayTimes_metadata, times)


agcls.AgClassCatalog.add_catalog_entry("{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}", IAgCrdnEventArrayFixedTimes)
agcls.AgTypeNameMap["IAgCrdnEventArrayFixedTimes"] = IAgCrdnEventArrayFixedTimes

class IAgCrdnEventArrayMerged(object):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TimeArrayA" : 1,
                             "set_TimeArrayA" : 2,
                             "get_TimeArrayB" : 3,
                             "set_TimeArrayB" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayMerged._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayMerged from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayMerged.__dict__ and type(IAgCrdnEventArrayMerged.__dict__[attrname]) == property:
            return IAgCrdnEventArrayMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayMerged.")
    
    _get_TimeArrayA_metadata = { "name" : "TimeArrayA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TimeArrayA(self) -> "IAgCrdnEventArray":
        """The first time array."""
        return self._intf.get_property(IAgCrdnEventArrayMerged._metadata, IAgCrdnEventArrayMerged._get_TimeArrayA_metadata)

    _set_TimeArrayA_metadata = { "name" : "TimeArrayA",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventArray"),) }
    @TimeArrayA.setter
    def TimeArrayA(self, timeArrayA:"IAgCrdnEventArray") -> None:
        return self._intf.set_property(IAgCrdnEventArrayMerged._metadata, IAgCrdnEventArrayMerged._set_TimeArrayA_metadata, timeArrayA)

    _get_TimeArrayB_metadata = { "name" : "TimeArrayB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TimeArrayB(self) -> "IAgCrdnEventArray":
        """The second time array."""
        return self._intf.get_property(IAgCrdnEventArrayMerged._metadata, IAgCrdnEventArrayMerged._get_TimeArrayB_metadata)

    _set_TimeArrayB_metadata = { "name" : "TimeArrayB",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventArray"),) }
    @TimeArrayB.setter
    def TimeArrayB(self, timeArrayB:"IAgCrdnEventArray") -> None:
        return self._intf.set_property(IAgCrdnEventArrayMerged._metadata, IAgCrdnEventArrayMerged._set_TimeArrayB_metadata, timeArrayB)


agcls.AgClassCatalog.add_catalog_entry("{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}", IAgCrdnEventArrayMerged)
agcls.AgTypeNameMap["IAgCrdnEventArrayMerged"] = IAgCrdnEventArrayMerged

class IAgCrdnEventArraySignaled(object):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalTimeArray" : 1,
                             "set_OriginalTimeArray" : 2,
                             "get_SignalSense" : 3,
                             "set_SignalSense" : 4,
                             "get_BaseClockLocation" : 5,
                             "set_BaseClockLocation" : 6,
                             "get_TargetClockLocation" : 7,
                             "set_TargetClockLocation" : 8,
                             "get_SignalDelay" : 9,
                             "set_SignalDelay" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArraySignaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArraySignaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArraySignaled.__dict__ and type(IAgCrdnEventArraySignaled.__dict__[attrname]) == property:
            return IAgCrdnEventArraySignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArraySignaled.")
    
    _get_OriginalTimeArray_metadata = { "name" : "OriginalTimeArray",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalTimeArray(self) -> "IAgCrdnEventArray":
        """The original time array."""
        return self._intf.get_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._get_OriginalTimeArray_metadata)

    _set_OriginalTimeArray_metadata = { "name" : "OriginalTimeArray",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventArray"),) }
    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"IAgCrdnEventArray") -> None:
        return self._intf.set_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._set_OriginalTimeArray_metadata, originalTimeArray)

    _get_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._get_SignalSense_metadata)

    _set_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        return self._intf.set_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._set_SignalSense_metadata, signalSense)

    _get_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._get_BaseClockLocation_metadata)

    _set_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._set_BaseClockLocation_metadata, baseClockLocation)

    _get_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._get_TargetClockLocation_metadata)

    _set_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._set_TargetClockLocation_metadata, targetClockLocation)

    _get_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._get_SignalDelay_metadata)

    _set_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSignalDelay"),) }
    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        return self._intf.set_property(IAgCrdnEventArraySignaled._metadata, IAgCrdnEventArraySignaled._set_SignalDelay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}", IAgCrdnEventArraySignaled)
agcls.AgTypeNameMap["IAgCrdnEventArraySignaled"] = IAgCrdnEventArraySignaled

class IAgCrdnEventArrayStartStopTimes(object):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1AB79442-7711-4342-B944-81C51D14FBE4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_StartStopOption" : 1,
                             "set_StartStopOption" : 2,
                             "get_ReferenceIntervals" : 3,
                             "set_ReferenceIntervals" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventArrayStartStopTimes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventArrayStartStopTimes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayStartStopTimes.__dict__ and type(IAgCrdnEventArrayStartStopTimes.__dict__[attrname]) == property:
            return IAgCrdnEventArrayStartStopTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventArrayStartStopTimes.")
    
    _get_StartStopOption_metadata = { "name" : "StartStopOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnStartStopOption),) }
    @property
    def StartStopOption(self) -> "AgECrdnStartStopOption":
        """The edge type. At least one of the two edge types must be selected."""
        return self._intf.get_property(IAgCrdnEventArrayStartStopTimes._metadata, IAgCrdnEventArrayStartStopTimes._get_StartStopOption_metadata)

    _set_StartStopOption_metadata = { "name" : "StartStopOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnStartStopOption),) }
    @StartStopOption.setter
    def StartStopOption(self, startStopOption:"AgECrdnStartStopOption") -> None:
        return self._intf.set_property(IAgCrdnEventArrayStartStopTimes._metadata, IAgCrdnEventArrayStartStopTimes._set_StartStopOption_metadata, startStopOption)

    _get_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(IAgCrdnEventArrayStartStopTimes._metadata, IAgCrdnEventArrayStartStopTimes._get_ReferenceIntervals_metadata)

    _set_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventArrayStartStopTimes._metadata, IAgCrdnEventArrayStartStopTimes._set_ReferenceIntervals_metadata, referenceIntervals)


agcls.AgClassCatalog.add_catalog_entry("{1AB79442-7711-4342-B944-81C51D14FBE4}", IAgCrdnEventArrayStartStopTimes)
agcls.AgTypeNameMap["IAgCrdnEventArrayStartStopTimes"] = IAgCrdnEventArrayStartStopTimes

class IAgCrdnEventEpoch(object):
    """Event set at specified date/time."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Epoch" : 1,
                             "set_Epoch" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventEpoch._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventEpoch from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventEpoch.__dict__ and type(IAgCrdnEventEpoch.__dict__[attrname]) == property:
            return IAgCrdnEventEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventEpoch.")
    
    _get_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Epoch(self) -> typing.Any:
        """An explicit date/time, set using any STK date format."""
        return self._intf.get_property(IAgCrdnEventEpoch._metadata, IAgCrdnEventEpoch._get_Epoch_metadata)

    _set_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IAgCrdnEventEpoch._metadata, IAgCrdnEventEpoch._set_Epoch_metadata, epoch)


agcls.AgClassCatalog.add_catalog_entry("{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}", IAgCrdnEventEpoch)
agcls.AgTypeNameMap["IAgCrdnEventEpoch"] = IAgCrdnEventEpoch

class IAgCrdnEventExtremum(object):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C588FDD4-2008-4C33-AA63-1C59565AE4F3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ExtremumType" : 1,
                             "set_ExtremumType" : 2,
                             "get_Calculation" : 3,
                             "set_Calculation" : 4,
                             "get_CustomTimeLimits" : 5,
                             "set_CustomTimeLimits" : 6,
                             "get_UseCustomTimeLimits" : 7,
                             "set_UseCustomTimeLimits" : 8,
                             "get_SaveDataOption" : 9,
                             "set_SaveDataOption" : 10,
                             "get_Sampling" : 11,
                             "set_Sampling" : 12,
                             "get_Convergence" : 13,
                             "set_Convergence" : 14, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventExtremum._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventExtremum from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventExtremum.__dict__ and type(IAgCrdnEventExtremum.__dict__[attrname]) == property:
            return IAgCrdnEventExtremum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventExtremum.")
    
    _get_ExtremumType_metadata = { "name" : "ExtremumType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnExtremumConstants),) }
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        return self._intf.get_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._get_ExtremumType_metadata)

    _set_ExtremumType_metadata = { "name" : "ExtremumType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnExtremumConstants),) }
    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        return self._intf.set_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._set_ExtremumType_metadata, extremumType)

    _get_Calculation_metadata = { "name" : "Calculation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Calculation(self) -> "IAgCrdnCalcScalar":
        """The scalar calculation."""
        return self._intf.get_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._get_Calculation_metadata)

    _set_Calculation_metadata = { "name" : "Calculation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @Calculation.setter
    def Calculation(self, calculation:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._set_Calculation_metadata, calculation)

    _get_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._get_CustomTimeLimits_metadata)

    _set_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._set_CustomTimeLimits_metadata, customTimeLimits)

    _get_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._get_UseCustomTimeLimits_metadata)

    _set_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._set_UseCustomTimeLimits_metadata, useCustomTimeLimits)

    _get_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._get_SaveDataOption_metadata)

    _set_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        return self._intf.set_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._set_SaveDataOption_metadata, saveDataOption)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._set_Sampling_metadata, sampling)

    _get_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._get_Convergence_metadata)

    _set_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConverge"),) }
    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        return self._intf.set_property(IAgCrdnEventExtremum._metadata, IAgCrdnEventExtremum._set_Convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{C588FDD4-2008-4C33-AA63-1C59565AE4F3}", IAgCrdnEventExtremum)
agcls.AgTypeNameMap["IAgCrdnEventExtremum"] = IAgCrdnEventExtremum

class IAgCrdnEventFactory(object):
    """The factory creates events."""
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{803DD343-F271-47D9-8D71-2092DD2A3387}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Today" : 1,
                             "get_Tomorrow" : 2,
                             "Create" : 3,
                             "CreateEventEpoch" : 4,
                             "CreateEventExtremum" : 5,
                             "CreateEventStartStopTime" : 6,
                             "CreateEventSignaled" : 7,
                             "CreateEventTimeOffset" : 8,
                             "CreateSmartEpochFromTime" : 9,
                             "CreateSmartEpochFromEvent" : 10,
                             "IsTypeSupported" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventFactory.__dict__ and type(IAgCrdnEventFactory.__dict__[attrname]) == property:
            return IAgCrdnEventFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventFactory.")
    
    _get_Today_metadata = { "name" : "Today",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Today(self) -> "IAgCrdnEvent":
        """Returns Today time instant."""
        return self._intf.get_property(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._get_Today_metadata)

    _get_Tomorrow_metadata = { "name" : "Tomorrow",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Tomorrow(self) -> "IAgCrdnEvent":
        """Returns Tomorrow time instant."""
        return self._intf.get_property(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._get_Tomorrow_metadata)

    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnEventType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnEventType") -> "IAgCrdnEvent":
        """Creates and registers an event using specified name, description, and type."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._Create_metadata, name, description, type, out_arg())

    _CreateEventEpoch_metadata = { "name" : "CreateEventEpoch",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventEpoch(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event set at a specified date/time."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._CreateEventEpoch_metadata, name, description, out_arg())

    _CreateEventExtremum_metadata = { "name" : "CreateEventExtremum",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventExtremum(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event that determines the time of global minimum or maximum of specified scalar calculation."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._CreateEventExtremum_metadata, name, description, out_arg())

    _CreateEventStartStopTime_metadata = { "name" : "CreateEventStartStopTime",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventStartStopTime(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event that is either the start or stop time selected from a reference interval."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._CreateEventStartStopTime_metadata, name, description, out_arg())

    _CreateEventSignaled_metadata = { "name" : "CreateEventSignaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventSignaled(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event recorded on a specified clock via signal transmission from an original time instant recorded on different clock."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._CreateEventSignaled_metadata, name, description, out_arg())

    _CreateEventTimeOffset_metadata = { "name" : "CreateEventTimeOffset",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventTimeOffset(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event at fixed offset from specified reference event."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._CreateEventTimeOffset_metadata, name, description, out_arg())

    _CreateSmartEpochFromTime_metadata = { "name" : "CreateSmartEpochFromTime",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def CreateSmartEpochFromTime(self, epoch:typing.Any) -> "IAgCrdnEventSmartEpoch":
        """Creates a smart epoch from STK epoch."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._CreateSmartEpochFromTime_metadata, epoch, out_arg())

    _CreateSmartEpochFromEvent_metadata = { "name" : "CreateSmartEpochFromEvent",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"), agmarshall.AgInterface_out_arg,) }
    def CreateSmartEpochFromEvent(self, refEvent:"IAgCrdnEvent") -> "IAgCrdnEventSmartEpoch":
        """Creates a smart epoch from an event."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._CreateSmartEpochFromEvent_metadata, refEvent, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnEventType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnEventFactory._metadata, IAgCrdnEventFactory._IsTypeSupported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{803DD343-F271-47D9-8D71-2092DD2A3387}", IAgCrdnEventFactory)
agcls.AgTypeNameMap["IAgCrdnEventFactory"] = IAgCrdnEventFactory

class IAgCrdnEventInterval(object):
    """A single time interval."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "get_LabelStartDescription" : 2,
                             "get_LabelStopDescription" : 3,
                             "get_LabelStart" : 4,
                             "get_LabelStop" : 5,
                             "FindInterval" : 6,
                             "Occurred" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventInterval._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventInterval from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventInterval.__dict__ and type(IAgCrdnEventInterval.__dict__[attrname]) == property:
            return IAgCrdnEventInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventInterval.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventIntervalType),) }
    @property
    def Type(self) -> "AgECrdnEventIntervalType":
        """Return the type of interval."""
        return self._intf.get_property(IAgCrdnEventInterval._metadata, IAgCrdnEventInterval._get_Type_metadata)

    _get_LabelStartDescription_metadata = { "name" : "LabelStartDescription",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def LabelStartDescription(self) -> str:
        """The start description."""
        return self._intf.get_property(IAgCrdnEventInterval._metadata, IAgCrdnEventInterval._get_LabelStartDescription_metadata)

    _get_LabelStopDescription_metadata = { "name" : "LabelStopDescription",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def LabelStopDescription(self) -> str:
        """The stop description."""
        return self._intf.get_property(IAgCrdnEventInterval._metadata, IAgCrdnEventInterval._get_LabelStopDescription_metadata)

    _get_LabelStart_metadata = { "name" : "LabelStart",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def LabelStart(self) -> str:
        """A label associated with the interval start."""
        return self._intf.get_property(IAgCrdnEventInterval._metadata, IAgCrdnEventInterval._get_LabelStart_metadata)

    _get_LabelStop_metadata = { "name" : "LabelStop",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def LabelStop(self) -> str:
        """A label associated with the interval stop."""
        return self._intf.get_property(IAgCrdnEventInterval._metadata, IAgCrdnEventInterval._get_LabelStop_metadata)

    _FindInterval_metadata = { "name" : "FindInterval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def FindInterval(self) -> "IAgCrdnEventIntervalResult":
        """Return computed interval if it exists."""
        return self._intf.invoke(IAgCrdnEventInterval._metadata, IAgCrdnEventInterval._FindInterval_metadata, out_arg())

    _Occurred_metadata = { "name" : "Occurred",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval if it exists."""
        return self._intf.invoke(IAgCrdnEventInterval._metadata, IAgCrdnEventInterval._Occurred_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}", IAgCrdnEventInterval)
agcls.AgTypeNameMap["IAgCrdnEventInterval"] = IAgCrdnEventInterval

class IAgCrdnEventIntervalBetweenTimeInstants(object):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18236EC1-B691-4FFD-995B-FB4896BAFD71}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_StartTimeInstant" : 1,
                             "set_StartTimeInstant" : 2,
                             "get_StopTimeInstant" : 3,
                             "set_StopTimeInstant" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalBetweenTimeInstants._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalBetweenTimeInstants from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalBetweenTimeInstants.__dict__ and type(IAgCrdnEventIntervalBetweenTimeInstants.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalBetweenTimeInstants.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalBetweenTimeInstants.")
    
    _get_StartTimeInstant_metadata = { "name" : "StartTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def StartTimeInstant(self) -> "IAgCrdnEvent":
        """The start time instant of the interval."""
        return self._intf.get_property(IAgCrdnEventIntervalBetweenTimeInstants._metadata, IAgCrdnEventIntervalBetweenTimeInstants._get_StartTimeInstant_metadata)

    _set_StartTimeInstant_metadata = { "name" : "StartTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @StartTimeInstant.setter
    def StartTimeInstant(self, startTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalBetweenTimeInstants._metadata, IAgCrdnEventIntervalBetweenTimeInstants._set_StartTimeInstant_metadata, startTimeInstant)

    _get_StopTimeInstant_metadata = { "name" : "StopTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def StopTimeInstant(self) -> "IAgCrdnEvent":
        """The stop time instant of the interval."""
        return self._intf.get_property(IAgCrdnEventIntervalBetweenTimeInstants._metadata, IAgCrdnEventIntervalBetweenTimeInstants._get_StopTimeInstant_metadata)

    _set_StopTimeInstant_metadata = { "name" : "StopTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @StopTimeInstant.setter
    def StopTimeInstant(self, stopTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalBetweenTimeInstants._metadata, IAgCrdnEventIntervalBetweenTimeInstants._set_StopTimeInstant_metadata, stopTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{18236EC1-B691-4FFD-995B-FB4896BAFD71}", IAgCrdnEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap["IAgCrdnEventIntervalBetweenTimeInstants"] = IAgCrdnEventIntervalBetweenTimeInstants

class IAgCrdnEventIntervalCollection(object):
    """A collection of related interval lists."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "get_Labels" : 2,
                             "FindIntervalCollection" : 3,
                             "Occurred" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalCollection from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollection.__dict__ and type(IAgCrdnEventIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalCollection.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType),) }
    @property
    def Type(self) -> "AgECrdnEventIntervalCollectionType":
        """Return the type of collection of interval lists."""
        return self._intf.get_property(IAgCrdnEventIntervalCollection._metadata, IAgCrdnEventIntervalCollection._get_Type_metadata)

    _get_Labels_metadata = { "name" : "Labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Labels(self) -> list:
        """Get the labels associated with the interval lists in the collection."""
        return self._intf.get_property(IAgCrdnEventIntervalCollection._metadata, IAgCrdnEventIntervalCollection._get_Labels_metadata)

    _FindIntervalCollection_metadata = { "name" : "FindIntervalCollection",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def FindIntervalCollection(self) -> "IAgCrdnIntervalsVectorResult":
        """Return computed collection of interval lists."""
        return self._intf.invoke(IAgCrdnEventIntervalCollection._metadata, IAgCrdnEventIntervalCollection._FindIntervalCollection_metadata, out_arg())

    _Occurred_metadata = { "name" : "Occurred",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Occurred(self, epoch:typing.Any) -> "IAgCrdnEventIntervalCollectionOccurredResult":
        """Determine if specified time falls within any of the computed interval lists in the collection."""
        return self._intf.invoke(IAgCrdnEventIntervalCollection._metadata, IAgCrdnEventIntervalCollection._Occurred_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}", IAgCrdnEventIntervalCollection)
agcls.AgTypeNameMap["IAgCrdnEventIntervalCollection"] = IAgCrdnEventIntervalCollection

class IAgCrdnEventIntervalCollectionCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0253FA16-73AA-4F0A-9904-0789EC873ECB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ConditionSet" : 1,
                             "set_ConditionSet" : 2,
                             "get_CustomTimeLimits" : 3,
                             "set_CustomTimeLimits" : 4,
                             "get_UseCustomTimeLimits" : 5,
                             "set_UseCustomTimeLimits" : 6,
                             "get_SaveDataOption" : 7,
                             "set_SaveDataOption" : 8,
                             "get_Sampling" : 9,
                             "set_Sampling" : 10,
                             "get_Convergence" : 11,
                             "set_Convergence" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalCollectionCondition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalCollectionCondition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionCondition.__dict__ and type(IAgCrdnEventIntervalCollectionCondition.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalCollectionCondition.")
    
    _get_ConditionSet_metadata = { "name" : "ConditionSet",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ConditionSet(self) -> "IAgCrdnConditionSet":
        """Get/set the condition set object."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._get_ConditionSet_metadata)

    _set_ConditionSet_metadata = { "name" : "ConditionSet",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConditionSet"),) }
    @ConditionSet.setter
    def ConditionSet(self, conditionSet:"IAgCrdnConditionSet") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._set_ConditionSet_metadata, conditionSet)

    _get_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._get_CustomTimeLimits_metadata)

    _set_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._set_CustomTimeLimits_metadata, customTimeLimits)

    _get_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use specified custom interval list (see CustomTimeLimits)."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._get_UseCustomTimeLimits_metadata)

    _set_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._set_UseCustomTimeLimits_metadata, useCustomTimeLimits)

    _get_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._get_SaveDataOption_metadata)

    _set_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._set_SaveDataOption_metadata, saveDataOption)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._set_Sampling_metadata, sampling)

    _get_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._get_Convergence_metadata)

    _set_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConverge"),) }
    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionCondition._metadata, IAgCrdnEventIntervalCollectionCondition._set_Convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{0253FA16-73AA-4F0A-9904-0789EC873ECB}", IAgCrdnEventIntervalCollectionCondition)
agcls.AgTypeNameMap["IAgCrdnEventIntervalCollectionCondition"] = IAgCrdnEventIntervalCollectionCondition

class IAgCrdnEventIntervalCollectionFactory(object):
    """The factory creates collections of event interval lists."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{15E2D2CF-61F9-4468-A5E1-770149F6B08C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateEventIntervalCollectionLighting" : 2,
                             "CreateEventIntervalCollectionSignaled" : 3,
                             "IsTypeSupported" : 4,
                             "CreateEventIntervalCollectionSatisfaction" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalCollectionFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalCollectionFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionFactory.__dict__ and type(IAgCrdnEventIntervalCollectionFactory.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalCollectionFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalCollectionType") -> "IAgCrdnEventIntervalCollection":
        """Create and register an event interval collection using specified name, description, and type."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionFactory._metadata, IAgCrdnEventIntervalCollectionFactory._Create_metadata, name, description, type, out_arg())

    _CreateEventIntervalCollectionLighting_metadata = { "name" : "CreateEventIntervalCollectionLighting",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalCollectionLighting(self, name:str, description:str) -> "IAgCrdnEventIntervalCollection":
        """Create an event interval collection defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionFactory._metadata, IAgCrdnEventIntervalCollectionFactory._CreateEventIntervalCollectionLighting_metadata, name, description, out_arg())

    _CreateEventIntervalCollectionSignaled_metadata = { "name" : "CreateEventIntervalCollectionSignaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalCollectionSignaled(self, name:str, description:str) -> "IAgCrdnEventIntervalCollection":
        """Create an event interval collection recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionFactory._metadata, IAgCrdnEventIntervalCollectionFactory._CreateEventIntervalCollectionSignaled_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnEventIntervalCollectionType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionFactory._metadata, IAgCrdnEventIntervalCollectionFactory._IsTypeSupported_metadata, eType, out_arg())

    _CreateEventIntervalCollectionSatisfaction_metadata = { "name" : "CreateEventIntervalCollectionSatisfaction",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalCollectionSatisfaction(self, name:str, description:str) -> "IAgCrdnEventIntervalCollection":
        """Create an event interval collection containing intervals during which condition set is satisfied."""
        return self._intf.invoke(IAgCrdnEventIntervalCollectionFactory._metadata, IAgCrdnEventIntervalCollectionFactory._CreateEventIntervalCollectionSatisfaction_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{15E2D2CF-61F9-4468-A5E1-770149F6B08C}", IAgCrdnEventIntervalCollectionFactory)
agcls.AgTypeNameMap["IAgCrdnEventIntervalCollectionFactory"] = IAgCrdnEventIntervalCollectionFactory

class IAgCrdnEventIntervalCollectionLighting(object):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Location" : 1,
                             "set_Location" : 2,
                             "get_EclipsingBodies" : 3,
                             "set_EclipsingBodies" : 4,
                             "get_UseObjectEclipsingBodies" : 5,
                             "set_UseObjectEclipsingBodies" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalCollectionLighting._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalCollectionLighting from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionLighting.__dict__ and type(IAgCrdnEventIntervalCollectionLighting.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalCollectionLighting.")
    
    _get_Location_metadata = { "name" : "Location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Location(self) -> "IAgCrdnPoint":
        """The location point to compute sunlight, penumbra and umbra."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionLighting._metadata, IAgCrdnEventIntervalCollectionLighting._get_Location_metadata)

    _set_Location_metadata = { "name" : "Location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @Location.setter
    def Location(self, location:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionLighting._metadata, IAgCrdnEventIntervalCollectionLighting._set_Location_metadata, location)

    _get_EclipsingBodies_metadata = { "name" : "EclipsingBodies",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionLighting._metadata, IAgCrdnEventIntervalCollectionLighting._get_EclipsingBodies_metadata)

    _set_EclipsingBodies_metadata = { "name" : "EclipsingBodies",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionLighting._metadata, IAgCrdnEventIntervalCollectionLighting._set_EclipsingBodies_metadata, eclipsingBodies)

    _get_UseObjectEclipsingBodies_metadata = { "name" : "UseObjectEclipsingBodies",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionLighting._metadata, IAgCrdnEventIntervalCollectionLighting._get_UseObjectEclipsingBodies_metadata)

    _set_UseObjectEclipsingBodies_metadata = { "name" : "UseObjectEclipsingBodies",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionLighting._metadata, IAgCrdnEventIntervalCollectionLighting._set_UseObjectEclipsingBodies_metadata, useObjectEclipsingBodies)


agcls.AgClassCatalog.add_catalog_entry("{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}", IAgCrdnEventIntervalCollectionLighting)
agcls.AgTypeNameMap["IAgCrdnEventIntervalCollectionLighting"] = IAgCrdnEventIntervalCollectionLighting

class IAgCrdnEventIntervalCollectionSignaled(object):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AE464683-EEEC-46CF-8886-91F7A30B7859}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalCollection" : 1,
                             "set_OriginalCollection" : 2,
                             "get_SignalSense" : 3,
                             "set_SignalSense" : 4,
                             "get_BaseClockLocation" : 5,
                             "set_BaseClockLocation" : 6,
                             "get_TargetClockLocation" : 7,
                             "set_TargetClockLocation" : 8,
                             "get_SignalDelay" : 9,
                             "set_SignalDelay" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalCollectionSignaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalCollectionSignaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionSignaled.__dict__ and type(IAgCrdnEventIntervalCollectionSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalCollectionSignaled.")
    
    _get_OriginalCollection_metadata = { "name" : "OriginalCollection",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalCollection(self) -> "IAgCrdnEventIntervalCollection":
        """The original interval list collection."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._get_OriginalCollection_metadata)

    _set_OriginalCollection_metadata = { "name" : "OriginalCollection",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalCollection"),) }
    @OriginalCollection.setter
    def OriginalCollection(self, originalCollection:"IAgCrdnEventIntervalCollection") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._set_OriginalCollection_metadata, originalCollection)

    _get_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._get_SignalSense_metadata)

    _set_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._set_SignalSense_metadata, signalSense)

    _get_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._get_BaseClockLocation_metadata)

    _set_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._set_BaseClockLocation_metadata, baseClockLocation)

    _get_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._get_TargetClockLocation_metadata)

    _set_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._set_TargetClockLocation_metadata, targetClockLocation)

    _get_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._get_SignalDelay_metadata)

    _set_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSignalDelay"),) }
    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalCollectionSignaled._metadata, IAgCrdnEventIntervalCollectionSignaled._set_SignalDelay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{AE464683-EEEC-46CF-8886-91F7A30B7859}", IAgCrdnEventIntervalCollectionSignaled)
agcls.AgTypeNameMap["IAgCrdnEventIntervalCollectionSignaled"] = IAgCrdnEventIntervalCollectionSignaled

class IAgCrdnEventIntervalFactory(object):
    """The factory creates event intervals."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F87C00CA-725C-425C-941E-6987709D788F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateEventIntervalFixed" : 2,
                             "CreateEventIntervalFixedDuration" : 3,
                             "CreateEventIntervalBetweenTimeInstants" : 4,
                             "CreateEventIntervalFromIntervalList" : 5,
                             "CreateEventIntervalScaled" : 6,
                             "CreateEventIntervalSignaled" : 7,
                             "CreateEventIntervalTimeOffset" : 8,
                             "IsTypeSupported" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFactory.__dict__ and type(IAgCrdnEventIntervalFactory.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnEventIntervalType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalType") -> "IAgCrdnEventInterval":
        """Create and register an interval using specified name, description, and type."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._Create_metadata, name, description, type, out_arg())

    _CreateEventIntervalFixed_metadata = { "name" : "CreateEventIntervalFixed",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalFixed(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval defined between two explicitly specified start and stop times."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._CreateEventIntervalFixed_metadata, name, description, out_arg())

    _CreateEventIntervalFixedDuration_metadata = { "name" : "CreateEventIntervalFixedDuration",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalFixedDuration(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._CreateEventIntervalFixedDuration_metadata, name, description, out_arg())

    _CreateEventIntervalBetweenTimeInstants_metadata = { "name" : "CreateEventIntervalBetweenTimeInstants",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalBetweenTimeInstants(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval using specified start and stop time instants."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._CreateEventIntervalBetweenTimeInstants_metadata, name, description, out_arg())

    _CreateEventIntervalFromIntervalList_metadata = { "name" : "CreateEventIntervalFromIntervalList",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalFromIntervalList(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval from a specified interval list by using one of several selection methods."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._CreateEventIntervalFromIntervalList_metadata, name, description, out_arg())

    _CreateEventIntervalScaled_metadata = { "name" : "CreateEventIntervalScaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalScaled(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval by scaling an original interval using either absolute or relative scale."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._CreateEventIntervalScaled_metadata, name, description, out_arg())

    _CreateEventIntervalSignaled_metadata = { "name" : "CreateEventIntervalSignaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalSignaled(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval that is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._CreateEventIntervalSignaled_metadata, name, description, out_arg())

    _CreateEventIntervalTimeOffset_metadata = { "name" : "CreateEventIntervalTimeOffset",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalTimeOffset(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval defined by shifting the specified reference interval by a fixed time offset."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._CreateEventIntervalTimeOffset_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventIntervalType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnEventIntervalType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnEventIntervalFactory._metadata, IAgCrdnEventIntervalFactory._IsTypeSupported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{F87C00CA-725C-425C-941E-6987709D788F}", IAgCrdnEventIntervalFactory)
agcls.AgTypeNameMap["IAgCrdnEventIntervalFactory"] = IAgCrdnEventIntervalFactory

class IAgCrdnEventIntervalFixed(object):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2DBC4523-FDD0-413B-B933-9F74B9B17BED}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_StartTime" : 1,
                             "get_StopTime" : 2,
                             "SetInterval" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalFixed._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalFixed from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFixed.__dict__ and type(IAgCrdnEventIntervalFixed.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalFixed.")
    
    _get_StartTime_metadata = { "name" : "StartTime",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def StartTime(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(IAgCrdnEventIntervalFixed._metadata, IAgCrdnEventIntervalFixed._get_StartTime_metadata)

    _get_StopTime_metadata = { "name" : "StopTime",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def StopTime(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(IAgCrdnEventIntervalFixed._metadata, IAgCrdnEventIntervalFixed._get_StopTime_metadata)

    _SetInterval_metadata = { "name" : "SetInterval",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def SetInterval(self, startEpoch:typing.Any, stopEpoch:typing.Any) -> None:
        """Set interval's start and stop times."""
        return self._intf.invoke(IAgCrdnEventIntervalFixed._metadata, IAgCrdnEventIntervalFixed._SetInterval_metadata, startEpoch, stopEpoch)


agcls.AgClassCatalog.add_catalog_entry("{2DBC4523-FDD0-413B-B933-9F74B9B17BED}", IAgCrdnEventIntervalFixed)
agcls.AgTypeNameMap["IAgCrdnEventIntervalFixed"] = IAgCrdnEventIntervalFixed

class IAgCrdnEventIntervalFixedDuration(object):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2A20830B-D576-4DF1-9C15-51EB59AEC23F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceTimeInstant" : 1,
                             "set_ReferenceTimeInstant" : 2,
                             "get_StartOffset" : 3,
                             "set_StartOffset" : 4,
                             "get_StopOffset" : 5,
                             "set_StopOffset" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalFixedDuration._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalFixedDuration from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFixedDuration.__dict__ and type(IAgCrdnEventIntervalFixedDuration.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFixedDuration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalFixedDuration.")
    
    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        return self._intf.get_property(IAgCrdnEventIntervalFixedDuration._metadata, IAgCrdnEventIntervalFixedDuration._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalFixedDuration._metadata, IAgCrdnEventIntervalFixedDuration._set_ReferenceTimeInstant_metadata, referenceTimeInstant)

    _get_StartOffset_metadata = { "name" : "StartOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StartOffset(self) -> float:
        """The start time offset value."""
        return self._intf.get_property(IAgCrdnEventIntervalFixedDuration._metadata, IAgCrdnEventIntervalFixedDuration._get_StartOffset_metadata)

    _set_StartOffset_metadata = { "name" : "StartOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalFixedDuration._metadata, IAgCrdnEventIntervalFixedDuration._set_StartOffset_metadata, startOffset)

    _get_StopOffset_metadata = { "name" : "StopOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StopOffset(self) -> float:
        """The stop time offset value."""
        return self._intf.get_property(IAgCrdnEventIntervalFixedDuration._metadata, IAgCrdnEventIntervalFixedDuration._get_StopOffset_metadata)

    _set_StopOffset_metadata = { "name" : "StopOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalFixedDuration._metadata, IAgCrdnEventIntervalFixedDuration._set_StopOffset_metadata, stopOffset)


agcls.AgClassCatalog.add_catalog_entry("{2A20830B-D576-4DF1-9C15-51EB59AEC23F}", IAgCrdnEventIntervalFixedDuration)
agcls.AgTypeNameMap["IAgCrdnEventIntervalFixedDuration"] = IAgCrdnEventIntervalFixedDuration

class IAgCrdnEventIntervalFromIntervalList(object):
    """Interval created from specified interval list by using one of several selection methods."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DCF8AA30-67A3-4856-956D-C4952BF3818E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceIntervals" : 1,
                             "set_ReferenceIntervals" : 2,
                             "get_IntervalSelection" : 3,
                             "set_IntervalSelection" : 4,
                             "get_IntervalNumber" : 5,
                             "set_IntervalNumber" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalFromIntervalList._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalFromIntervalList from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFromIntervalList.__dict__ and type(IAgCrdnEventIntervalFromIntervalList.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFromIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalFromIntervalList.")
    
    _get_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalFromIntervalList._metadata, IAgCrdnEventIntervalFromIntervalList._get_ReferenceIntervals_metadata)

    _set_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalFromIntervalList._metadata, IAgCrdnEventIntervalFromIntervalList._set_ReferenceIntervals_metadata, referenceIntervals)

    _get_IntervalSelection_metadata = { "name" : "IntervalSelection",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalSelection),) }
    @property
    def IntervalSelection(self) -> "AgECrdnIntervalSelection":
        """The method used to select an interval from the reference interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalFromIntervalList._metadata, IAgCrdnEventIntervalFromIntervalList._get_IntervalSelection_metadata)

    _set_IntervalSelection_metadata = { "name" : "IntervalSelection",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalSelection),) }
    @IntervalSelection.setter
    def IntervalSelection(self, intervalSelection:"AgECrdnIntervalSelection") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalFromIntervalList._metadata, IAgCrdnEventIntervalFromIntervalList._set_IntervalSelection_metadata, intervalSelection)

    _get_IntervalNumber_metadata = { "name" : "IntervalNumber",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def IntervalNumber(self) -> int:
        """An interval number. Applicable only if IntervalSelection is IntervalSelectionFromStart or IntervalSelectionFromEnd"""
        return self._intf.get_property(IAgCrdnEventIntervalFromIntervalList._metadata, IAgCrdnEventIntervalFromIntervalList._get_IntervalNumber_metadata)

    _set_IntervalNumber_metadata = { "name" : "IntervalNumber",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @IntervalNumber.setter
    def IntervalNumber(self, intervalNumber:int) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalFromIntervalList._metadata, IAgCrdnEventIntervalFromIntervalList._set_IntervalNumber_metadata, intervalNumber)


agcls.AgClassCatalog.add_catalog_entry("{DCF8AA30-67A3-4856-956D-C4952BF3818E}", IAgCrdnEventIntervalFromIntervalList)
agcls.AgTypeNameMap["IAgCrdnEventIntervalFromIntervalList"] = IAgCrdnEventIntervalFromIntervalList

class IAgCrdnEventIntervalList(object):
    """An ordered list of time intervals."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "get_Labels" : 2,
                             "get_Descriptions" : 3,
                             "FindIntervals" : 4,
                             "Occurred" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalList._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalList from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalList.__dict__ and type(IAgCrdnEventIntervalList.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalList.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventIntervalListType),) }
    @property
    def Type(self) -> "AgECrdnEventIntervalListType":
        """Return the type of interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalList._metadata, IAgCrdnEventIntervalList._get_Type_metadata)

    _get_Labels_metadata = { "name" : "Labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Labels(self) -> list:
        """Get the label descriptions associated with the interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalList._metadata, IAgCrdnEventIntervalList._get_Labels_metadata)

    _get_Descriptions_metadata = { "name" : "Descriptions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Descriptions(self) -> list:
        """Get the labels associated with the interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalList._metadata, IAgCrdnEventIntervalList._get_Descriptions_metadata)

    _FindIntervals_metadata = { "name" : "FindIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def FindIntervals(self) -> "IAgCrdnIntervalListResult":
        """Return computed interval list that can be empty."""
        return self._intf.invoke(IAgCrdnEventIntervalList._metadata, IAgCrdnEventIntervalList._FindIntervals_metadata, out_arg())

    _Occurred_metadata = { "name" : "Occurred",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval list."""
        return self._intf.invoke(IAgCrdnEventIntervalList._metadata, IAgCrdnEventIntervalList._Occurred_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}", IAgCrdnEventIntervalList)
agcls.AgTypeNameMap["IAgCrdnEventIntervalList"] = IAgCrdnEventIntervalList

class IAgCrdnEventIntervalListCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D073568A-7398-45C2-998A-CD2EC12F06E0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Condition" : 1,
                             "set_Condition" : 2,
                             "get_CustomTimeLimits" : 3,
                             "set_CustomTimeLimits" : 4,
                             "get_UseCustomTimeLimits" : 5,
                             "set_UseCustomTimeLimits" : 6,
                             "get_SaveDataOption" : 7,
                             "set_SaveDataOption" : 8,
                             "get_Sampling" : 9,
                             "set_Sampling" : 10,
                             "get_Convergence" : 11,
                             "set_Convergence" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListCondition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListCondition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListCondition.__dict__ and type(IAgCrdnEventIntervalListCondition.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListCondition.")
    
    _get_Condition_metadata = { "name" : "Condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """The condition component."""
        return self._intf.get_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._get_Condition_metadata)

    _set_Condition_metadata = { "name" : "Condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCondition"),) }
    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._set_Condition_metadata, condition)

    _get_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """The interval list or single interval within which intervals of satisfaction are sought. The specified value is used if UseCustomTimeLimits is true. The default is set to overall availability of host object..."""
        return self._intf.get_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._get_CustomTimeLimits_metadata)

    _set_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._set_CustomTimeLimits_metadata, customTimeLimits)

    _get_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._get_UseCustomTimeLimits_metadata)

    _set_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._set_UseCustomTimeLimits_metadata, useCustomTimeLimits)

    _get_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed intervals of satisfaction are saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._get_SaveDataOption_metadata)

    _set_SaveDataOption_metadata = { "name" : "SaveDataOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSaveDataOption),) }
    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._set_SaveDataOption_metadata, saveDataOption)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._set_Sampling_metadata, sampling)

    _get_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times for intervals of satisfaction are found."""
        return self._intf.get_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._get_Convergence_metadata)

    _set_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConverge"),) }
    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListCondition._metadata, IAgCrdnEventIntervalListCondition._set_Convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{D073568A-7398-45C2-998A-CD2EC12F06E0}", IAgCrdnEventIntervalListCondition)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListCondition"] = IAgCrdnEventIntervalListCondition

class IAgCrdnEventIntervalListFactory(object):
    """The factory creates event interval lists."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateEventIntervalListMerged" : 2,
                             "CreateEventIntervalListFiltered" : 3,
                             "CreateEventIntervalListCondition" : 4,
                             "CreateEventIntervalListScaled" : 5,
                             "CreateEventIntervalListSignaled" : 6,
                             "CreateEventIntervalListTimeOffset" : 7,
                             "IsTypeSupported" : 8,
                             "CreateEventIntervalListFile" : 9,
                             "CreateEventIntervalListFixed" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFactory.__dict__ and type(IAgCrdnEventIntervalListFactory.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnEventIntervalListType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalListType") -> "IAgCrdnEventIntervalList":
        """Create and register an interval list using specified name, description, and type."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._Create_metadata, name, description, type, out_arg())

    _CreateEventIntervalListMerged_metadata = { "name" : "CreateEventIntervalListMerged",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListMerged(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list by merging two constituent interval lists using specified logical operation."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListMerged_metadata, name, description, out_arg())

    _CreateEventIntervalListFiltered_metadata = { "name" : "CreateEventIntervalListFiltered",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListFiltered(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list by filtering intervals from original interval list using specified filtering method."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListFiltered_metadata, name, description, out_arg())

    _CreateEventIntervalListCondition_metadata = { "name" : "CreateEventIntervalListCondition",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListCondition(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list containing intervals during which specified condition is satisfied."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListCondition_metadata, name, description, out_arg())

    _CreateEventIntervalListScaled_metadata = { "name" : "CreateEventIntervalListScaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListScaled(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list defined by scaling every interval in original interval list using either absolute or relative scale."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListScaled_metadata, name, description, out_arg())

    _CreateEventIntervalListSignaled_metadata = { "name" : "CreateEventIntervalListSignaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListSignaled(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list recorded at the target clock location by performing signal transmission of original interval list between base and target clock locations."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListSignaled_metadata, name, description, out_arg())

    _CreateEventIntervalListTimeOffset_metadata = { "name" : "CreateEventIntervalListTimeOffset",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListTimeOffset(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list defined by shifting the specified reference interval list by a fixed time offset."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListTimeOffset_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventIntervalListType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnEventIntervalListType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._IsTypeSupported_metadata, eType, out_arg())

    _CreateEventIntervalListFile_metadata = { "name" : "CreateEventIntervalListFile",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListFile(self, name:str, description:str, filePath:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list based on specified interval file."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListFile_metadata, name, description, filePath, out_arg())

    _CreateEventIntervalListFixed_metadata = { "name" : "CreateEventIntervalListFixed",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEventIntervalListFixed(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
        return self._intf.invoke(IAgCrdnEventIntervalListFactory._metadata, IAgCrdnEventIntervalListFactory._CreateEventIntervalListFixed_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}", IAgCrdnEventIntervalListFactory)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListFactory"] = IAgCrdnEventIntervalListFactory

class IAgCrdnEventIntervalListFile(object):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A17588F4-C944-44F8-B8D8-275B13D27E3A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Filename" : 1,
                             "set_Filename" : 2,
                             "Reload" : 3,
                             "GetFileSpan" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListFile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListFile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFile.__dict__ and type(IAgCrdnEventIntervalListFile.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListFile.")
    
    _get_Filename_metadata = { "name" : "Filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the time interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalListFile._metadata, IAgCrdnEventIntervalListFile._get_Filename_metadata)

    _set_Filename_metadata = { "name" : "Filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Filename.setter
    def Filename(self, filename:str) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListFile._metadata, IAgCrdnEventIntervalListFile._set_Filename_metadata, filename)

    _Reload_metadata = { "name" : "Reload",
            "arg_types" : (),
            "marshallers" : () }
    def Reload(self) -> None:
        """Reloads the interval list file."""
        return self._intf.invoke(IAgCrdnEventIntervalListFile._metadata, IAgCrdnEventIntervalListFile._Reload_metadata, )

    _GetFileSpan_metadata = { "name" : "GetFileSpan",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetFileSpan(self) -> "IAgCrdnEventIntervalResult":
        """Computes the interval list file span."""
        return self._intf.invoke(IAgCrdnEventIntervalListFile._metadata, IAgCrdnEventIntervalListFile._GetFileSpan_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{A17588F4-C944-44F8-B8D8-275B13D27E3A}", IAgCrdnEventIntervalListFile)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListFile"] = IAgCrdnEventIntervalListFile

class IAgCrdnEventIntervalListFiltered(object):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalIntervals" : 1,
                             "set_OriginalIntervals" : 2,
                             "get_FilterFactory" : 3,
                             "get_Filter" : 4,
                             "set_Filter" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListFiltered._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListFiltered from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFiltered.__dict__ and type(IAgCrdnEventIntervalListFiltered.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListFiltered.")
    
    _get_OriginalIntervals_metadata = { "name" : "OriginalIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalIntervals(self) -> "IAgCrdnEventIntervalList":
        """The original interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalListFiltered._metadata, IAgCrdnEventIntervalListFiltered._get_OriginalIntervals_metadata)

    _set_OriginalIntervals_metadata = { "name" : "OriginalIntervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListFiltered._metadata, IAgCrdnEventIntervalListFiltered._set_OriginalIntervals_metadata, originalIntervals)

    _get_FilterFactory_metadata = { "name" : "FilterFactory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FilterFactory(self) -> "IAgCrdnPruneFilterFactory":
        """Get the prune filter factory."""
        return self._intf.get_property(IAgCrdnEventIntervalListFiltered._metadata, IAgCrdnEventIntervalListFiltered._get_FilterFactory_metadata)

    _get_Filter_metadata = { "name" : "Filter",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Filter(self) -> "IAgCrdnPruneFilter":
        """The pruning filter."""
        return self._intf.get_property(IAgCrdnEventIntervalListFiltered._metadata, IAgCrdnEventIntervalListFiltered._get_Filter_metadata)

    _set_Filter_metadata = { "name" : "Filter",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPruneFilter"),) }
    @Filter.setter
    def Filter(self, filter:"IAgCrdnPruneFilter") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListFiltered._metadata, IAgCrdnEventIntervalListFiltered._set_Filter_metadata, filter)


agcls.AgClassCatalog.add_catalog_entry("{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}", IAgCrdnEventIntervalListFiltered)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListFiltered"] = IAgCrdnEventIntervalListFiltered

class IAgCrdnEventIntervalListFixed(object):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "GetIntervals" : 1,
                             "SetIntervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListFixed._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListFixed from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFixed.__dict__ and type(IAgCrdnEventIntervalListFixed.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListFixed.")
    
    _GetIntervals_metadata = { "name" : "GetIntervals",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def GetIntervals(self) -> list:
        """Get intervals with explicitly specified start and stop times from interval list. The method returns a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        return self._intf.invoke(IAgCrdnEventIntervalListFixed._metadata, IAgCrdnEventIntervalListFixed._GetIntervals_metadata, out_arg())

    _SetIntervals_metadata = { "name" : "SetIntervals",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def SetIntervals(self, intervals:list) -> None:
        """Set interval list from intervals with explicitly specified start and stop times. The method takes a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        return self._intf.invoke(IAgCrdnEventIntervalListFixed._metadata, IAgCrdnEventIntervalListFixed._SetIntervals_metadata, intervals)


agcls.AgClassCatalog.add_catalog_entry("{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}", IAgCrdnEventIntervalListFixed)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListFixed"] = IAgCrdnEventIntervalListFixed

class IAgCrdnEventIntervalListMerged(object):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IntervalListOrIntervalA" : 1,
                             "get_IntervalListOrIntervalB" : 2,
                             "get_MergeOperation" : 3,
                             "set_MergeOperation" : 4,
                             "SetIntervalListA" : 5,
                             "SetIntervalA" : 6,
                             "SetIntervalListB" : 7,
                             "SetIntervalB" : 8,
                             "AddInterval" : 9,
                             "AddIntervalList" : 10,
                             "SetInterval" : 11,
                             "SetIntervalList" : 12,
                             "GetTimeComponent" : 13,
                             "GetTimeComponentSize" : 14,
                             "RemoveTimeComponent" : 15, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListMerged._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListMerged from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListMerged.__dict__ and type(IAgCrdnEventIntervalListMerged.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListMerged.")
    
    _get_IntervalListOrIntervalA_metadata = { "name" : "IntervalListOrIntervalA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def IntervalListOrIntervalA(self) -> "IAgCrdn":
        """The interval list or interval A."""
        return self._intf.get_property(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._get_IntervalListOrIntervalA_metadata)

    _get_IntervalListOrIntervalB_metadata = { "name" : "IntervalListOrIntervalB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def IntervalListOrIntervalB(self) -> "IAgCrdn":
        """The interval list or interval B."""
        return self._intf.get_property(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._get_IntervalListOrIntervalB_metadata)

    _get_MergeOperation_metadata = { "name" : "MergeOperation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation),) }
    @property
    def MergeOperation(self) -> "AgECrdnEventListMergeOperation":
        """The merge operation."""
        return self._intf.get_property(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._get_MergeOperation_metadata)

    _set_MergeOperation_metadata = { "name" : "MergeOperation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation),) }
    @MergeOperation.setter
    def MergeOperation(self, mergeOperation:"AgECrdnEventListMergeOperation") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._set_MergeOperation_metadata, mergeOperation)

    _SetIntervalListA_metadata = { "name" : "SetIntervalListA",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    def SetIntervalListA(self, refIntervals:"IAgCrdnEventIntervalList") -> None:
        """Sets the interval list A."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._SetIntervalListA_metadata, refIntervals)

    _SetIntervalA_metadata = { "name" : "SetIntervalA",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    def SetIntervalA(self, refIntervals:"IAgCrdnEventInterval") -> None:
        """Sets the interval A."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._SetIntervalA_metadata, refIntervals)

    _SetIntervalListB_metadata = { "name" : "SetIntervalListB",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    def SetIntervalListB(self, refIntervals:"IAgCrdnEventIntervalList") -> None:
        """Sets the interval list B."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._SetIntervalListB_metadata, refIntervals)

    _SetIntervalB_metadata = { "name" : "SetIntervalB",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    def SetIntervalB(self, refIntervals:"IAgCrdnEventInterval") -> None:
        """Sets the interval B."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._SetIntervalB_metadata, refIntervals)

    _AddInterval_metadata = { "name" : "AddInterval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    def AddInterval(self, refIntervals:"IAgCrdnEventInterval") -> None:
        """Add interval."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._AddInterval_metadata, refIntervals)

    _AddIntervalList_metadata = { "name" : "AddIntervalList",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    def AddIntervalList(self, refIntervals:"IAgCrdnEventIntervalList") -> None:
        """Add interval list."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._AddIntervalList_metadata, refIntervals)

    _SetInterval_metadata = { "name" : "SetInterval",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"), agmarshall.INT_arg,) }
    def SetInterval(self, refIntervals:"IAgCrdnEventInterval", pos:int) -> None:
        """Sets the interval at given index."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._SetInterval_metadata, refIntervals, pos)

    _SetIntervalList_metadata = { "name" : "SetIntervalList",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"), agmarshall.INT_arg,) }
    def SetIntervalList(self, refIntervals:"IAgCrdnEventIntervalList", pos:int) -> None:
        """Sets the interval list at given index."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._SetIntervalList_metadata, refIntervals, pos)

    _GetTimeComponent_metadata = { "name" : "GetTimeComponent",
            "arg_types" : (agcom.INT, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.BSTR_arg,) }
    def GetTimeComponent(self, pos:int) -> str:
        """Gets time component at given position."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._GetTimeComponent_metadata, pos, out_arg())

    _GetTimeComponentSize_metadata = { "name" : "GetTimeComponentSize",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    def GetTimeComponentSize(self) -> int:
        """Gets time component list size."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._GetTimeComponentSize_metadata, out_arg())

    _RemoveTimeComponent_metadata = { "name" : "RemoveTimeComponent",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    def RemoveTimeComponent(self, pos:int) -> None:
        """Remove time component at given position."""
        return self._intf.invoke(IAgCrdnEventIntervalListMerged._metadata, IAgCrdnEventIntervalListMerged._RemoveTimeComponent_metadata, pos)


agcls.AgClassCatalog.add_catalog_entry("{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}", IAgCrdnEventIntervalListMerged)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListMerged"] = IAgCrdnEventIntervalListMerged

class IAgCrdnEventIntervalListScaled(object):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7DDA88F8-A738-464E-9CDC-613E107F57D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalIntervals" : 1,
                             "set_OriginalIntervals" : 2,
                             "get_AbsoluteIncrement" : 3,
                             "set_AbsoluteIncrement" : 4,
                             "get_RelativeIncrement" : 5,
                             "set_RelativeIncrement" : 6,
                             "get_UseAbsoluteIncrement" : 7,
                             "set_UseAbsoluteIncrement" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListScaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListScaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListScaled.__dict__ and type(IAgCrdnEventIntervalListScaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListScaled.")
    
    _get_OriginalIntervals_metadata = { "name" : "OriginalIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalIntervals(self) -> "IAgCrdnEventIntervalList":
        """The original interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._get_OriginalIntervals_metadata)

    _set_OriginalIntervals_metadata = { "name" : "OriginalIntervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._set_OriginalIntervals_metadata, originalIntervals)

    _get_AbsoluteIncrement_metadata = { "name" : "AbsoluteIncrement",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a new interval list by expanding (or shortening if negative) every interval in the original interval list by shifting interval's start/stop times equally by half of specified increment value."""
        return self._intf.get_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._get_AbsoluteIncrement_metadata)

    _set_AbsoluteIncrement_metadata = { "name" : "AbsoluteIncrement",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._set_AbsoluteIncrement_metadata, absoluteIncrement)

    _get_RelativeIncrement_metadata = { "name" : "RelativeIncrement",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        return self._intf.get_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._get_RelativeIncrement_metadata)

    _set_RelativeIncrement_metadata = { "name" : "RelativeIncrement",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._set_RelativeIncrement_metadata, relativeIncrement)

    _get_UseAbsoluteIncrement_metadata = { "name" : "UseAbsoluteIncrement",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        return self._intf.get_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._get_UseAbsoluteIncrement_metadata)

    _set_UseAbsoluteIncrement_metadata = { "name" : "UseAbsoluteIncrement",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListScaled._metadata, IAgCrdnEventIntervalListScaled._set_UseAbsoluteIncrement_metadata, useAbsoluteIncrement)


agcls.AgClassCatalog.add_catalog_entry("{7DDA88F8-A738-464E-9CDC-613E107F57D0}", IAgCrdnEventIntervalListScaled)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListScaled"] = IAgCrdnEventIntervalListScaled

class IAgCrdnEventIntervalListSignaled(object):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C40EA24E-E258-4B0E-8A0F-89424F93F837}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalIntervals" : 1,
                             "set_OriginalIntervals" : 2,
                             "get_SignalSense" : 3,
                             "set_SignalSense" : 4,
                             "get_BaseClockLocation" : 5,
                             "set_BaseClockLocation" : 6,
                             "get_TargetClockLocation" : 7,
                             "set_TargetClockLocation" : 8,
                             "get_SignalDelay" : 9,
                             "set_SignalDelay" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListSignaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListSignaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListSignaled.__dict__ and type(IAgCrdnEventIntervalListSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListSignaled.")
    
    _get_OriginalIntervals_metadata = { "name" : "OriginalIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalIntervals(self) -> "IAgCrdnEventIntervalList":
        """The original time interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._get_OriginalIntervals_metadata)

    _set_OriginalIntervals_metadata = { "name" : "OriginalIntervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._set_OriginalIntervals_metadata, originalIntervals)

    _get_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._get_SignalSense_metadata)

    _set_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._set_SignalSense_metadata, signalSense)

    _get_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._get_BaseClockLocation_metadata)

    _set_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._set_BaseClockLocation_metadata, baseClockLocation)

    _get_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._get_TargetClockLocation_metadata)

    _set_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._set_TargetClockLocation_metadata, targetClockLocation)

    _get_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._get_SignalDelay_metadata)

    _set_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSignalDelay"),) }
    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListSignaled._metadata, IAgCrdnEventIntervalListSignaled._set_SignalDelay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{C40EA24E-E258-4B0E-8A0F-89424F93F837}", IAgCrdnEventIntervalListSignaled)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListSignaled"] = IAgCrdnEventIntervalListSignaled

class IAgCrdnEventIntervalListTimeOffset(object):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EEA120D3-8E9F-419B-B11C-A034007EB2D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceIntervals" : 1,
                             "set_ReferenceIntervals" : 2,
                             "get_TimeOffset" : 3,
                             "set_TimeOffset" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalListTimeOffset._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalListTimeOffset from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListTimeOffset.__dict__ and type(IAgCrdnEventIntervalListTimeOffset.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalListTimeOffset.")
    
    _get_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(IAgCrdnEventIntervalListTimeOffset._metadata, IAgCrdnEventIntervalListTimeOffset._get_ReferenceIntervals_metadata)

    _set_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListTimeOffset._metadata, IAgCrdnEventIntervalListTimeOffset._set_ReferenceIntervals_metadata, referenceIntervals)

    _get_TimeOffset_metadata = { "name" : "TimeOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeOffset(self) -> float:
        """The time offset."""
        return self._intf.get_property(IAgCrdnEventIntervalListTimeOffset._metadata, IAgCrdnEventIntervalListTimeOffset._get_TimeOffset_metadata)

    _set_TimeOffset_metadata = { "name" : "TimeOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalListTimeOffset._metadata, IAgCrdnEventIntervalListTimeOffset._set_TimeOffset_metadata, timeOffset)


agcls.AgClassCatalog.add_catalog_entry("{EEA120D3-8E9F-419B-B11C-A034007EB2D0}", IAgCrdnEventIntervalListTimeOffset)
agcls.AgTypeNameMap["IAgCrdnEventIntervalListTimeOffset"] = IAgCrdnEventIntervalListTimeOffset

class IAgCrdnEventIntervalScaled(object):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FA9613FB-7341-4785-AD95-51CFA2B605BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalInterval" : 1,
                             "set_OriginalInterval" : 2,
                             "get_AbsoluteIncrement" : 3,
                             "set_AbsoluteIncrement" : 4,
                             "get_RelativeIncrement" : 5,
                             "set_RelativeIncrement" : 6,
                             "get_UseAbsoluteIncrement" : 7,
                             "set_UseAbsoluteIncrement" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalScaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalScaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalScaled.__dict__ and type(IAgCrdnEventIntervalScaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalScaled.")
    
    _get_OriginalInterval_metadata = { "name" : "OriginalInterval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalInterval(self) -> "IAgCrdnEventInterval":
        """The original interval."""
        return self._intf.get_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._get_OriginalInterval_metadata)

    _set_OriginalInterval_metadata = { "name" : "OriginalInterval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"IAgCrdnEventInterval") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._set_OriginalInterval_metadata, originalInterval)

    _get_AbsoluteIncrement_metadata = { "name" : "AbsoluteIncrement",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a interval by expanding (or shortening if negative) the original interval by shifting its start/stop times equally by half of specified increment value."""
        return self._intf.get_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._get_AbsoluteIncrement_metadata)

    _set_AbsoluteIncrement_metadata = { "name" : "AbsoluteIncrement",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._set_AbsoluteIncrement_metadata, absoluteIncrement)

    _get_RelativeIncrement_metadata = { "name" : "RelativeIncrement",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        return self._intf.get_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._get_RelativeIncrement_metadata)

    _set_RelativeIncrement_metadata = { "name" : "RelativeIncrement",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._set_RelativeIncrement_metadata, relativeIncrement)

    _get_UseAbsoluteIncrement_metadata = { "name" : "UseAbsoluteIncrement",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        return self._intf.get_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._get_UseAbsoluteIncrement_metadata)

    _set_UseAbsoluteIncrement_metadata = { "name" : "UseAbsoluteIncrement",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalScaled._metadata, IAgCrdnEventIntervalScaled._set_UseAbsoluteIncrement_metadata, useAbsoluteIncrement)


agcls.AgClassCatalog.add_catalog_entry("{FA9613FB-7341-4785-AD95-51CFA2B605BC}", IAgCrdnEventIntervalScaled)
agcls.AgTypeNameMap["IAgCrdnEventIntervalScaled"] = IAgCrdnEventIntervalScaled

class IAgCrdnEventIntervalSignaled(object):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{51B9DE87-9220-40B2-AA57-01F7B17BD945}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalInterval" : 1,
                             "set_OriginalInterval" : 2,
                             "get_SignalSense" : 3,
                             "set_SignalSense" : 4,
                             "get_BaseClockLocation" : 5,
                             "set_BaseClockLocation" : 6,
                             "get_TargetClockLocation" : 7,
                             "set_TargetClockLocation" : 8,
                             "get_SignalDelay" : 9,
                             "set_SignalDelay" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalSignaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalSignaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalSignaled.__dict__ and type(IAgCrdnEventIntervalSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalSignaled.")
    
    _get_OriginalInterval_metadata = { "name" : "OriginalInterval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalInterval(self) -> "IAgCrdnEventInterval":
        """The original interval."""
        return self._intf.get_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._get_OriginalInterval_metadata)

    _set_OriginalInterval_metadata = { "name" : "OriginalInterval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"IAgCrdnEventInterval") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._set_OriginalInterval_metadata, originalInterval)

    _get_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        return self._intf.get_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._get_SignalSense_metadata)

    _set_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._set_SignalSense_metadata, signalSense)

    _get_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._get_BaseClockLocation_metadata)

    _set_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._set_BaseClockLocation_metadata, baseClockLocation)

    _get_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._get_TargetClockLocation_metadata)

    _set_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._set_TargetClockLocation_metadata, targetClockLocation)

    _get_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._get_SignalDelay_metadata)

    _set_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSignalDelay"),) }
    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalSignaled._metadata, IAgCrdnEventIntervalSignaled._set_SignalDelay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{51B9DE87-9220-40B2-AA57-01F7B17BD945}", IAgCrdnEventIntervalSignaled)
agcls.AgTypeNameMap["IAgCrdnEventIntervalSignaled"] = IAgCrdnEventIntervalSignaled

class IAgCrdnEventIntervalSmartInterval(object):
    """A smart interval."""
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceInterval" : 1,
                             "get_DurationAsString" : 2,
                             "set_DurationAsString" : 3,
                             "get_State" : 4,
                             "set_State" : 5,
                             "SetImplicitInterval" : 6,
                             "FindStartTime" : 7,
                             "FindStopTime" : 8,
                             "GetStartEpoch" : 9,
                             "SetStartEpoch" : 10,
                             "GetStopEpoch" : 11,
                             "SetStopEpoch" : 12,
                             "SetExplicitInterval" : 13,
                             "SetStartAndStopEpochs" : 14,
                             "SetStartAndStopTimes" : 15,
                             "SetStartEpochAndDuration" : 16,
                             "SetStartTimeAndDuration" : 17, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalSmartInterval._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalSmartInterval from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalSmartInterval.__dict__ and type(IAgCrdnEventIntervalSmartInterval.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalSmartInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalSmartInterval.")
    
    _get_ReferenceInterval_metadata = { "name" : "ReferenceInterval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceInterval(self) -> "IAgCrdnEventInterval":
        """The reference interval used to compute start/stop times of this interval if the state of the interval is set to implicit."""
        return self._intf.get_property(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._get_ReferenceInterval_metadata)

    _get_DurationAsString_metadata = { "name" : "DurationAsString",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def DurationAsString(self) -> str:
        """The duration of the interval"""
        return self._intf.get_property(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._get_DurationAsString_metadata)

    _set_DurationAsString_metadata = { "name" : "DurationAsString",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @DurationAsString.setter
    def DurationAsString(self, durationAsString:str) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._set_DurationAsString_metadata, durationAsString)

    _get_State_metadata = { "name" : "State",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSmartIntervalState),) }
    @property
    def State(self) -> "AgECrdnSmartIntervalState":
        """A state of the smart interval."""
        return self._intf.get_property(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._get_State_metadata)

    _set_State_metadata = { "name" : "State",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSmartIntervalState),) }
    @State.setter
    def State(self, state:"AgECrdnSmartIntervalState") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._set_State_metadata, state)

    _SetImplicitInterval_metadata = { "name" : "SetImplicitInterval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    def SetImplicitInterval(self, eventInterval:"IAgCrdnEventInterval") -> None:
        """Set the reference interval and changes the state to Implicit."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetImplicitInterval_metadata, eventInterval)

    _FindStartTime_metadata = { "name" : "FindStartTime",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def FindStartTime(self) -> typing.Any:
        """Finds a start time of the interval. An exception is thrown if the start time cannot be determined from the interval's current state."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._FindStartTime_metadata, out_arg())

    _FindStopTime_metadata = { "name" : "FindStopTime",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def FindStopTime(self) -> typing.Any:
        """Finds a stop time of the interval. An exception is thrown if the stop time cannot be determined from the interval's current state."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._FindStopTime_metadata, out_arg())

    _GetStartEpoch_metadata = { "name" : "GetStartEpoch",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetStartEpoch(self) -> "IAgCrdnEventSmartEpoch":
        """Returns a copy of the start epoch. Changes to the epoch will not affect the state of the interval."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._GetStartEpoch_metadata, out_arg())

    _SetStartEpoch_metadata = { "name" : "SetStartEpoch",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventSmartEpoch"),) }
    def SetStartEpoch(self, startEpoch:"IAgCrdnEventSmartEpoch") -> None:
        """Sets a start of the interval using specified epoch component."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetStartEpoch_metadata, startEpoch)

    _GetStopEpoch_metadata = { "name" : "GetStopEpoch",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetStopEpoch(self) -> "IAgCrdnEventSmartEpoch":
        """Returns a copy of the stop epoch. Changes to the epoch will not affect the state of the interval."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._GetStopEpoch_metadata, out_arg())

    _SetStopEpoch_metadata = { "name" : "SetStopEpoch",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventSmartEpoch"),) }
    def SetStopEpoch(self, stopEpoch:"IAgCrdnEventSmartEpoch") -> None:
        """Sets a stop of the interval using specified epoch component."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetStopEpoch_metadata, stopEpoch)

    _SetExplicitInterval_metadata = { "name" : "SetExplicitInterval",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def SetExplicitInterval(self, start:typing.Any, stop:typing.Any) -> None:
        """Set the interval's start and the stop times changes the interval's state to explicit. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetExplicitInterval_metadata, start, stop)

    _SetStartAndStopEpochs_metadata = { "name" : "SetStartAndStopEpochs",
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventSmartEpoch"), agmarshall.AgInterface_in_arg("IAgCrdnEventSmartEpoch"),) }
    def SetStartAndStopEpochs(self, refStartEpoch:"IAgCrdnEventSmartEpoch", refStopEpoch:"IAgCrdnEventSmartEpoch") -> None:
        """Sets the interval's start and stop epochs as two smart epoch components. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetStartAndStopEpochs_metadata, refStartEpoch, refStopEpoch)

    _SetStartAndStopTimes_metadata = { "name" : "SetStartAndStopTimes",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def SetStartAndStopTimes(self, startTime:typing.Any, stopTime:typing.Any) -> None:
        """Sets the interval's start and stop epochs as explicit times. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetStartAndStopTimes_metadata, startTime, stopTime)

    _SetStartEpochAndDuration_metadata = { "name" : "SetStartEpochAndDuration",
            "arg_types" : (agcom.PVOID, agcom.BSTR,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventSmartEpoch"), agmarshall.BSTR_arg,) }
    def SetStartEpochAndDuration(self, refStartEpoch:"IAgCrdnEventSmartEpoch", durationStr:str) -> None:
        """Sets the interval's start epoch and the interval's duration."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetStartEpochAndDuration_metadata, refStartEpoch, durationStr)

    _SetStartTimeAndDuration_metadata = { "name" : "SetStartTimeAndDuration",
            "arg_types" : (agcom.VARIANT, agcom.BSTR,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.BSTR_arg,) }
    def SetStartTimeAndDuration(self, epoch:typing.Any, durationStr:str) -> None:
        """Sets the interval's start time and the interval's duration."""
        return self._intf.invoke(IAgCrdnEventIntervalSmartInterval._metadata, IAgCrdnEventIntervalSmartInterval._SetStartTimeAndDuration_metadata, epoch, durationStr)


agcls.AgClassCatalog.add_catalog_entry("{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}", IAgCrdnEventIntervalSmartInterval)
agcls.AgTypeNameMap["IAgCrdnEventIntervalSmartInterval"] = IAgCrdnEventIntervalSmartInterval

class IAgCrdnEventIntervalTimeOffset(object):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceInterval" : 1,
                             "set_ReferenceInterval" : 2,
                             "get_TimeOffset" : 3,
                             "set_TimeOffset" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventIntervalTimeOffset._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventIntervalTimeOffset from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalTimeOffset.__dict__ and type(IAgCrdnEventIntervalTimeOffset.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventIntervalTimeOffset.")
    
    _get_ReferenceInterval_metadata = { "name" : "ReferenceInterval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceInterval(self) -> "IAgCrdnEventInterval":
        """The reference interval."""
        return self._intf.get_property(IAgCrdnEventIntervalTimeOffset._metadata, IAgCrdnEventIntervalTimeOffset._get_ReferenceInterval_metadata)

    _set_ReferenceInterval_metadata = { "name" : "ReferenceInterval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    @ReferenceInterval.setter
    def ReferenceInterval(self, referenceInterval:"IAgCrdnEventInterval") -> None:
        return self._intf.set_property(IAgCrdnEventIntervalTimeOffset._metadata, IAgCrdnEventIntervalTimeOffset._set_ReferenceInterval_metadata, referenceInterval)

    _get_TimeOffset_metadata = { "name" : "TimeOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeOffset(self) -> float:
        """The time offset value."""
        return self._intf.get_property(IAgCrdnEventIntervalTimeOffset._metadata, IAgCrdnEventIntervalTimeOffset._get_TimeOffset_metadata)

    _set_TimeOffset_metadata = { "name" : "TimeOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        return self._intf.set_property(IAgCrdnEventIntervalTimeOffset._metadata, IAgCrdnEventIntervalTimeOffset._set_TimeOffset_metadata, timeOffset)


agcls.AgClassCatalog.add_catalog_entry("{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}", IAgCrdnEventIntervalTimeOffset)
agcls.AgTypeNameMap["IAgCrdnEventIntervalTimeOffset"] = IAgCrdnEventIntervalTimeOffset

class IAgCrdnEventSignaled(object):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginalTimeInstant" : 1,
                             "set_OriginalTimeInstant" : 2,
                             "get_SignalSense" : 3,
                             "set_SignalSense" : 4,
                             "get_BaseClockLocation" : 5,
                             "set_BaseClockLocation" : 6,
                             "get_TargetClockLocation" : 7,
                             "set_TargetClockLocation" : 8,
                             "get_SignalDelay" : 9,
                             "set_SignalDelay" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventSignaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventSignaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventSignaled.__dict__ and type(IAgCrdnEventSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventSignaled.")
    
    _get_OriginalTimeInstant_metadata = { "name" : "OriginalTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginalTimeInstant(self) -> "IAgCrdnEvent":
        """The original time instant."""
        return self._intf.get_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._get_OriginalTimeInstant_metadata)

    _set_OriginalTimeInstant_metadata = { "name" : "OriginalTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @OriginalTimeInstant.setter
    def OriginalTimeInstant(self, originalTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._set_OriginalTimeInstant_metadata, originalTimeInstant)

    _get_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        return self._intf.get_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._get_SignalSense_metadata)

    _set_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        return self._intf.set_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._set_SignalSense_metadata, signalSense)

    _get_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._get_BaseClockLocation_metadata)

    _set_BaseClockLocation_metadata = { "name" : "BaseClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._set_BaseClockLocation_metadata, baseClockLocation)

    _get_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._get_TargetClockLocation_metadata)

    _set_TargetClockLocation_metadata = { "name" : "TargetClockLocation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._set_TargetClockLocation_metadata, targetClockLocation)

    _get_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._get_SignalDelay_metadata)

    _set_SignalDelay_metadata = { "name" : "SignalDelay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSignalDelay"),) }
    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        return self._intf.set_property(IAgCrdnEventSignaled._metadata, IAgCrdnEventSignaled._set_SignalDelay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}", IAgCrdnEventSignaled)
agcls.AgTypeNameMap["IAgCrdnEventSignaled"] = IAgCrdnEventSignaled

class IAgCrdnEventSmartEpoch(object):
    """A smart epoch."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4C5542F5-5B94-498B-90BC-CC7CB7C86629}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TimeInstant" : 1,
                             "get_ReferenceEvent" : 2,
                             "get_State" : 3,
                             "set_State" : 4,
                             "SetExplicitTime" : 5,
                             "SetImplicitTime" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventSmartEpoch._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventSmartEpoch from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventSmartEpoch.__dict__ and type(IAgCrdnEventSmartEpoch.__dict__[attrname]) == property:
            return IAgCrdnEventSmartEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventSmartEpoch.")
    
    _get_TimeInstant_metadata = { "name" : "TimeInstant",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def TimeInstant(self) -> typing.Any:
        """Represents the time instant if the state is set to explicit."""
        return self._intf.get_property(IAgCrdnEventSmartEpoch._metadata, IAgCrdnEventSmartEpoch._get_TimeInstant_metadata)

    _get_ReferenceEvent_metadata = { "name" : "ReferenceEvent",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceEvent(self) -> "IAgCrdnEvent":
        """A reference event object used to compute time instant if the state is set to implicit."""
        return self._intf.get_property(IAgCrdnEventSmartEpoch._metadata, IAgCrdnEventSmartEpoch._get_ReferenceEvent_metadata)

    _get_State_metadata = { "name" : "State",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSmartEpochState),) }
    @property
    def State(self) -> "AgECrdnSmartEpochState":
        """State of the event."""
        return self._intf.get_property(IAgCrdnEventSmartEpoch._metadata, IAgCrdnEventSmartEpoch._get_State_metadata)

    _set_State_metadata = { "name" : "State",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSmartEpochState),) }
    @State.setter
    def State(self, state:"AgECrdnSmartEpochState") -> None:
        return self._intf.set_property(IAgCrdnEventSmartEpoch._metadata, IAgCrdnEventSmartEpoch._set_State_metadata, state)

    _SetExplicitTime_metadata = { "name" : "SetExplicitTime",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def SetExplicitTime(self, epoch:typing.Any) -> None:
        """Sets explicit time instant and the smart epoch's state to Explicit."""
        return self._intf.invoke(IAgCrdnEventSmartEpoch._metadata, IAgCrdnEventSmartEpoch._SetExplicitTime_metadata, epoch)

    _SetImplicitTime_metadata = { "name" : "SetImplicitTime",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    def SetImplicitTime(self, eventEpoch:"IAgCrdnEvent") -> None:
        """Sets the reference event and the smart epoch's state to Implicit."""
        return self._intf.invoke(IAgCrdnEventSmartEpoch._metadata, IAgCrdnEventSmartEpoch._SetImplicitTime_metadata, eventEpoch)


agcls.AgClassCatalog.add_catalog_entry("{4C5542F5-5B94-498B-90BC-CC7CB7C86629}", IAgCrdnEventSmartEpoch)
agcls.AgTypeNameMap["IAgCrdnEventSmartEpoch"] = IAgCrdnEventSmartEpoch

class IAgCrdnEventStartStopTime(object):
    """Event is either start or stop time selected from a reference interval."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB96850C-18E7-4269-8D35-67FB7E55BD59}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_UseStart" : 1,
                             "set_UseStart" : 2,
                             "get_ReferenceEventInterval" : 3,
                             "set_ReferenceEventInterval" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventStartStopTime._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventStartStopTime from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventStartStopTime.__dict__ and type(IAgCrdnEventStartStopTime.__dict__[attrname]) == property:
            return IAgCrdnEventStartStopTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventStartStopTime.")
    
    _get_UseStart_metadata = { "name" : "UseStart",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseStart(self) -> bool:
        """Indicates whether to use start (true) or stop (false)."""
        return self._intf.get_property(IAgCrdnEventStartStopTime._metadata, IAgCrdnEventStartStopTime._get_UseStart_metadata)

    _set_UseStart_metadata = { "name" : "UseStart",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseStart.setter
    def UseStart(self, useStart:bool) -> None:
        return self._intf.set_property(IAgCrdnEventStartStopTime._metadata, IAgCrdnEventStartStopTime._set_UseStart_metadata, useStart)

    _get_ReferenceEventInterval_metadata = { "name" : "ReferenceEventInterval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceEventInterval(self) -> "IAgCrdnEventInterval":
        """The reference interval."""
        return self._intf.get_property(IAgCrdnEventStartStopTime._metadata, IAgCrdnEventStartStopTime._get_ReferenceEventInterval_metadata)

    _set_ReferenceEventInterval_metadata = { "name" : "ReferenceEventInterval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventInterval"),) }
    @ReferenceEventInterval.setter
    def ReferenceEventInterval(self, referenceEventInterval:"IAgCrdnEventInterval") -> None:
        return self._intf.set_property(IAgCrdnEventStartStopTime._metadata, IAgCrdnEventStartStopTime._set_ReferenceEventInterval_metadata, referenceEventInterval)


agcls.AgClassCatalog.add_catalog_entry("{EB96850C-18E7-4269-8D35-67FB7E55BD59}", IAgCrdnEventStartStopTime)
agcls.AgTypeNameMap["IAgCrdnEventStartStopTime"] = IAgCrdnEventStartStopTime

class IAgCrdnEventTimeOffset(object):
    """Event at fixed offset from specified reference event."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB95E24E-6BDF-434C-A278-BF64475E4EB5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceTimeInstant" : 1,
                             "set_ReferenceTimeInstant" : 2,
                             "get_TimeOffset2" : 3,
                             "set_TimeOffset2" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnEventTimeOffset._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnEventTimeOffset from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventTimeOffset.__dict__ and type(IAgCrdnEventTimeOffset.__dict__[attrname]) == property:
            return IAgCrdnEventTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnEventTimeOffset.")
    
    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        return self._intf.get_property(IAgCrdnEventTimeOffset._metadata, IAgCrdnEventTimeOffset._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnEventTimeOffset._metadata, IAgCrdnEventTimeOffset._set_ReferenceTimeInstant_metadata, referenceTimeInstant)

    _get_TimeOffset2_metadata = { "name" : "TimeOffset2",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeOffset2(self) -> float:
        """The time offset from the ReferenceTimeInstant. The value is in ``TimeUnit`` dimension."""
        return self._intf.get_property(IAgCrdnEventTimeOffset._metadata, IAgCrdnEventTimeOffset._get_TimeOffset2_metadata)

    _set_TimeOffset2_metadata = { "name" : "TimeOffset2",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeOffset2.setter
    def TimeOffset2(self, timeOffset2:float) -> None:
        return self._intf.set_property(IAgCrdnEventTimeOffset._metadata, IAgCrdnEventTimeOffset._set_TimeOffset2_metadata, timeOffset2)


agcls.AgClassCatalog.add_catalog_entry("{EB95E24E-6BDF-434C-A278-BF64475E4EB5}", IAgCrdnEventTimeOffset)
agcls.AgTypeNameMap["IAgCrdnEventTimeOffset"] = IAgCrdnEventTimeOffset

class IAgCrdnFirstIntervalsFilter(object):
    """The filter selects a portion of first intervals."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{032A1F18-16B1-48B3-BB59-AFE83A834880}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_MaximumNumberOfIntervals" : 1,
                             "set_MaximumNumberOfIntervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnFirstIntervalsFilter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnFirstIntervalsFilter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnFirstIntervalsFilter.__dict__ and type(IAgCrdnFirstIntervalsFilter.__dict__[attrname]) == property:
            return IAgCrdnFirstIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnFirstIntervalsFilter.")
    
    _get_MaximumNumberOfIntervals_metadata = { "name" : "MaximumNumberOfIntervals",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        return self._intf.get_property(IAgCrdnFirstIntervalsFilter._metadata, IAgCrdnFirstIntervalsFilter._get_MaximumNumberOfIntervals_metadata)

    _set_MaximumNumberOfIntervals_metadata = { "name" : "MaximumNumberOfIntervals",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(IAgCrdnFirstIntervalsFilter._metadata, IAgCrdnFirstIntervalsFilter._set_MaximumNumberOfIntervals_metadata, maximumNumberOfIntervals)


agcls.AgClassCatalog.add_catalog_entry("{032A1F18-16B1-48B3-BB59-AFE83A834880}", IAgCrdnFirstIntervalsFilter)
agcls.AgTypeNameMap["IAgCrdnFirstIntervalsFilter"] = IAgCrdnFirstIntervalsFilter

class IAgCrdnGapsFilter(object):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{97B393F6-5E70-4D67-80C1-F85080D818F3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_DurationKind" : 1,
                             "set_DurationKind" : 2,
                             "get_GapDuration" : 3,
                             "set_GapDuration" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnGapsFilter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnGapsFilter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGapsFilter.__dict__ and type(IAgCrdnGapsFilter.__dict__[attrname]) == property:
            return IAgCrdnGapsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnGapsFilter.")
    
    _get_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(IAgCrdnGapsFilter._metadata, IAgCrdnGapsFilter._get_DurationKind_metadata)

    _set_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        return self._intf.set_property(IAgCrdnGapsFilter._metadata, IAgCrdnGapsFilter._set_DurationKind_metadata, durationKind)

    _get_GapDuration_metadata = { "name" : "GapDuration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def GapDuration(self) -> float:
        """Duration of the gap."""
        return self._intf.get_property(IAgCrdnGapsFilter._metadata, IAgCrdnGapsFilter._get_GapDuration_metadata)

    _set_GapDuration_metadata = { "name" : "GapDuration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @GapDuration.setter
    def GapDuration(self, gapDuration:float) -> None:
        return self._intf.set_property(IAgCrdnGapsFilter._metadata, IAgCrdnGapsFilter._set_GapDuration_metadata, gapDuration)


agcls.AgClassCatalog.add_catalog_entry("{97B393F6-5E70-4D67-80C1-F85080D818F3}", IAgCrdnGapsFilter)
agcls.AgTypeNameMap["IAgCrdnGapsFilter"] = IAgCrdnGapsFilter

class IAgCrdnIntegral(object):
    """Represents a base class for integral definitions."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{61D34977-CC2E-43C1-9103-692FF9B3DEF0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnIntegral._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnIntegral from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntegral.__dict__ and type(IAgCrdnIntegral.__dict__[attrname]) == property:
            return IAgCrdnIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnIntegral.")
    

agcls.AgClassCatalog.add_catalog_entry("{61D34977-CC2E-43C1-9103-692FF9B3DEF0}", IAgCrdnIntegral)
agcls.AgTypeNameMap["IAgCrdnIntegral"] = IAgCrdnIntegral

class IAgCrdnIntegralBasic(object):
    """Integral definition determines how scalar calculation is numerically integrated."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{19DEEA25-F655-487B-86FF-429B55093F77}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "set_Type" : 2,
                             "get_Tolerance" : 3,
                             "set_Tolerance" : 4,
                             "get_MaximumIterations" : 5,
                             "set_MaximumIterations" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnIntegralBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnIntegralBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntegralBasic.__dict__ and type(IAgCrdnIntegralBasic.__dict__[attrname]) == property:
            return IAgCrdnIntegralBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnIntegralBasic.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntegralType),) }
    @property
    def Type(self) -> "AgECrdnIntegralType":
        """Get the integral type which determines the method of integration and can be set to trapezoidal, Simplson or adaptive Lobatto."""
        return self._intf.get_property(IAgCrdnIntegralBasic._metadata, IAgCrdnIntegralBasic._get_Type_metadata)

    _set_Type_metadata = { "name" : "Type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntegralType),) }
    @Type.setter
    def Type(self, type:"AgECrdnIntegralType") -> None:
        return self._intf.set_property(IAgCrdnIntegralBasic._metadata, IAgCrdnIntegralBasic._set_Type_metadata, type)

    _get_Tolerance_metadata = { "name" : "Tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Tolerance(self) -> float:
        """Get the tolerance which determines how accurate integral is computed by finding relative difference between refined and unrefined integral evaluations. Only available if Adaptive Lobatto is selected as the integral type."""
        return self._intf.get_property(IAgCrdnIntegralBasic._metadata, IAgCrdnIntegralBasic._get_Tolerance_metadata)

    _set_Tolerance_metadata = { "name" : "Tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Tolerance.setter
    def Tolerance(self, tolerance:float) -> None:
        return self._intf.set_property(IAgCrdnIntegralBasic._metadata, IAgCrdnIntegralBasic._set_Tolerance_metadata, tolerance)

    _get_MaximumIterations_metadata = { "name" : "MaximumIterations",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def MaximumIterations(self) -> int:
        """Get the number of iteration which determines how many refinement iterations are allowed. Only available if Adaptive Lobatto is selected as the integral type."""
        return self._intf.get_property(IAgCrdnIntegralBasic._metadata, IAgCrdnIntegralBasic._get_MaximumIterations_metadata)

    _set_MaximumIterations_metadata = { "name" : "MaximumIterations",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @MaximumIterations.setter
    def MaximumIterations(self, maximumIterations:int) -> None:
        return self._intf.set_property(IAgCrdnIntegralBasic._metadata, IAgCrdnIntegralBasic._set_MaximumIterations_metadata, maximumIterations)


agcls.AgClassCatalog.add_catalog_entry("{19DEEA25-F655-487B-86FF-429B55093F77}", IAgCrdnIntegralBasic)
agcls.AgTypeNameMap["IAgCrdnIntegralBasic"] = IAgCrdnIntegralBasic

class IAgCrdnInterp(object):
    """Represents a base class for interpolation definitions."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnInterp._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnInterp from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInterp.__dict__ and type(IAgCrdnInterp.__dict__[attrname]) == property:
            return IAgCrdnInterp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnInterp.")
    

agcls.AgClassCatalog.add_catalog_entry("{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}", IAgCrdnInterp)
agcls.AgTypeNameMap["IAgCrdnInterp"] = IAgCrdnInterp

class IAgCrdnInterpBasic(object):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "set_Type" : 2,
                             "get_Order" : 3,
                             "set_Order" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnInterpBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnInterpBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInterpBasic.__dict__ and type(IAgCrdnInterpBasic.__dict__[attrname]) == property:
            return IAgCrdnInterpBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnInterpBasic.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnInterpolatorType),) }
    @property
    def Type(self) -> "AgECrdnInterpolatorType":
        """Get the interpolation type, which can be Lagrange or Hermite interpolation. See STK help on interpolation for further details."""
        return self._intf.get_property(IAgCrdnInterpBasic._metadata, IAgCrdnInterpBasic._get_Type_metadata)

    _set_Type_metadata = { "name" : "Type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnInterpolatorType),) }
    @Type.setter
    def Type(self, type:"AgECrdnInterpolatorType") -> None:
        return self._intf.set_property(IAgCrdnInterpBasic._metadata, IAgCrdnInterpBasic._set_Type_metadata, type)

    _get_Order_metadata = { "name" : "Order",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def Order(self) -> int:
        """Get the interpolation order, which determines the order of interpolation polynomial and is related to how many samples are used during interpolation. See STK help on interpolation for further details."""
        return self._intf.get_property(IAgCrdnInterpBasic._metadata, IAgCrdnInterpBasic._get_Order_metadata)

    _set_Order_metadata = { "name" : "Order",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @Order.setter
    def Order(self, order:int) -> None:
        return self._intf.set_property(IAgCrdnInterpBasic._metadata, IAgCrdnInterpBasic._set_Order_metadata, order)


agcls.AgClassCatalog.add_catalog_entry("{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}", IAgCrdnInterpBasic)
agcls.AgTypeNameMap["IAgCrdnInterpBasic"] = IAgCrdnInterpBasic

class IAgCrdnIntervalsFilter(object):
    """The filter selects intervals of at least/most certain duration."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_DurationKind" : 1,
                             "set_DurationKind" : 2,
                             "get_IntervalDuration" : 3,
                             "set_IntervalDuration" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnIntervalsFilter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnIntervalsFilter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalsFilter.__dict__ and type(IAgCrdnIntervalsFilter.__dict__[attrname]) == property:
            return IAgCrdnIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnIntervalsFilter.")
    
    _get_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(IAgCrdnIntervalsFilter._metadata, IAgCrdnIntervalsFilter._get_DurationKind_metadata)

    _set_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        return self._intf.set_property(IAgCrdnIntervalsFilter._metadata, IAgCrdnIntervalsFilter._set_DurationKind_metadata, durationKind)

    _get_IntervalDuration_metadata = { "name" : "IntervalDuration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def IntervalDuration(self) -> float:
        """The interval duration."""
        return self._intf.get_property(IAgCrdnIntervalsFilter._metadata, IAgCrdnIntervalsFilter._get_IntervalDuration_metadata)

    _set_IntervalDuration_metadata = { "name" : "IntervalDuration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        return self._intf.set_property(IAgCrdnIntervalsFilter._metadata, IAgCrdnIntervalsFilter._set_IntervalDuration_metadata, intervalDuration)


agcls.AgClassCatalog.add_catalog_entry("{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}", IAgCrdnIntervalsFilter)
agcls.AgTypeNameMap["IAgCrdnIntervalsFilter"] = IAgCrdnIntervalsFilter

class IAgCrdnLastIntervalsFilter(object):
    """The filter selects a portion of last intervals."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_MaximumNumberOfIntervals" : 1,
                             "set_MaximumNumberOfIntervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnLastIntervalsFilter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnLastIntervalsFilter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnLastIntervalsFilter.__dict__ and type(IAgCrdnLastIntervalsFilter.__dict__[attrname]) == property:
            return IAgCrdnLastIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnLastIntervalsFilter.")
    
    _get_MaximumNumberOfIntervals_metadata = { "name" : "MaximumNumberOfIntervals",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        return self._intf.get_property(IAgCrdnLastIntervalsFilter._metadata, IAgCrdnLastIntervalsFilter._get_MaximumNumberOfIntervals_metadata)

    _set_MaximumNumberOfIntervals_metadata = { "name" : "MaximumNumberOfIntervals",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(IAgCrdnLastIntervalsFilter._metadata, IAgCrdnLastIntervalsFilter._set_MaximumNumberOfIntervals_metadata, maximumNumberOfIntervals)


agcls.AgClassCatalog.add_catalog_entry("{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}", IAgCrdnLastIntervalsFilter)
agcls.AgTypeNameMap["IAgCrdnLastIntervalsFilter"] = IAgCrdnLastIntervalsFilter

class IAgCrdnParameterSet(object):
    """Parameter set contains various sets of scalar computations."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{285664E8-604B-4C0A-9ED0-5EE27CA1539D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Type" : 1,
                             "get_Labels" : 2,
                             "get_Dimensions" : 3,
                             "get_ScalarNames" : 4,
                             "Calculate" : 5,
                             "CalculateWithDerivative" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSet._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSet from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSet.__dict__ and type(IAgCrdnParameterSet.__dict__[attrname]) == property:
            return IAgCrdnParameterSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSet.")
    
    _get_Type_metadata = { "name" : "Type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnParameterSetType),) }
    @property
    def Type(self) -> "AgECrdnParameterSetType":
        """Get the type of parameter set."""
        return self._intf.get_property(IAgCrdnParameterSet._metadata, IAgCrdnParameterSet._get_Type_metadata)

    _get_Labels_metadata = { "name" : "Labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Labels(self) -> list:
        """Get the labels identifying hierarchy of representations within parameter set."""
        return self._intf.get_property(IAgCrdnParameterSet._metadata, IAgCrdnParameterSet._get_Labels_metadata)

    _get_Dimensions_metadata = { "name" : "Dimensions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Dimensions(self) -> list:
        """Get the names identifying types of dimensions of individual scalars within parameter set."""
        return self._intf.get_property(IAgCrdnParameterSet._metadata, IAgCrdnParameterSet._get_Dimensions_metadata)

    _get_ScalarNames_metadata = { "name" : "ScalarNames",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def ScalarNames(self) -> list:
        """Get the names identifying individual scalars within parameter set."""
        return self._intf.get_property(IAgCrdnParameterSet._metadata, IAgCrdnParameterSet._get_ScalarNames_metadata)

    _Calculate_metadata = { "name" : "Calculate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def Calculate(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars within parameter set at the specified time."""
        return self._intf.invoke(IAgCrdnParameterSet._metadata, IAgCrdnParameterSet._Calculate_metadata, epoch, out_arg())

    _CalculateWithDerivative_metadata = { "name" : "CalculateWithDerivative",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def CalculateWithDerivative(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars and their time derivatives within parameter set at the specified time."""
        return self._intf.invoke(IAgCrdnParameterSet._metadata, IAgCrdnParameterSet._CalculateWithDerivative_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{285664E8-604B-4C0A-9ED0-5EE27CA1539D}", IAgCrdnParameterSet)
agcls.AgTypeNameMap["IAgCrdnParameterSet"] = IAgCrdnParameterSet

class IAgCrdnParameterSetAttitude(object):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8B7DCF32-3CA4-4794-8468-81A3627B4043}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Axes" : 1,
                             "set_Axes" : 2,
                             "get_ReferenceAxes" : 3,
                             "set_ReferenceAxes" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSetAttitude._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSetAttitude from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetAttitude.__dict__ and type(IAgCrdnParameterSetAttitude.__dict__[attrname]) == property:
            return IAgCrdnParameterSetAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSetAttitude.")
    
    _get_Axes_metadata = { "name" : "Axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Axes(self) -> "IAgCrdnAxes":
        """Get the axes for which attitude representations are computed."""
        return self._intf.get_property(IAgCrdnParameterSetAttitude._metadata, IAgCrdnParameterSetAttitude._get_Axes_metadata)

    _set_Axes_metadata = { "name" : "Axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    @Axes.setter
    def Axes(self, axes:"IAgCrdnAxes") -> None:
        return self._intf.set_property(IAgCrdnParameterSetAttitude._metadata, IAgCrdnParameterSetAttitude._set_Axes_metadata, axes)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """Get the reference axes relative to which attitude representations are computed."""
        return self._intf.get_property(IAgCrdnParameterSetAttitude._metadata, IAgCrdnParameterSetAttitude._get_ReferenceAxes_metadata)

    _set_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        return self._intf.set_property(IAgCrdnParameterSetAttitude._metadata, IAgCrdnParameterSetAttitude._set_ReferenceAxes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{8B7DCF32-3CA4-4794-8468-81A3627B4043}", IAgCrdnParameterSetAttitude)
agcls.AgTypeNameMap["IAgCrdnParameterSetAttitude"] = IAgCrdnParameterSetAttitude

class IAgCrdnParameterSetFactory(object):
    """The factory is used to create instances of available parameter set types."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4D20E85F-1DEA-4963-9114-6B0407E53C5E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateParameterSetAttitude" : 2,
                             "CreateParameterSetGroundTrajectory" : 3,
                             "CreateParameterSetTrajectory" : 4,
                             "CreateParameterSetOrbit" : 5,
                             "CreateParameterSetVector" : 6,
                             "IsTypeSupported" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSetFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSetFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetFactory.__dict__ and type(IAgCrdnParameterSetFactory.__dict__[attrname]) == property:
            return IAgCrdnParameterSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSetFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnParameterSetType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnParameterSetType") -> "IAgCrdnParameterSet":
        """Creates and registers a parameter set using specified name and description."""
        return self._intf.invoke(IAgCrdnParameterSetFactory._metadata, IAgCrdnParameterSetFactory._Create_metadata, name, description, type, out_arg())

    _CreateParameterSetAttitude_metadata = { "name" : "CreateParameterSetAttitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateParameterSetAttitude(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying one set of axes in reference to another."""
        return self._intf.invoke(IAgCrdnParameterSetFactory._metadata, IAgCrdnParameterSetFactory._CreateParameterSetAttitude_metadata, name, description, out_arg())

    _CreateParameterSetGroundTrajectory_metadata = { "name" : "CreateParameterSetGroundTrajectory",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateParameterSetGroundTrajectory(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying location in reference central body."""
        return self._intf.invoke(IAgCrdnParameterSetFactory._metadata, IAgCrdnParameterSetFactory._CreateParameterSetGroundTrajectory_metadata, name, description, out_arg())

    _CreateParameterSetTrajectory_metadata = { "name" : "CreateParameterSetTrajectory",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateParameterSetTrajectory(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying location in reference coordinate system."""
        return self._intf.invoke(IAgCrdnParameterSetFactory._metadata, IAgCrdnParameterSetFactory._CreateParameterSetTrajectory_metadata, name, description, out_arg())

    _CreateParameterSetOrbit_metadata = { "name" : "CreateParameterSetOrbit",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateParameterSetOrbit(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying orbiting point and its central body."""
        return self._intf.invoke(IAgCrdnParameterSetFactory._metadata, IAgCrdnParameterSetFactory._CreateParameterSetOrbit_metadata, name, description, out_arg())

    _CreateParameterSetVector_metadata = { "name" : "CreateParameterSetVector",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateParameterSetVector(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying vector in reference axes."""
        return self._intf.invoke(IAgCrdnParameterSetFactory._metadata, IAgCrdnParameterSetFactory._CreateParameterSetVector_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnParameterSetType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnParameterSetType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnParameterSetFactory._metadata, IAgCrdnParameterSetFactory._IsTypeSupported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4D20E85F-1DEA-4963-9114-6B0407E53C5E}", IAgCrdnParameterSetFactory)
agcls.AgTypeNameMap["IAgCrdnParameterSetFactory"] = IAgCrdnParameterSetFactory

class IAgCrdnParameterSetGroundTrajectory(object):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{53ABEB95-F846-4574-BA87-C76220FDC19F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Location" : 1,
                             "set_Location" : 2,
                             "get_CentralBody" : 3,
                             "set_CentralBody" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSetGroundTrajectory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSetGroundTrajectory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetGroundTrajectory.__dict__ and type(IAgCrdnParameterSetGroundTrajectory.__dict__[attrname]) == property:
            return IAgCrdnParameterSetGroundTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSetGroundTrajectory.")
    
    _get_Location_metadata = { "name" : "Location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Location(self) -> "IAgCrdnPoint":
        """Get the point for which ground trajectory representations are computed."""
        return self._intf.get_property(IAgCrdnParameterSetGroundTrajectory._metadata, IAgCrdnParameterSetGroundTrajectory._get_Location_metadata)

    _set_Location_metadata = { "name" : "Location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @Location.setter
    def Location(self, location:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnParameterSetGroundTrajectory._metadata, IAgCrdnParameterSetGroundTrajectory._set_Location_metadata, location)

    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which ground trajectory representations are computed. Both the central body reference shape and its CBF (central body centered fixed) system are used by this parameter set."""
        return self._intf.get_property(IAgCrdnParameterSetGroundTrajectory._metadata, IAgCrdnParameterSetGroundTrajectory._get_CentralBody_metadata)

    _set_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        return self._intf.set_property(IAgCrdnParameterSetGroundTrajectory._metadata, IAgCrdnParameterSetGroundTrajectory._set_CentralBody_metadata, centralBody)


agcls.AgClassCatalog.add_catalog_entry("{53ABEB95-F846-4574-BA87-C76220FDC19F}", IAgCrdnParameterSetGroundTrajectory)
agcls.AgTypeNameMap["IAgCrdnParameterSetGroundTrajectory"] = IAgCrdnParameterSetGroundTrajectory

class IAgCrdnParameterSetOrbit(object):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{141AEAB7-C017-4044-BE2C-EFE4AD724022}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OrbitingPoint" : 1,
                             "set_OrbitingPoint" : 2,
                             "get_ReferenceSystem" : 3,
                             "set_ReferenceSystem" : 4,
                             "get_GravitationalParameter" : 5,
                             "set_GravitationalParameter" : 6,
                             "get_CentralBody" : 7,
                             "set_CentralBody" : 8,
                             "get_UseCentralBodyGravitationalParameter" : 9,
                             "set_UseCentralBodyGravitationalParameter" : 10,
                             "get_UseCentralBodyInertial" : 11,
                             "set_UseCentralBodyInertial" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSetOrbit._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSetOrbit from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetOrbit.__dict__ and type(IAgCrdnParameterSetOrbit.__dict__[attrname]) == property:
            return IAgCrdnParameterSetOrbit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSetOrbit.")
    
    _get_OrbitingPoint_metadata = { "name" : "OrbitingPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OrbitingPoint(self) -> "IAgCrdnPoint":
        """Get the point for which orbital parameters are computed."""
        return self._intf.get_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._get_OrbitingPoint_metadata)

    _set_OrbitingPoint_metadata = { "name" : "OrbitingPoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @OrbitingPoint.setter
    def OrbitingPoint(self, orbitingPoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._set_OrbitingPoint_metadata, orbitingPoint)

    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which orbital parameters are computed. Only used if the option to specify reference system is selected."""
        return self._intf.get_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._set_ReferenceSystem_metadata, referenceSystem)

    _get_GravitationalParameter_metadata = { "name" : "GravitationalParameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def GravitationalParameter(self) -> float:
        """Get the gravitational parameter for the mass relative to which orbital parameters are computed. Only used if the option to specify gravitational parameter is selected."""
        return self._intf.get_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._get_GravitationalParameter_metadata)

    _set_GravitationalParameter_metadata = { "name" : "GravitationalParameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @GravitationalParameter.setter
    def GravitationalParameter(self, gravitationalParameter:float) -> None:
        return self._intf.set_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._set_GravitationalParameter_metadata, gravitationalParameter)

    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which orbital parameters are computed."""
        return self._intf.get_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._get_CentralBody_metadata)

    _set_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        return self._intf.set_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._set_CentralBody_metadata, centralBody)

    _get_UseCentralBodyGravitationalParameter_metadata = { "name" : "UseCentralBodyGravitationalParameter",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCentralBodyGravitationalParameter(self) -> bool:
        """Get the option that determines whether to specify the gravitational parameter value or to inherit it from the central body."""
        return self._intf.get_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._get_UseCentralBodyGravitationalParameter_metadata)

    _set_UseCentralBodyGravitationalParameter_metadata = { "name" : "UseCentralBodyGravitationalParameter",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCentralBodyGravitationalParameter.setter
    def UseCentralBodyGravitationalParameter(self, useCentralBodyGravitationalParameter:bool) -> None:
        return self._intf.set_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._set_UseCentralBodyGravitationalParameter_metadata, useCentralBodyGravitationalParameter)

    _get_UseCentralBodyInertial_metadata = { "name" : "UseCentralBodyInertial",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCentralBodyInertial(self) -> bool:
        """Get the option that determines whether to specify the reference coordinate system or to the inherit inertial reference system from the central body."""
        return self._intf.get_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._get_UseCentralBodyInertial_metadata)

    _set_UseCentralBodyInertial_metadata = { "name" : "UseCentralBodyInertial",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCentralBodyInertial.setter
    def UseCentralBodyInertial(self, useCentralBodyInertial:bool) -> None:
        return self._intf.set_property(IAgCrdnParameterSetOrbit._metadata, IAgCrdnParameterSetOrbit._set_UseCentralBodyInertial_metadata, useCentralBodyInertial)


agcls.AgClassCatalog.add_catalog_entry("{141AEAB7-C017-4044-BE2C-EFE4AD724022}", IAgCrdnParameterSetOrbit)
agcls.AgTypeNameMap["IAgCrdnParameterSetOrbit"] = IAgCrdnParameterSetOrbit

class IAgCrdnParameterSetTrajectory(object):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0FE9C601-61BB-4579-B91F-B1123A19AFB4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Point" : 1,
                             "set_Point" : 2,
                             "get_ReferenceSystem" : 3,
                             "set_ReferenceSystem" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSetTrajectory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSetTrajectory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetTrajectory.__dict__ and type(IAgCrdnParameterSetTrajectory.__dict__[attrname]) == property:
            return IAgCrdnParameterSetTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSetTrajectory.")
    
    _get_Point_metadata = { "name" : "Point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Point(self) -> "IAgCrdnPoint":
        """Get the point for which trajectory representations are computed."""
        return self._intf.get_property(IAgCrdnParameterSetTrajectory._metadata, IAgCrdnParameterSetTrajectory._get_Point_metadata)

    _set_Point_metadata = { "name" : "Point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @Point.setter
    def Point(self, point:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnParameterSetTrajectory._metadata, IAgCrdnParameterSetTrajectory._set_Point_metadata, point)

    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system relative to which trajectory representations are computed."""
        return self._intf.get_property(IAgCrdnParameterSetTrajectory._metadata, IAgCrdnParameterSetTrajectory._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnParameterSetTrajectory._metadata, IAgCrdnParameterSetTrajectory._set_ReferenceSystem_metadata, referenceSystem)


agcls.AgClassCatalog.add_catalog_entry("{0FE9C601-61BB-4579-B91F-B1123A19AFB4}", IAgCrdnParameterSetTrajectory)
agcls.AgTypeNameMap["IAgCrdnParameterSetTrajectory"] = IAgCrdnParameterSetTrajectory

class IAgCrdnParameterSetVector(object):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5B99EEC1-21BD-48B5-96A0-0230894532F1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Vector" : 1,
                             "set_Vector" : 2,
                             "get_ReferenceAxes" : 3,
                             "set_ReferenceAxes" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnParameterSetVector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnParameterSetVector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetVector.__dict__ and type(IAgCrdnParameterSetVector.__dict__[attrname]) == property:
            return IAgCrdnParameterSetVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnParameterSetVector.")
    
    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCrdnVector":
        """Get the vector for which representations are computed."""
        return self._intf.get_property(IAgCrdnParameterSetVector._metadata, IAgCrdnParameterSetVector._get_Vector_metadata)

    _set_Vector_metadata = { "name" : "Vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @Vector.setter
    def Vector(self, vector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnParameterSetVector._metadata, IAgCrdnParameterSetVector._set_Vector_metadata, vector)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """Get the reference axes relative to which representations are computed."""
        return self._intf.get_property(IAgCrdnParameterSetVector._metadata, IAgCrdnParameterSetVector._get_ReferenceAxes_metadata)

    _set_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        return self._intf.set_property(IAgCrdnParameterSetVector._metadata, IAgCrdnParameterSetVector._set_ReferenceAxes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{5B99EEC1-21BD-48B5-96A0-0230894532F1}", IAgCrdnParameterSetVector)
agcls.AgTypeNameMap["IAgCrdnParameterSetVector"] = IAgCrdnParameterSetVector

class IAgCrdnPruneFilter(object):
    """A filter used with event interval list pruned class to prune interval lists..."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{89E95CD7-CDB2-4B17-9E47-DE17F551F873}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_FilterType" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPruneFilter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPruneFilter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPruneFilter.__dict__ and type(IAgCrdnPruneFilter.__dict__[attrname]) == property:
            return IAgCrdnPruneFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPruneFilter.")
    
    _get_FilterType_metadata = { "name" : "FilterType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPruneFilter),) }
    @property
    def FilterType(self) -> "AgECrdnPruneFilter":
        """Returns a type of the filter."""
        return self._intf.get_property(IAgCrdnPruneFilter._metadata, IAgCrdnPruneFilter._get_FilterType_metadata)


agcls.AgClassCatalog.add_catalog_entry("{89E95CD7-CDB2-4B17-9E47-DE17F551F873}", IAgCrdnPruneFilter)
agcls.AgTypeNameMap["IAgCrdnPruneFilter"] = IAgCrdnPruneFilter

class IAgCrdnPruneFilterFactory(object):
    """The factory creates pruning filters."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{77E7099E-9B41-45FA-B50F-F8DE5964FABD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPruneFilterFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPruneFilterFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPruneFilterFactory.__dict__ and type(IAgCrdnPruneFilterFactory.__dict__[attrname]) == property:
            return IAgCrdnPruneFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPruneFilterFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPruneFilter), agmarshall.AgInterface_out_arg,) }
    def Create(self, eFilter:"AgECrdnPruneFilter") -> "IAgCrdnPruneFilter":
        """Create and initializes a new prune filter using default configuration."""
        return self._intf.invoke(IAgCrdnPruneFilterFactory._metadata, IAgCrdnPruneFilterFactory._Create_metadata, eFilter, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{77E7099E-9B41-45FA-B50F-F8DE5964FABD}", IAgCrdnPruneFilterFactory)
agcls.AgTypeNameMap["IAgCrdnPruneFilterFactory"] = IAgCrdnPruneFilterFactory

class IAgCrdnRelativeSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Condition" : 1,
                             "set_Condition" : 2,
                             "get_DurationKind" : 3,
                             "set_DurationKind" : 4,
                             "get_RelativeIntervalDuration" : 5,
                             "set_RelativeIntervalDuration" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnRelativeSatisfactionConditionFilter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnRelativeSatisfactionConditionFilter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnRelativeSatisfactionConditionFilter.__dict__ and type(IAgCrdnRelativeSatisfactionConditionFilter.__dict__[attrname]) == property:
            return IAgCrdnRelativeSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnRelativeSatisfactionConditionFilter.")
    
    _get_Condition_metadata = { "name" : "Condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        return self._intf.get_property(IAgCrdnRelativeSatisfactionConditionFilter._metadata, IAgCrdnRelativeSatisfactionConditionFilter._get_Condition_metadata)

    _set_Condition_metadata = { "name" : "Condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCondition"),) }
    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        return self._intf.set_property(IAgCrdnRelativeSatisfactionConditionFilter._metadata, IAgCrdnRelativeSatisfactionConditionFilter._set_Condition_metadata, condition)

    _get_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(IAgCrdnRelativeSatisfactionConditionFilter._metadata, IAgCrdnRelativeSatisfactionConditionFilter._get_DurationKind_metadata)

    _set_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        return self._intf.set_property(IAgCrdnRelativeSatisfactionConditionFilter._metadata, IAgCrdnRelativeSatisfactionConditionFilter._set_DurationKind_metadata, durationKind)

    _get_RelativeIntervalDuration_metadata = { "name" : "RelativeIntervalDuration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RelativeIntervalDuration(self) -> float:
        """A percentage of time the condition must be satisfied."""
        return self._intf.get_property(IAgCrdnRelativeSatisfactionConditionFilter._metadata, IAgCrdnRelativeSatisfactionConditionFilter._get_RelativeIntervalDuration_metadata)

    _set_RelativeIntervalDuration_metadata = { "name" : "RelativeIntervalDuration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RelativeIntervalDuration.setter
    def RelativeIntervalDuration(self, relativeIntervalDuration:float) -> None:
        return self._intf.set_property(IAgCrdnRelativeSatisfactionConditionFilter._metadata, IAgCrdnRelativeSatisfactionConditionFilter._set_RelativeIntervalDuration_metadata, relativeIntervalDuration)


agcls.AgClassCatalog.add_catalog_entry("{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}", IAgCrdnRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap["IAgCrdnRelativeSatisfactionConditionFilter"] = IAgCrdnRelativeSatisfactionConditionFilter

class IAgCrdnSampling(object):
    """Base sampling interface."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSampling._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSampling from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSampling.__dict__ and type(IAgCrdnSampling.__dict__[attrname]) == property:
            return IAgCrdnSampling.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSampling.")
    

agcls.AgClassCatalog.add_catalog_entry("{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}", IAgCrdnSampling)
agcls.AgTypeNameMap["IAgCrdnSampling"] = IAgCrdnSampling

class IAgCrdnSamplingBasic(object):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SamplingMethod" : 1,
                             "set_SamplingMethod" : 2,
                             "get_MethodFactory" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSamplingBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSamplingBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingBasic.__dict__ and type(IAgCrdnSamplingBasic.__dict__[attrname]) == property:
            return IAgCrdnSamplingBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSamplingBasic.")
    
    _get_SamplingMethod_metadata = { "name" : "SamplingMethod",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SamplingMethod(self) -> "IAgCrdnSamplingMethod":
        """Get the sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnSamplingBasic._metadata, IAgCrdnSamplingBasic._get_SamplingMethod_metadata)

    _set_SamplingMethod_metadata = { "name" : "SamplingMethod",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSamplingMethod"),) }
    @SamplingMethod.setter
    def SamplingMethod(self, samplingMethod:"IAgCrdnSamplingMethod") -> None:
        return self._intf.set_property(IAgCrdnSamplingBasic._metadata, IAgCrdnSamplingBasic._set_SamplingMethod_metadata, samplingMethod)

    _get_MethodFactory_metadata = { "name" : "MethodFactory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def MethodFactory(self) -> "IAgCrdnSamplingMethodFactory":
        """Creates sampling definitions, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnSamplingBasic._metadata, IAgCrdnSamplingBasic._get_MethodFactory_metadata)


agcls.AgClassCatalog.add_catalog_entry("{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}", IAgCrdnSamplingBasic)
agcls.AgTypeNameMap["IAgCrdnSamplingBasic"] = IAgCrdnSamplingBasic

class IAgCrdnSamplingCurvatureTolerance(object):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{618ADA55-9E3D-4CEC-815A-B028995774CB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_MinimumTimeStep" : 1,
                             "set_MinimumTimeStep" : 2,
                             "get_MaximumTimeStep" : 3,
                             "set_MaximumTimeStep" : 4,
                             "get_StepAtBoundaries" : 5,
                             "set_StepAtBoundaries" : 6,
                             "get_RelativeTolerance" : 7,
                             "set_RelativeTolerance" : 8,
                             "get_AbsoluteTolerance" : 9,
                             "set_AbsoluteTolerance" : 10,
                             "get_CurvatureTolerance" : 11,
                             "set_CurvatureTolerance" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSamplingCurvatureTolerance._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSamplingCurvatureTolerance from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingCurvatureTolerance.__dict__ and type(IAgCrdnSamplingCurvatureTolerance.__dict__[attrname]) == property:
            return IAgCrdnSamplingCurvatureTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSamplingCurvatureTolerance.")
    
    _get_MinimumTimeStep_metadata = { "name" : "MinimumTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        return self._intf.get_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._get_MinimumTimeStep_metadata)

    _set_MinimumTimeStep_metadata = { "name" : "MinimumTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._set_MinimumTimeStep_metadata, minimumTimeStep)

    _get_MaximumTimeStep_metadata = { "name" : "MaximumTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        return self._intf.get_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._get_MaximumTimeStep_metadata)

    _set_MaximumTimeStep_metadata = { "name" : "MaximumTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._set_MaximumTimeStep_metadata, maximumTimeStep)

    _get_StepAtBoundaries_metadata = { "name" : "StepAtBoundaries",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        return self._intf.get_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._get_StepAtBoundaries_metadata)

    _set_StepAtBoundaries_metadata = { "name" : "StepAtBoundaries",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._set_StepAtBoundaries_metadata, stepAtBoundaries)

    _get_RelativeTolerance_metadata = { "name" : "RelativeTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        return self._intf.get_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._get_RelativeTolerance_metadata)

    _set_RelativeTolerance_metadata = { "name" : "RelativeTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._set_RelativeTolerance_metadata, relativeTolerance)

    _get_AbsoluteTolerance_metadata = { "name" : "AbsoluteTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        return self._intf.get_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._get_AbsoluteTolerance_metadata)

    _set_AbsoluteTolerance_metadata = { "name" : "AbsoluteTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._set_AbsoluteTolerance_metadata, absoluteTolerance)

    _get_CurvatureTolerance_metadata = { "name" : "CurvatureTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def CurvatureTolerance(self) -> float:
        """Get the curvature tolerance which determines acceptable angular difference between slopes over consecutive steps"""
        return self._intf.get_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._get_CurvatureTolerance_metadata)

    _set_CurvatureTolerance_metadata = { "name" : "CurvatureTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @CurvatureTolerance.setter
    def CurvatureTolerance(self, curvatureTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingCurvatureTolerance._metadata, IAgCrdnSamplingCurvatureTolerance._set_CurvatureTolerance_metadata, curvatureTolerance)


agcls.AgClassCatalog.add_catalog_entry("{618ADA55-9E3D-4CEC-815A-B028995774CB}", IAgCrdnSamplingCurvatureTolerance)
agcls.AgTypeNameMap["IAgCrdnSamplingCurvatureTolerance"] = IAgCrdnSamplingCurvatureTolerance

class IAgCrdnSamplingFixedStep(object):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{68784D1E-776C-4212-B35E-121FFE569627}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TimeStep" : 1,
                             "set_TimeStep" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSamplingFixedStep._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSamplingFixedStep from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingFixedStep.__dict__ and type(IAgCrdnSamplingFixedStep.__dict__[attrname]) == property:
            return IAgCrdnSamplingFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSamplingFixedStep.")
    
    _get_TimeStep_metadata = { "name" : "TimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeStep(self) -> float:
        """Get the fixed time step."""
        return self._intf.get_property(IAgCrdnSamplingFixedStep._metadata, IAgCrdnSamplingFixedStep._get_TimeStep_metadata)

    _set_TimeStep_metadata = { "name" : "TimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingFixedStep._metadata, IAgCrdnSamplingFixedStep._set_TimeStep_metadata, timeStep)


agcls.AgClassCatalog.add_catalog_entry("{68784D1E-776C-4212-B35E-121FFE569627}", IAgCrdnSamplingFixedStep)
agcls.AgTypeNameMap["IAgCrdnSamplingFixedStep"] = IAgCrdnSamplingFixedStep

class IAgCrdnSamplingMethod(object):
    """A sampling method."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1D14391E-F22F-42FF-B3FA-902F061A6F7B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_MethodType" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSamplingMethod._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSamplingMethod from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingMethod.__dict__ and type(IAgCrdnSamplingMethod.__dict__[attrname]) == property:
            return IAgCrdnSamplingMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSamplingMethod.")
    
    _get_MethodType_metadata = { "name" : "MethodType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSamplingMethod),) }
    @property
    def MethodType(self) -> "AgECrdnSamplingMethod":
        """A sampling method type."""
        return self._intf.get_property(IAgCrdnSamplingMethod._metadata, IAgCrdnSamplingMethod._get_MethodType_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1D14391E-F22F-42FF-B3FA-902F061A6F7B}", IAgCrdnSamplingMethod)
agcls.AgTypeNameMap["IAgCrdnSamplingMethod"] = IAgCrdnSamplingMethod

class IAgCrdnSamplingMethodFactory(object):
    """The factory creates sampling method components."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C214929B-45FA-4023-9C40-6DCE747C151B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "CreateFixedStep" : 1,
                             "CreateCurvatureTolerance" : 2,
                             "CreateRelativeTolerance" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSamplingMethodFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSamplingMethodFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingMethodFactory.__dict__ and type(IAgCrdnSamplingMethodFactory.__dict__[attrname]) == property:
            return IAgCrdnSamplingMethodFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSamplingMethodFactory.")
    
    _CreateFixedStep_metadata = { "name" : "CreateFixedStep",
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def CreateFixedStep(self, fixedStep:float) -> "IAgCrdnSamplingMethod":
        """Create a fixed time step sampling definition."""
        return self._intf.invoke(IAgCrdnSamplingMethodFactory._metadata, IAgCrdnSamplingMethodFactory._CreateFixedStep_metadata, fixedStep, out_arg())

    _CreateCurvatureTolerance_metadata = { "name" : "CreateCurvatureTolerance",
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def CreateCurvatureTolerance(self, curvatureTolerance:float) -> "IAgCrdnSamplingMethod":
        """Create a curvature tolerance sampling definition. Curvature tolerance uses changes in slope between samples."""
        return self._intf.invoke(IAgCrdnSamplingMethodFactory._metadata, IAgCrdnSamplingMethodFactory._CreateCurvatureTolerance_metadata, curvatureTolerance, out_arg())

    _CreateRelativeTolerance_metadata = { "name" : "CreateRelativeTolerance",
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def CreateRelativeTolerance(self, relativeTolerance:float) -> "IAgCrdnSamplingMethod":
        """Create a relative tolerance sampling definition. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples."""
        return self._intf.invoke(IAgCrdnSamplingMethodFactory._metadata, IAgCrdnSamplingMethodFactory._CreateRelativeTolerance_metadata, relativeTolerance, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C214929B-45FA-4023-9C40-6DCE747C151B}", IAgCrdnSamplingMethodFactory)
agcls.AgTypeNameMap["IAgCrdnSamplingMethodFactory"] = IAgCrdnSamplingMethodFactory

class IAgCrdnSamplingRelativeTolerance(object):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{32BB5026-A93C-41F7-ADE8-0A04A43627BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_MinimumTimeStep" : 1,
                             "set_MinimumTimeStep" : 2,
                             "get_MaximumTimeStep" : 3,
                             "set_MaximumTimeStep" : 4,
                             "get_StepAtBoundaries" : 5,
                             "set_StepAtBoundaries" : 6,
                             "get_RelativeTolerance" : 7,
                             "set_RelativeTolerance" : 8,
                             "get_AbsoluteTolerance" : 9,
                             "set_AbsoluteTolerance" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSamplingRelativeTolerance._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSamplingRelativeTolerance from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingRelativeTolerance.__dict__ and type(IAgCrdnSamplingRelativeTolerance.__dict__[attrname]) == property:
            return IAgCrdnSamplingRelativeTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSamplingRelativeTolerance.")
    
    _get_MinimumTimeStep_metadata = { "name" : "MinimumTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        return self._intf.get_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._get_MinimumTimeStep_metadata)

    _set_MinimumTimeStep_metadata = { "name" : "MinimumTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._set_MinimumTimeStep_metadata, minimumTimeStep)

    _get_MaximumTimeStep_metadata = { "name" : "MaximumTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        return self._intf.get_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._get_MaximumTimeStep_metadata)

    _set_MaximumTimeStep_metadata = { "name" : "MaximumTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._set_MaximumTimeStep_metadata, maximumTimeStep)

    _get_StepAtBoundaries_metadata = { "name" : "StepAtBoundaries",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        return self._intf.get_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._get_StepAtBoundaries_metadata)

    _set_StepAtBoundaries_metadata = { "name" : "StepAtBoundaries",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._set_StepAtBoundaries_metadata, stepAtBoundaries)

    _get_RelativeTolerance_metadata = { "name" : "RelativeTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        return self._intf.get_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._get_RelativeTolerance_metadata)

    _set_RelativeTolerance_metadata = { "name" : "RelativeTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._set_RelativeTolerance_metadata, relativeTolerance)

    _get_AbsoluteTolerance_metadata = { "name" : "AbsoluteTolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        return self._intf.get_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._get_AbsoluteTolerance_metadata)

    _set_AbsoluteTolerance_metadata = { "name" : "AbsoluteTolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(IAgCrdnSamplingRelativeTolerance._metadata, IAgCrdnSamplingRelativeTolerance._set_AbsoluteTolerance_metadata, absoluteTolerance)


agcls.AgClassCatalog.add_catalog_entry("{32BB5026-A93C-41F7-ADE8-0A04A43627BC}", IAgCrdnSamplingRelativeTolerance)
agcls.AgTypeNameMap["IAgCrdnSamplingRelativeTolerance"] = IAgCrdnSamplingRelativeTolerance

class IAgCrdnSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{84F129C1-1D47-4FE2-B87B-013BEF12269C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Condition" : 1,
                             "set_Condition" : 2,
                             "get_DurationKind" : 3,
                             "set_DurationKind" : 4,
                             "get_IntervalDuration" : 5,
                             "set_IntervalDuration" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSatisfactionConditionFilter._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSatisfactionConditionFilter from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSatisfactionConditionFilter.__dict__ and type(IAgCrdnSatisfactionConditionFilter.__dict__[attrname]) == property:
            return IAgCrdnSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSatisfactionConditionFilter.")
    
    _get_Condition_metadata = { "name" : "Condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        return self._intf.get_property(IAgCrdnSatisfactionConditionFilter._metadata, IAgCrdnSatisfactionConditionFilter._get_Condition_metadata)

    _set_Condition_metadata = { "name" : "Condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCondition"),) }
    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        return self._intf.set_property(IAgCrdnSatisfactionConditionFilter._metadata, IAgCrdnSatisfactionConditionFilter._set_Condition_metadata, condition)

    _get_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(IAgCrdnSatisfactionConditionFilter._metadata, IAgCrdnSatisfactionConditionFilter._get_DurationKind_metadata)

    _set_DurationKind_metadata = { "name" : "DurationKind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind),) }
    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        return self._intf.set_property(IAgCrdnSatisfactionConditionFilter._metadata, IAgCrdnSatisfactionConditionFilter._set_DurationKind_metadata, durationKind)

    _get_IntervalDuration_metadata = { "name" : "IntervalDuration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def IntervalDuration(self) -> float:
        """A duration of time the condition must be satisfied."""
        return self._intf.get_property(IAgCrdnSatisfactionConditionFilter._metadata, IAgCrdnSatisfactionConditionFilter._get_IntervalDuration_metadata)

    _set_IntervalDuration_metadata = { "name" : "IntervalDuration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        return self._intf.set_property(IAgCrdnSatisfactionConditionFilter._metadata, IAgCrdnSatisfactionConditionFilter._set_IntervalDuration_metadata, intervalDuration)


agcls.AgClassCatalog.add_catalog_entry("{84F129C1-1D47-4FE2-B87B-013BEF12269C}", IAgCrdnSatisfactionConditionFilter)
agcls.AgTypeNameMap["IAgCrdnSatisfactionConditionFilter"] = IAgCrdnSatisfactionConditionFilter

class IAgCrdnSignalDelay(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5ED53953-1C55-431D-88AF-1AF23B2FE424}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSignalDelay._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSignalDelay from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSignalDelay.__dict__ and type(IAgCrdnSignalDelay.__dict__[attrname]) == property:
            return IAgCrdnSignalDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSignalDelay.")
    

agcls.AgClassCatalog.add_catalog_entry("{5ED53953-1C55-431D-88AF-1AF23B2FE424}", IAgCrdnSignalDelay)
agcls.AgTypeNameMap["IAgCrdnSignalDelay"] = IAgCrdnSignalDelay

class IAgCrdnSignalDelayBasic(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SignalPathReferenceSystem" : 1,
                             "set_SignalPathReferenceSystem" : 2,
                             "get_ReferenceSystem" : 3,
                             "set_ReferenceSystem" : 4,
                             "get_SpeedOption" : 5,
                             "set_SpeedOption" : 6,
                             "get_TransferSpeed" : 7,
                             "set_TransferSpeed" : 8,
                             "get_TimeDelayConvergence" : 9,
                             "set_TimeDelayConvergence" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSignalDelayBasic._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSignalDelayBasic from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSignalDelayBasic.__dict__ and type(IAgCrdnSignalDelayBasic.__dict__[attrname]) == property:
            return IAgCrdnSignalDelayBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSignalDelayBasic.")
    
    _get_SignalPathReferenceSystem_metadata = { "name" : "SignalPathReferenceSystem",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem),) }
    @property
    def SignalPathReferenceSystem(self) -> "AgECrdnSignalPathReferenceSystem":
        """Get the type of signal path reference system which can be set to use STK Access default (see STK Help for further details), Solar system barycenter inertial reference, central body inertial reference or custom reference system..."""
        return self._intf.get_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._get_SignalPathReferenceSystem_metadata)

    _set_SignalPathReferenceSystem_metadata = { "name" : "SignalPathReferenceSystem",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem),) }
    @SignalPathReferenceSystem.setter
    def SignalPathReferenceSystem(self, signalPathReferenceSystem:"AgECrdnSignalPathReferenceSystem") -> None:
        return self._intf.set_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._set_SignalPathReferenceSystem_metadata, signalPathReferenceSystem)

    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the custom reference system which is used as a reference for signal path if the signal path reference option is set to Custom."""
        return self._intf.get_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._set_ReferenceSystem_metadata, referenceSystem)

    _get_SpeedOption_metadata = { "name" : "SpeedOption",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSpeedOptions),) }
    @property
    def SpeedOption(self) -> "AgECrdnSpeedOptions":
        """Get the speed option which determines whether to use the speed of light or a custom speed value."""
        return self._intf.get_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._get_SpeedOption_metadata)

    _set_SpeedOption_metadata = { "name" : "SpeedOption",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSpeedOptions),) }
    @SpeedOption.setter
    def SpeedOption(self, speedOption:"AgECrdnSpeedOptions") -> None:
        return self._intf.set_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._set_SpeedOption_metadata, speedOption)

    _get_TransferSpeed_metadata = { "name" : "TransferSpeed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TransferSpeed(self) -> float:
        """Get the signal propagation speed value which is used if the speed option is set to Custom."""
        return self._intf.get_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._get_TransferSpeed_metadata)

    _set_TransferSpeed_metadata = { "name" : "TransferSpeed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TransferSpeed.setter
    def TransferSpeed(self, transferSpeed:float) -> None:
        return self._intf.set_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._set_TransferSpeed_metadata, transferSpeed)

    _get_TimeDelayConvergence_metadata = { "name" : "TimeDelayConvergence",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeDelayConvergence(self) -> float:
        """Get the time delay convergence which determines the accuracy of computed propagation time between the two locations."""
        return self._intf.get_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._get_TimeDelayConvergence_metadata)

    _set_TimeDelayConvergence_metadata = { "name" : "TimeDelayConvergence",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        return self._intf.set_property(IAgCrdnSignalDelayBasic._metadata, IAgCrdnSignalDelayBasic._set_TimeDelayConvergence_metadata, timeDelayConvergence)


agcls.AgClassCatalog.add_catalog_entry("{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}", IAgCrdnSignalDelayBasic)
agcls.AgTypeNameMap["IAgCrdnSignalDelayBasic"] = IAgCrdnSignalDelayBasic

class IAgCrdnVolumeCalcFactory(object):
    """The factory is used to create instances of volume calcs."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{42eb6d4a-5cff-471f-997d-3f624cb4a416}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "IsTypeSupported" : 1,
                             "Create" : 2,
                             "CreateVolumeCalcAltitude" : 3,
                             "CreateVolumeCalcAngleOffVector" : 4,
                             "CreateVolumeCalcFile" : 5,
                             "CreateVolumeCalcFromScalar" : 6,
                             "CreateVolumeCalcSolarIntensity" : 7,
                             "CreateVolumeCalcVolumeSatisfactionMetric" : 8,
                             "CreateVolumeCalcRange" : 9,
                             "CreateVolumeCalcDelayRange" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcFactory.__dict__ and type(IAgCrdnVolumeCalcFactory.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcFactory.")
    
    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnVolumeCalcType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._IsTypeSupported_metadata, eType, out_arg())

    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnVolumeCalcType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnVolumeCalcType") -> "IAgCrdnVolumeCalc":
        """Creates and registers a volume calc using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._Create_metadata, name, description, type, out_arg())

    _CreateVolumeCalcAltitude_metadata = { "name" : "CreateVolumeCalcAltitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcAltitude(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a altitude to location volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcAltitude_metadata, name, description, out_arg())

    _CreateVolumeCalcAngleOffVector_metadata = { "name" : "CreateVolumeCalcAngleOffVector",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcAngleOffVector(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a angle to location volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcAngleOffVector_metadata, name, description, out_arg())

    _CreateVolumeCalcFile_metadata = { "name" : "CreateVolumeCalcFile",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcFile(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a file volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcFile_metadata, name, description, out_arg())

    _CreateVolumeCalcFromScalar_metadata = { "name" : "CreateVolumeCalcFromScalar",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcFromScalar(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a scalar to location volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcFromScalar_metadata, name, description, out_arg())

    _CreateVolumeCalcSolarIntensity_metadata = { "name" : "CreateVolumeCalcSolarIntensity",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcSolarIntensity(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a solar intensity volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcSolarIntensity_metadata, name, description, out_arg())

    _CreateVolumeCalcVolumeSatisfactionMetric_metadata = { "name" : "CreateVolumeCalcVolumeSatisfactionMetric",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcVolumeSatisfactionMetric(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a spatial condition satisfaction metric volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcVolumeSatisfactionMetric_metadata, name, description, out_arg())

    _CreateVolumeCalcRange_metadata = { "name" : "CreateVolumeCalcRange",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcRange(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcRange_metadata, name, description, out_arg())

    _CreateVolumeCalcDelayRange_metadata = { "name" : "CreateVolumeCalcDelayRange",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCalcDelayRange(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeCalcFactory._metadata, IAgCrdnVolumeCalcFactory._CreateVolumeCalcDelayRange_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{42eb6d4a-5cff-471f-997d-3f624cb4a416}", IAgCrdnVolumeCalcFactory)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcFactory"] = IAgCrdnVolumeCalcFactory

class IAgCrdnVolumeFactory(object):
    """The factory is used to create instances of volumes."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FE97990E-A152-417C-883E-64C42AB9B913}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "IsTypeSupported" : 2,
                             "CreateVolumeCombined" : 3,
                             "CreateVolumeLighting" : 4,
                             "CreateVolumeOverTime" : 5,
                             "CreateVolumeFromGrid" : 6,
                             "CreateVolumeFromCalc" : 7,
                             "CreateVolumeFromTimeSatisfaction" : 8,
                             "CreateVolumeFromCondition" : 9,
                             "CreateVolumeInview" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFactory.__dict__ and type(IAgCrdnVolumeFactory.__dict__[attrname]) == property:
            return IAgCrdnVolumeFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnVolumeType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnVolumeType") -> "IAgCrdnVolume":
        """Creates and registers a volume using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._Create_metadata, name, description, type, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnVolumeType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._IsTypeSupported_metadata, eType, out_arg())

    _CreateVolumeCombined_metadata = { "name" : "CreateVolumeCombined",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeCombined(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type combined."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeCombined_metadata, name, description, out_arg())

    _CreateVolumeLighting_metadata = { "name" : "CreateVolumeLighting",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeLighting(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type lighting."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeLighting_metadata, name, description, out_arg())

    _CreateVolumeOverTime_metadata = { "name" : "CreateVolumeOverTime",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeOverTime(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type over time."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeOverTime_metadata, name, description, out_arg())

    _CreateVolumeFromGrid_metadata = { "name" : "CreateVolumeFromGrid",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeFromGrid(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type from grid."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeFromGrid_metadata, name, description, out_arg())

    _CreateVolumeFromCalc_metadata = { "name" : "CreateVolumeFromCalc",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeFromCalc(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type from calc."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeFromCalc_metadata, name, description, out_arg())

    _CreateVolumeFromTimeSatisfaction_metadata = { "name" : "CreateVolumeFromTimeSatisfaction",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeFromTimeSatisfaction(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type from time satisfaction."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeFromTimeSatisfaction_metadata, name, description, out_arg())

    _CreateVolumeFromCondition_metadata = { "name" : "CreateVolumeFromCondition",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeFromCondition(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type condition."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeFromCondition_metadata, name, description, out_arg())

    _CreateVolumeInview_metadata = { "name" : "CreateVolumeInview",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeInview(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type Inview."""
        return self._intf.invoke(IAgCrdnVolumeFactory._metadata, IAgCrdnVolumeFactory._CreateVolumeInview_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{FE97990E-A152-417C-883E-64C42AB9B913}", IAgCrdnVolumeFactory)
agcls.AgTypeNameMap["IAgCrdnVolumeFactory"] = IAgCrdnVolumeFactory

class IAgCrdnVolumeGridFactory(object):
    """The factory is used to create instances of volume grids."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4533DEA1-D754-4579-A79D-B5A639C2CD39}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "CreateVolumeGridCartesian" : 2,
                             "IsTypeSupported" : 3,
                             "CreateVolumeGridCylindrical" : 4,
                             "CreateVolumeGridSpherical" : 5,
                             "CreateVolumeGridConstrained" : 6,
                             "CreateVolumeGridLatLonAlt" : 7,
                             "CreateVolumeGridBearingAlt" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridFactory.__dict__ and type(IAgCrdnVolumeGridFactory.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnVolumeGridType), agmarshall.AgInterface_out_arg,) }
    def Create(self, name:str, description:str, type:"AgECrdnVolumeGridType") -> "IAgCrdnVolumeGrid":
        """Creates and registers a volume grid using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._Create_metadata, name, description, type, out_arg())

    _CreateVolumeGridCartesian_metadata = { "name" : "CreateVolumeGridCartesian",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeGridCartesian(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a cartesian volume grid type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._CreateVolumeGridCartesian_metadata, name, description, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeGridType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, eType:"AgECrdnVolumeGridType") -> bool:
        """Returns whether the specified type is supported."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._IsTypeSupported_metadata, eType, out_arg())

    _CreateVolumeGridCylindrical_metadata = { "name" : "CreateVolumeGridCylindrical",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeGridCylindrical(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a cylindrical volume grid type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._CreateVolumeGridCylindrical_metadata, name, description, out_arg())

    _CreateVolumeGridSpherical_metadata = { "name" : "CreateVolumeGridSpherical",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeGridSpherical(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a spherical volume grid type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._CreateVolumeGridSpherical_metadata, name, description, out_arg())

    _CreateVolumeGridConstrained_metadata = { "name" : "CreateVolumeGridConstrained",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeGridConstrained(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a volume grid of type that can be constrained by conditions using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._CreateVolumeGridConstrained_metadata, name, description, out_arg())

    _CreateVolumeGridLatLonAlt_metadata = { "name" : "CreateVolumeGridLatLonAlt",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeGridLatLonAlt(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers cartographic volume grid type using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._CreateVolumeGridLatLonAlt_metadata, name, description, out_arg())

    _CreateVolumeGridBearingAlt_metadata = { "name" : "CreateVolumeGridBearingAlt",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVolumeGridBearingAlt(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a volume grid of type surface bearing using specified name and description."""
        return self._intf.invoke(IAgCrdnVolumeGridFactory._metadata, IAgCrdnVolumeGridFactory._CreateVolumeGridBearingAlt_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4533DEA1-D754-4579-A79D-B5A639C2CD39}", IAgCrdnVolumeGridFactory)
agcls.AgTypeNameMap["IAgCrdnVolumeGridFactory"] = IAgCrdnVolumeGridFactory

class IAgCrdnGridCoordinateDefinition(object):
    """Defines a set of coordinate values."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{96875D1C-9CBC-4732-A678-2CB17995C0E9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_MethodType" : 1,
                             "get_GridValuesMethod" : 2,
                             "SetGridValuesFixedStep" : 3,
                             "SetGridValuesFixedNumberOfSteps" : 4,
                             "SetGridValuesCustom" : 5,
                             "SetGridValuesFixedNumberOfStepsEx" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnGridCoordinateDefinition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnGridCoordinateDefinition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridCoordinateDefinition.__dict__ and type(IAgCrdnGridCoordinateDefinition.__dict__[attrname]) == property:
            return IAgCrdnGridCoordinateDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnGridCoordinateDefinition.")
    
    _get_MethodType_metadata = { "name" : "MethodType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType),) }
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        return self._intf.get_property(IAgCrdnGridCoordinateDefinition._metadata, IAgCrdnGridCoordinateDefinition._get_MethodType_metadata)

    _get_GridValuesMethod_metadata = { "name" : "GridValuesMethod",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def GridValuesMethod(self) -> "IAgCrdnGridValuesMethod":
        """Sets/Returns the grid values interface."""
        return self._intf.get_property(IAgCrdnGridCoordinateDefinition._metadata, IAgCrdnGridCoordinateDefinition._get_GridValuesMethod_metadata)

    _SetGridValuesFixedStep_metadata = { "name" : "SetGridValuesFixedStep",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT_BOOL, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def SetGridValuesFixedStep(self, min:float, max:float, includeMinMax:bool, refValue:float, fixedStep:float) -> "IAgCrdnGridValuesFixedStep":
        """Sets grid values type to fixed step."""
        return self._intf.invoke(IAgCrdnGridCoordinateDefinition._metadata, IAgCrdnGridCoordinateDefinition._SetGridValuesFixedStep_metadata, min, max, includeMinMax, refValue, fixedStep, out_arg())

    _SetGridValuesFixedNumberOfSteps_metadata = { "name" : "SetGridValuesFixedNumberOfSteps",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def SetGridValuesFixedNumberOfSteps(self, min:float, max:float, numSteps:int) -> "IAgCrdnGridValuesFixedNumberOfSteps":
        """This method is deprecated. Use SetGridValuesFixedNumberOfStepsEx."""
        return self._intf.invoke(IAgCrdnGridCoordinateDefinition._metadata, IAgCrdnGridCoordinateDefinition._SetGridValuesFixedNumberOfSteps_metadata, min, max, numSteps, out_arg())

    _SetGridValuesCustom_metadata = { "name" : "SetGridValuesCustom",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.AgInterface_out_arg,) }
    def SetGridValuesCustom(self, values:list) -> "IAgCrdnGridValuesCustom":
        """Sets grid values type to custom values."""
        return self._intf.invoke(IAgCrdnGridCoordinateDefinition._metadata, IAgCrdnGridCoordinateDefinition._SetGridValuesCustom_metadata, values, out_arg())

    _SetGridValuesFixedNumberOfStepsEx_metadata = { "name" : "SetGridValuesFixedNumberOfStepsEx",
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def SetGridValuesFixedNumberOfStepsEx(self, min:"IAgQuantity", max:"IAgQuantity", numSteps:int) -> "IAgCrdnGridValuesFixedNumberOfSteps":
        """Sets grid values type to fixed number of steps with min and max as IAgQuantity"""
        return self._intf.invoke(IAgCrdnGridCoordinateDefinition._metadata, IAgCrdnGridCoordinateDefinition._SetGridValuesFixedNumberOfStepsEx_metadata, min, max, numSteps, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{96875D1C-9CBC-4732-A678-2CB17995C0E9}", IAgCrdnGridCoordinateDefinition)
agcls.AgTypeNameMap["IAgCrdnGridCoordinateDefinition"] = IAgCrdnGridCoordinateDefinition

class IAgCrdnGridValuesCustom(object):
    """Fixed step grid values."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Values" : 1,
                             "set_Values" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnGridValuesCustom._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnGridValuesCustom from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesCustom.__dict__ and type(IAgCrdnGridValuesCustom.__dict__[attrname]) == property:
            return IAgCrdnGridValuesCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnGridValuesCustom.")
    
    _get_Values_metadata = { "name" : "Values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Values(self) -> list:
        """Custom set of coordinate values."""
        return self._intf.get_property(IAgCrdnGridValuesCustom._metadata, IAgCrdnGridValuesCustom._get_Values_metadata)

    _set_Values_metadata = { "name" : "Values",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @Values.setter
    def Values(self, values:list) -> None:
        return self._intf.set_property(IAgCrdnGridValuesCustom._metadata, IAgCrdnGridValuesCustom._set_Values_metadata, values)


agcls.AgClassCatalog.add_catalog_entry("{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}", IAgCrdnGridValuesCustom)
agcls.AgTypeNameMap["IAgCrdnGridValuesCustom"] = IAgCrdnGridValuesCustom

class IAgCrdnGridValuesFixedNumberOfSteps(object):
    """Fixed step grid values."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{379ACEFA-1B1E-4753-BA9A-87939E5B8893}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Min" : 1,
                             "set_Min" : 2,
                             "get_Max" : 3,
                             "set_Max" : 4,
                             "get_NumberOfSteps" : 5,
                             "set_NumberOfSteps" : 6,
                             "get_MinEx" : 7,
                             "set_MinEx" : 8,
                             "get_MaxEx" : 9,
                             "set_MaxEx" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnGridValuesFixedNumberOfSteps._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnGridValuesFixedNumberOfSteps from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesFixedNumberOfSteps.__dict__ and type(IAgCrdnGridValuesFixedNumberOfSteps.__dict__[attrname]) == property:
            return IAgCrdnGridValuesFixedNumberOfSteps.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnGridValuesFixedNumberOfSteps.")
    
    _get_Min_metadata = { "name" : "Min",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Min(self) -> float:
        """This property is deprecated. Use MinEx."""
        return self._intf.get_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._get_Min_metadata)

    _set_Min_metadata = { "name" : "Min",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Min.setter
    def Min(self, min:float) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._set_Min_metadata, min)

    _get_Max_metadata = { "name" : "Max",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Max(self) -> float:
        """This property is deprecated. Use MaxEx."""
        return self._intf.get_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._get_Max_metadata)

    _set_Max_metadata = { "name" : "Max",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Max.setter
    def Max(self, max:float) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._set_Max_metadata, max)

    _get_NumberOfSteps_metadata = { "name" : "NumberOfSteps",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def NumberOfSteps(self) -> int:
        """The number of steps between coordinate values."""
        return self._intf.get_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._get_NumberOfSteps_metadata)

    _set_NumberOfSteps_metadata = { "name" : "NumberOfSteps",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @NumberOfSteps.setter
    def NumberOfSteps(self, numberOfSteps:int) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._set_NumberOfSteps_metadata, numberOfSteps)

    _get_MinEx_metadata = { "name" : "MinEx",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def MinEx(self) -> "IAgQuantity":
        """Minimum coordinate value as IAgQuantity."""
        return self._intf.get_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._get_MinEx_metadata)

    _set_MinEx_metadata = { "name" : "MinEx",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    @MinEx.setter
    def MinEx(self, minEx:"IAgQuantity") -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._set_MinEx_metadata, minEx)

    _get_MaxEx_metadata = { "name" : "MaxEx",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def MaxEx(self) -> "IAgQuantity":
        """Maximum coordinate value as IAgQuantity."""
        return self._intf.get_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._get_MaxEx_metadata)

    _set_MaxEx_metadata = { "name" : "MaxEx",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    @MaxEx.setter
    def MaxEx(self, maxEx:"IAgQuantity") -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedNumberOfSteps._metadata, IAgCrdnGridValuesFixedNumberOfSteps._set_MaxEx_metadata, maxEx)


agcls.AgClassCatalog.add_catalog_entry("{379ACEFA-1B1E-4753-BA9A-87939E5B8893}", IAgCrdnGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap["IAgCrdnGridValuesFixedNumberOfSteps"] = IAgCrdnGridValuesFixedNumberOfSteps

class IAgCrdnGridValuesFixedStep(object):
    """Fixed step grid values."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7C18BF81-7E22-4A28-B462-37ED86EC3050}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Min" : 1,
                             "set_Min" : 2,
                             "get_Max" : 3,
                             "set_Max" : 4,
                             "get_IncludeMinMax" : 5,
                             "set_IncludeMinMax" : 6,
                             "get_ReferenceValue" : 7,
                             "set_ReferenceValue" : 8,
                             "get_Step" : 9,
                             "set_Step" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnGridValuesFixedStep._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnGridValuesFixedStep from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesFixedStep.__dict__ and type(IAgCrdnGridValuesFixedStep.__dict__[attrname]) == property:
            return IAgCrdnGridValuesFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnGridValuesFixedStep.")
    
    _get_Min_metadata = { "name" : "Min",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Min(self) -> float:
        """Minimum coordinate value."""
        return self._intf.get_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._get_Min_metadata)

    _set_Min_metadata = { "name" : "Min",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Min.setter
    def Min(self, min:float) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._set_Min_metadata, min)

    _get_Max_metadata = { "name" : "Max",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Max(self) -> float:
        """Maximum coordinate value."""
        return self._intf.get_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._get_Max_metadata)

    _set_Max_metadata = { "name" : "Max",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Max.setter
    def Max(self, max:float) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._set_Max_metadata, max)

    _get_IncludeMinMax_metadata = { "name" : "IncludeMinMax",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IncludeMinMax(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        return self._intf.get_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._get_IncludeMinMax_metadata)

    _set_IncludeMinMax_metadata = { "name" : "IncludeMinMax",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IncludeMinMax.setter
    def IncludeMinMax(self, includeMinMax:bool) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._set_IncludeMinMax_metadata, includeMinMax)

    _get_ReferenceValue_metadata = { "name" : "ReferenceValue",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ReferenceValue(self) -> float:
        """Reference coordinate value from which steps are taken."""
        return self._intf.get_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._get_ReferenceValue_metadata)

    _set_ReferenceValue_metadata = { "name" : "ReferenceValue",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ReferenceValue.setter
    def ReferenceValue(self, referenceValue:float) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._set_ReferenceValue_metadata, referenceValue)

    _get_Step_metadata = { "name" : "Step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Step(self) -> float:
        """Step between subsequent coordinate values."""
        return self._intf.get_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._get_Step_metadata)

    _set_Step_metadata = { "name" : "Step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Step.setter
    def Step(self, step:float) -> None:
        return self._intf.set_property(IAgCrdnGridValuesFixedStep._metadata, IAgCrdnGridValuesFixedStep._set_Step_metadata, step)


agcls.AgClassCatalog.add_catalog_entry("{7C18BF81-7E22-4A28-B462-37ED86EC3050}", IAgCrdnGridValuesFixedStep)
agcls.AgTypeNameMap["IAgCrdnGridValuesFixedStep"] = IAgCrdnGridValuesFixedStep

class IAgCrdnGridValuesMethod(object):
    """A grid values method."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_MethodType" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnGridValuesMethod._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnGridValuesMethod from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesMethod.__dict__ and type(IAgCrdnGridValuesMethod.__dict__[attrname]) == property:
            return IAgCrdnGridValuesMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnGridValuesMethod.")
    
    _get_MethodType_metadata = { "name" : "MethodType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType),) }
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        return self._intf.get_property(IAgCrdnGridValuesMethod._metadata, IAgCrdnGridValuesMethod._get_MethodType_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}", IAgCrdnGridValuesMethod)
agcls.AgTypeNameMap["IAgCrdnGridValuesMethod"] = IAgCrdnGridValuesMethod

class IAgCrdnLightTimeDelay(object):
    """Manage Light Time Delay options.."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{82765B62-B9AB-4D52-900E-52ADAC0365D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_UseLightTimeDelay" : 1,
                             "set_UseLightTimeDelay" : 2,
                             "get_TimeDelayConvergence" : 3,
                             "set_TimeDelayConvergence" : 4,
                             "get_AberrationType" : 5,
                             "set_AberrationType" : 6,
                             "get_ClockHost" : 7,
                             "set_ClockHost" : 8,
                             "get_TimeSense" : 9,
                             "set_TimeSense" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnLightTimeDelay._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnLightTimeDelay from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnLightTimeDelay.__dict__ and type(IAgCrdnLightTimeDelay.__dict__[attrname]) == property:
            return IAgCrdnLightTimeDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnLightTimeDelay.")
    
    _get_UseLightTimeDelay_metadata = { "name" : "UseLightTimeDelay",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseLightTimeDelay(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        return self._intf.get_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._get_UseLightTimeDelay_metadata)

    _set_UseLightTimeDelay_metadata = { "name" : "UseLightTimeDelay",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseLightTimeDelay.setter
    def UseLightTimeDelay(self, useLightTimeDelay:bool) -> None:
        return self._intf.set_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._set_UseLightTimeDelay_metadata, useLightTimeDelay)

    _get_TimeDelayConvergence_metadata = { "name" : "TimeDelayConvergence",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def TimeDelayConvergence(self) -> float:
        """Set light Time Delay Convergence."""
        return self._intf.get_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._get_TimeDelayConvergence_metadata)

    _set_TimeDelayConvergence_metadata = { "name" : "TimeDelayConvergence",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        return self._intf.set_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._set_TimeDelayConvergence_metadata, timeDelayConvergence)

    _get_AberrationType_metadata = { "name" : "AberrationType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType),) }
    @property
    def AberrationType(self) -> "AgECrdnVolumeAberrationType":
        """Method used to Aberration Type."""
        return self._intf.get_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._get_AberrationType_metadata)

    _set_AberrationType_metadata = { "name" : "AberrationType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType),) }
    @AberrationType.setter
    def AberrationType(self, aberrationType:"AgECrdnVolumeAberrationType") -> None:
        return self._intf.set_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._set_AberrationType_metadata, aberrationType)

    _get_ClockHost_metadata = { "name" : "ClockHost",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType),) }
    @property
    def ClockHost(self) -> "AgECrdnVolumeClockHostType":
        """Indicates whether object1 or object2 of an Access instance holds the clock for Access times."""
        return self._intf.get_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._get_ClockHost_metadata)

    _set_ClockHost_metadata = { "name" : "ClockHost",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType),) }
    @ClockHost.setter
    def ClockHost(self, clockHost:"AgECrdnVolumeClockHostType") -> None:
        return self._intf.set_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._set_ClockHost_metadata, clockHost)

    _get_TimeSense_metadata = { "name" : "TimeSense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType),) }
    @property
    def TimeSense(self) -> "AgECrdnVolumeTimeSenseType":
        """Indicates whether apparent position is computed in a transmit or receive sense"""
        return self._intf.get_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._get_TimeSense_metadata)

    _set_TimeSense_metadata = { "name" : "TimeSense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType),) }
    @TimeSense.setter
    def TimeSense(self, timeSense:"AgECrdnVolumeTimeSenseType") -> None:
        return self._intf.set_property(IAgCrdnLightTimeDelay._metadata, IAgCrdnLightTimeDelay._set_TimeSense_metadata, timeSense)


agcls.AgClassCatalog.add_catalog_entry("{82765B62-B9AB-4D52-900E-52ADAC0365D0}", IAgCrdnLightTimeDelay)
agcls.AgTypeNameMap["IAgCrdnLightTimeDelay"] = IAgCrdnLightTimeDelay

class IAgCrdnVolume(object):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F85958EC-F470-432F-81B1-8517D3952F1E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolume._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolume from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolume.__dict__ and type(IAgCrdnVolume.__dict__[attrname]) == property:
            return IAgCrdnVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolume.")
    

agcls.AgClassCatalog.add_catalog_entry("{F85958EC-F470-432F-81B1-8517D3952F1E}", IAgCrdnVolume)
agcls.AgTypeNameMap["IAgCrdnVolume"] = IAgCrdnVolume

class IAgCrdnVolumeCalc(object):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalc._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalc from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalc.__dict__ and type(IAgCrdnVolumeCalc.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalc.")
    

agcls.AgClassCatalog.add_catalog_entry("{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}", IAgCrdnVolumeCalc)
agcls.AgTypeNameMap["IAgCrdnVolumeCalc"] = IAgCrdnVolumeCalc

class IAgCrdnVolumeCalcAltitude(object):
    """A volume calc altitude interface."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6039868a-acea-4918-966b-c6f952fd94d3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "set_CentralBody" : 2,
                             "get_ShapeModel" : 3,
                             "set_ShapeModel" : 4,
                             "get_UseCustomReference" : 5,
                             "set_UseCustomReference" : 6,
                             "get_ReferencePoint" : 7,
                             "set_ReferencePoint" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcAltitude._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcAltitude from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcAltitude.__dict__ and type(IAgCrdnVolumeCalcAltitude.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcAltitude.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def CentralBody(self) -> str:
        """Get the central body for the volume calc. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume calc."""
        return self._intf.get_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._get_CentralBody_metadata)

    _set_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._set_CentralBody_metadata, centralBody)

    _get_ShapeModel_metadata = { "name" : "ShapeModel",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType),) }
    @property
    def ShapeModel(self) -> "AgECrdnVolumeCalcAltitudeReferenceType":
        """The Volume Calc Altitude Reference Type."""
        return self._intf.get_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._get_ShapeModel_metadata)

    _set_ShapeModel_metadata = { "name" : "ShapeModel",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType),) }
    @ShapeModel.setter
    def ShapeModel(self, shapeModel:"AgECrdnVolumeCalcAltitudeReferenceType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._set_ShapeModel_metadata, shapeModel)

    _get_UseCustomReference_metadata = { "name" : "UseCustomReference",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomReference(self) -> bool:
        """Whether to use custom reference."""
        return self._intf.get_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._get_UseCustomReference_metadata)

    _set_UseCustomReference_metadata = { "name" : "UseCustomReference",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomReference.setter
    def UseCustomReference(self, useCustomReference:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._set_UseCustomReference_metadata, useCustomReference)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """A reference point. Can be any point from VGT."""
        return self._intf.get_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._get_ReferencePoint_metadata)

    _set_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAltitude._metadata, IAgCrdnVolumeCalcAltitude._set_ReferencePoint_metadata, referencePoint)


agcls.AgClassCatalog.add_catalog_entry("{6039868a-acea-4918-966b-c6f952fd94d3}", IAgCrdnVolumeCalcAltitude)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcAltitude"] = IAgCrdnVolumeCalcAltitude

class IAgCrdnVolumeCalcAngleOffVector(object):
    """A volume calc angle off vector interface."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ad6880b4-afc1-47ba-b964-f38916955c7b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Angle" : 1,
                             "set_Angle" : 2,
                             "get_ReferencePlane" : 3,
                             "set_ReferencePlane" : 4,
                             "get_ReferencePoint" : 5,
                             "set_ReferencePoint" : 6,
                             "get_ReferenceVector" : 7,
                             "set_ReferenceVector" : 8,
                             "get_AboutVector" : 9,
                             "set_AboutVector" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcAngleOffVector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcAngleOffVector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcAngleOffVector.__dict__ and type(IAgCrdnVolumeCalcAngleOffVector.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcAngleOffVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcAngleOffVector.")
    
    _get_Angle_metadata = { "name" : "Angle",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType),) }
    @property
    def Angle(self) -> "AgECrdnVolumeCalcAngleOffVectorType":
        """The Volume Calc Angle Off Vector Type."""
        return self._intf.get_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._get_Angle_metadata)

    _set_Angle_metadata = { "name" : "Angle",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType),) }
    @Angle.setter
    def Angle(self, angle:"AgECrdnVolumeCalcAngleOffVectorType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._set_Angle_metadata, angle)

    _get_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePlane(self) -> "IAgCrdnPlane":
        """The Volume Calc Angle Off Vector reference plane."""
        return self._intf.get_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._get_ReferencePlane_metadata)

    _set_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPlane"),) }
    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IAgCrdnPlane") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._set_ReferencePlane_metadata, referencePlane)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """The Volume Calc Angle Off Vector reference point."""
        return self._intf.get_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._get_ReferencePoint_metadata)

    _set_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._set_ReferencePoint_metadata, referencePoint)

    _get_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVector(self) -> "IAgCrdnVector":
        """The Volume Calc Angle Off Vector reference vector."""
        return self._intf.get_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._get_ReferenceVector_metadata)

    _set_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @ReferenceVector.setter
    def ReferenceVector(self, referenceVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._set_ReferenceVector_metadata, referenceVector)

    _get_AboutVector_metadata = { "name" : "AboutVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AboutVector(self) -> "IAgCrdnVector":
        """The Volume Calc Angle Off Vector reference about vector."""
        return self._intf.get_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._get_AboutVector_metadata)

    _set_AboutVector_metadata = { "name" : "AboutVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @AboutVector.setter
    def AboutVector(self, aboutVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcAngleOffVector._metadata, IAgCrdnVolumeCalcAngleOffVector._set_AboutVector_metadata, aboutVector)


agcls.AgClassCatalog.add_catalog_entry("{ad6880b4-afc1-47ba-b964-f38916955c7b}", IAgCrdnVolumeCalcAngleOffVector)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcAngleOffVector"] = IAgCrdnVolumeCalcAngleOffVector

class IAgCrdnVolumeCalcConditionSatMetric(object):
    """A volume calc condition satisfaction interface."""
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SpatialCondition" : 1,
                             "set_SpatialCondition" : 2,
                             "get_SatisfactionMetric" : 3,
                             "set_SatisfactionMetric" : 4,
                             "get_AccumulationType" : 5,
                             "set_AccumulationType" : 6,
                             "get_DurationType" : 7,
                             "set_DurationType" : 8,
                             "get_Filter" : 9,
                             "set_Filter" : 10,
                             "get_MaximumNumberOfIntervals" : 11,
                             "set_MaximumNumberOfIntervals" : 12,
                             "get_UseMinimumDuration" : 13,
                             "set_UseMinimumDuration" : 14,
                             "get_UseMaximumDuration" : 15,
                             "set_UseMaximumDuration" : 16,
                             "get_MinimumDurationTime" : 17,
                             "set_MinimumDurationTime" : 18,
                             "get_MaximumDurationTime" : 19,
                             "set_MaximumDurationTime" : 20, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcConditionSatMetric._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcConditionSatMetric from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcConditionSatMetric.__dict__ and type(IAgCrdnVolumeCalcConditionSatMetric.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcConditionSatMetric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcConditionSatMetric.")
    
    _get_SpatialCondition_metadata = { "name" : "SpatialCondition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SpatialCondition(self) -> "IAgCrdnVolume":
        """A spatial condition for satisfaction metric."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_SpatialCondition_metadata)

    _set_SpatialCondition_metadata = { "name" : "SpatialCondition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolume"),) }
    @SpatialCondition.setter
    def SpatialCondition(self, spatialCondition:"IAgCrdnVolume") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_SpatialCondition_metadata, spatialCondition)

    _get_SatisfactionMetric_metadata = { "name" : "SatisfactionMetric",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType),) }
    @property
    def SatisfactionMetric(self) -> "AgECrdnVolumeCalcVolumeSatisfactionMetricType":
        """Spatial condition satisfaction metric types."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_SatisfactionMetric_metadata)

    _set_SatisfactionMetric_metadata = { "name" : "SatisfactionMetric",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType),) }
    @SatisfactionMetric.setter
    def SatisfactionMetric(self, satisfactionMetric:"AgECrdnVolumeCalcVolumeSatisfactionMetricType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_SatisfactionMetric_metadata, satisfactionMetric)

    _get_AccumulationType_metadata = { "name" : "AccumulationType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType),) }
    @property
    def AccumulationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType":
        """Spatial condition satisfaction accumulation types."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_AccumulationType_metadata)

    _set_AccumulationType_metadata = { "name" : "AccumulationType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType),) }
    @AccumulationType.setter
    def AccumulationType(self, accumulationType:"AgECrdnVolumeCalcVolumeSatisfactionAccumulationType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_AccumulationType_metadata, accumulationType)

    _get_DurationType_metadata = { "name" : "DurationType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType),) }
    @property
    def DurationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionDurationType":
        """Spatial condition satisfaction duration types."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_DurationType_metadata)

    _set_DurationType_metadata = { "name" : "DurationType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType),) }
    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeCalcVolumeSatisfactionDurationType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_DurationType_metadata, durationType)

    _get_Filter_metadata = { "name" : "Filter",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType),) }
    @property
    def Filter(self) -> "AgECrdnVolumeCalcVolumeSatisfactionFilterType":
        """Spatial condition satisfaction duration types."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_Filter_metadata)

    _set_Filter_metadata = { "name" : "Filter",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType),) }
    @Filter.setter
    def Filter(self, filter:"AgECrdnVolumeCalcVolumeSatisfactionFilterType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_Filter_metadata, filter)

    _get_MaximumNumberOfIntervals_metadata = { "name" : "MaximumNumberOfIntervals",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Spatial condition satisfaction Maximum number of intervals."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_MaximumNumberOfIntervals_metadata)

    _set_MaximumNumberOfIntervals_metadata = { "name" : "MaximumNumberOfIntervals",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_MaximumNumberOfIntervals_metadata, maximumNumberOfIntervals)

    _get_UseMinimumDuration_metadata = { "name" : "UseMinimumDuration",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseMinimumDuration(self) -> bool:
        """Spatial condition satisfaction enable minimum duration."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_UseMinimumDuration_metadata)

    _set_UseMinimumDuration_metadata = { "name" : "UseMinimumDuration",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseMinimumDuration.setter
    def UseMinimumDuration(self, useMinimumDuration:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_UseMinimumDuration_metadata, useMinimumDuration)

    _get_UseMaximumDuration_metadata = { "name" : "UseMaximumDuration",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseMaximumDuration(self) -> bool:
        """Spatial condition satisfaction enable maximum duration."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_UseMaximumDuration_metadata)

    _set_UseMaximumDuration_metadata = { "name" : "UseMaximumDuration",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseMaximumDuration.setter
    def UseMaximumDuration(self, useMaximumDuration:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_UseMaximumDuration_metadata, useMaximumDuration)

    _get_MinimumDurationTime_metadata = { "name" : "MinimumDurationTime",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MinimumDurationTime(self) -> float:
        """Spatial condition satisfaction minimum duration time."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_MinimumDurationTime_metadata)

    _set_MinimumDurationTime_metadata = { "name" : "MinimumDurationTime",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MinimumDurationTime.setter
    def MinimumDurationTime(self, minimumDurationTime:float) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_MinimumDurationTime_metadata, minimumDurationTime)

    _get_MaximumDurationTime_metadata = { "name" : "MaximumDurationTime",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MaximumDurationTime(self) -> float:
        """Spatial condition satisfaction maximum duration time."""
        return self._intf.get_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._get_MaximumDurationTime_metadata)

    _set_MaximumDurationTime_metadata = { "name" : "MaximumDurationTime",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MaximumDurationTime.setter
    def MaximumDurationTime(self, maximumDurationTime:float) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcConditionSatMetric._metadata, IAgCrdnVolumeCalcConditionSatMetric._set_MaximumDurationTime_metadata, maximumDurationTime)


agcls.AgClassCatalog.add_catalog_entry("{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}", IAgCrdnVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcConditionSatMetric"] = IAgCrdnVolumeCalcConditionSatMetric

class IAgCrdnVolumeCalcDelayRange(object):
    """A volume calc propagation delay to location interface."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{874bf6c9-20d7-486c-918a-a0094093879a}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Distance" : 1,
                             "set_Distance" : 2,
                             "get_ReferencePoint" : 3,
                             "set_ReferencePoint" : 4,
                             "get_ReferencePlane" : 5,
                             "set_ReferencePlane" : 6,
                             "get_AlongVector" : 7,
                             "set_AlongVector" : 8,
                             "get_SpeedType" : 9,
                             "set_SpeedType" : 10,
                             "get_Speed" : 11,
                             "set_Speed" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcDelayRange._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcDelayRange from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcDelayRange.__dict__ and type(IAgCrdnVolumeCalcDelayRange.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcDelayRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcDelayRange.")
    
    _get_Distance_metadata = { "name" : "Distance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType),) }
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        return self._intf.get_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._get_Distance_metadata)

    _set_Distance_metadata = { "name" : "Distance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType),) }
    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._set_Distance_metadata, distance)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """The Volume Calc Range reference point."""
        return self._intf.get_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._get_ReferencePoint_metadata)

    _set_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._set_ReferencePoint_metadata, referencePoint)

    _get_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePlane(self) -> "IAgCrdnPlane":
        """The Volume Calc Range reference plane."""
        return self._intf.get_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._get_ReferencePlane_metadata)

    _set_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPlane"),) }
    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IAgCrdnPlane") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._set_ReferencePlane_metadata, referencePlane)

    _get_AlongVector_metadata = { "name" : "AlongVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AlongVector(self) -> "IAgCrdnVector":
        """The Volume Calc Range Along Vector."""
        return self._intf.get_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._get_AlongVector_metadata)

    _set_AlongVector_metadata = { "name" : "AlongVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @AlongVector.setter
    def AlongVector(self, alongVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._set_AlongVector_metadata, alongVector)

    _get_SpeedType_metadata = { "name" : "SpeedType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType),) }
    @property
    def SpeedType(self) -> "AgECrdnVolumeCalcRangeSpeedType":
        """The Volume Calc range speed types."""
        return self._intf.get_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._get_SpeedType_metadata)

    _set_SpeedType_metadata = { "name" : "SpeedType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType),) }
    @SpeedType.setter
    def SpeedType(self, speedType:"AgECrdnVolumeCalcRangeSpeedType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._set_SpeedType_metadata, speedType)

    _get_Speed_metadata = { "name" : "Speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Speed(self) -> float:
        """The Volume Calc range speed value"""
        return self._intf.get_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._get_Speed_metadata)

    _set_Speed_metadata = { "name" : "Speed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Speed.setter
    def Speed(self, speed:float) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcDelayRange._metadata, IAgCrdnVolumeCalcDelayRange._set_Speed_metadata, speed)


agcls.AgClassCatalog.add_catalog_entry("{874bf6c9-20d7-486c-918a-a0094093879a}", IAgCrdnVolumeCalcDelayRange)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcDelayRange"] = IAgCrdnVolumeCalcDelayRange

class IAgCrdnVolumeCalcFile(object):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{362b7405-edf6-486c-8fcf-1f9a93b75000}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Filename" : 1,
                             "set_Filename" : 2,
                             "Reload" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcFile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcFile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcFile.__dict__ and type(IAgCrdnVolumeCalcFile.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcFile.")
    
    _get_Filename_metadata = { "name" : "Filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the volume calc data."""
        return self._intf.get_property(IAgCrdnVolumeCalcFile._metadata, IAgCrdnVolumeCalcFile._get_Filename_metadata)

    _set_Filename_metadata = { "name" : "Filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Filename.setter
    def Filename(self, filename:str) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcFile._metadata, IAgCrdnVolumeCalcFile._set_Filename_metadata, filename)

    _Reload_metadata = { "name" : "Reload",
            "arg_types" : (),
            "marshallers" : () }
    def Reload(self) -> None:
        """Reloads the volume calc file."""
        return self._intf.invoke(IAgCrdnVolumeCalcFile._metadata, IAgCrdnVolumeCalcFile._Reload_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{362b7405-edf6-486c-8fcf-1f9a93b75000}", IAgCrdnVolumeCalcFile)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcFile"] = IAgCrdnVolumeCalcFile

class IAgCrdnVolumeCalcFromScalar(object):
    """A volume calc scalar to location interface."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6e537b27-ee55-44c5-89b2-f2c504a44bb6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Scalar" : 1,
                             "set_Scalar" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcFromScalar._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcFromScalar from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcFromScalar.__dict__ and type(IAgCrdnVolumeCalcFromScalar.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcFromScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcFromScalar.")
    
    _get_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """The Volume calc scalar to location Type."""
        return self._intf.get_property(IAgCrdnVolumeCalcFromScalar._metadata, IAgCrdnVolumeCalcFromScalar._get_Scalar_metadata)

    _set_Scalar_metadata = { "name" : "Scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcFromScalar._metadata, IAgCrdnVolumeCalcFromScalar._set_Scalar_metadata, scalar)


agcls.AgClassCatalog.add_catalog_entry("{6e537b27-ee55-44c5-89b2-f2c504a44bb6}", IAgCrdnVolumeCalcFromScalar)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcFromScalar"] = IAgCrdnVolumeCalcFromScalar

class IAgCrdnVolumeCalcRange(object):
    """A volume calc distance to location interface."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Distance" : 1,
                             "set_Distance" : 2,
                             "get_ReferencePoint" : 3,
                             "set_ReferencePoint" : 4,
                             "get_ReferencePlane" : 5,
                             "set_ReferencePlane" : 6,
                             "get_AlongVector" : 7,
                             "set_AlongVector" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcRange._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcRange from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcRange.__dict__ and type(IAgCrdnVolumeCalcRange.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcRange.")
    
    _get_Distance_metadata = { "name" : "Distance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType),) }
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        return self._intf.get_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._get_Distance_metadata)

    _set_Distance_metadata = { "name" : "Distance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType),) }
    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._set_Distance_metadata, distance)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """The Volume Calc Range reference point."""
        return self._intf.get_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._get_ReferencePoint_metadata)

    _set_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._set_ReferencePoint_metadata, referencePoint)

    _get_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePlane(self) -> "IAgCrdnPlane":
        """The Volume Calc Range reference plane."""
        return self._intf.get_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._get_ReferencePlane_metadata)

    _set_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPlane"),) }
    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IAgCrdnPlane") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._set_ReferencePlane_metadata, referencePlane)

    _get_AlongVector_metadata = { "name" : "AlongVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AlongVector(self) -> "IAgCrdnVector":
        """The Volume Calc Range Along Vector."""
        return self._intf.get_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._get_AlongVector_metadata)

    _set_AlongVector_metadata = { "name" : "AlongVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @AlongVector.setter
    def AlongVector(self, alongVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcRange._metadata, IAgCrdnVolumeCalcRange._set_AlongVector_metadata, alongVector)


agcls.AgClassCatalog.add_catalog_entry("{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}", IAgCrdnVolumeCalcRange)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcRange"] = IAgCrdnVolumeCalcRange

class IAgCrdnVolumeCalcSolarIntensity(object):
    """A volume calc solar intensityn interface."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{40e35f2b-9a83-449a-9a4e-35bdee832061}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_EclipsingBodies" : 1,
                             "set_EclipsingBodies" : 2,
                             "get_UseObjectEclipsingBodies" : 3,
                             "set_UseObjectEclipsingBodies" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCalcSolarIntensity._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCalcSolarIntensity from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcSolarIntensity.__dict__ and type(IAgCrdnVolumeCalcSolarIntensity.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcSolarIntensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCalcSolarIntensity.")
    
    _get_EclipsingBodies_metadata = { "name" : "EclipsingBodies",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(IAgCrdnVolumeCalcSolarIntensity._metadata, IAgCrdnVolumeCalcSolarIntensity._get_EclipsingBodies_metadata)

    _set_EclipsingBodies_metadata = { "name" : "EclipsingBodies",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcSolarIntensity._metadata, IAgCrdnVolumeCalcSolarIntensity._set_EclipsingBodies_metadata, eclipsingBodies)

    _get_UseObjectEclipsingBodies_metadata = { "name" : "UseObjectEclipsingBodies",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(IAgCrdnVolumeCalcSolarIntensity._metadata, IAgCrdnVolumeCalcSolarIntensity._get_UseObjectEclipsingBodies_metadata)

    _set_UseObjectEclipsingBodies_metadata = { "name" : "UseObjectEclipsingBodies",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeCalcSolarIntensity._metadata, IAgCrdnVolumeCalcSolarIntensity._set_UseObjectEclipsingBodies_metadata, useObjectEclipsingBodies)


agcls.AgClassCatalog.add_catalog_entry("{40e35f2b-9a83-449a-9a4e-35bdee832061}", IAgCrdnVolumeCalcSolarIntensity)
agcls.AgTypeNameMap["IAgCrdnVolumeCalcSolarIntensity"] = IAgCrdnVolumeCalcSolarIntensity

class IAgCrdnVolumeCombined(object):
    """A combined volume interface."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{96684FB4-3839-44DB-AD80-B772BF58A39A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CombineOperation" : 1,
                             "set_CombineOperation" : 2,
                             "get_ConditionCount" : 3,
                             "GetAllConditions" : 4,
                             "SetAllConditions" : 5,
                             "SetCondition" : 6,
                             "GetCondition" : 7,
                             "RemoveCondition" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeCombined._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeCombined from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCombined.__dict__ and type(IAgCrdnVolumeCombined.__dict__[attrname]) == property:
            return IAgCrdnVolumeCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeCombined.")
    
    _get_CombineOperation_metadata = { "name" : "CombineOperation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType),) }
    @property
    def CombineOperation(self) -> "AgECrdnVolumeCombinedOperationType":
        """Sets/Returns volume combined operation."""
        return self._intf.get_property(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._get_CombineOperation_metadata)

    _set_CombineOperation_metadata = { "name" : "CombineOperation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType),) }
    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnVolumeCombinedOperationType") -> None:
        return self._intf.set_property(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._set_CombineOperation_metadata, combineOperation)

    _get_ConditionCount_metadata = { "name" : "ConditionCount",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def ConditionCount(self) -> int:
        """Returns the spatial condition vector size."""
        return self._intf.get_property(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._get_ConditionCount_metadata)

    _GetAllConditions_metadata = { "name" : "GetAllConditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def GetAllConditions(self) -> list:
        """Get all spatial conditions."""
        return self._intf.invoke(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._GetAllConditions_metadata, out_arg())

    _SetAllConditions_metadata = { "name" : "SetAllConditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def SetAllConditions(self, conditions:list) -> None:
        """Set all spatial conditions."""
        return self._intf.invoke(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._SetAllConditions_metadata, conditions)

    _SetCondition_metadata = { "name" : "SetCondition",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolume"), agmarshall.INT_arg,) }
    def SetCondition(self, ref:"IAgCrdnVolume", pos:int) -> None:
        """Set spatial conditions at a position."""
        return self._intf.invoke(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._SetCondition_metadata, ref, pos)

    _GetCondition_metadata = { "name" : "GetCondition",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetCondition(self, pos:int) -> "IAgCrdnVolume":
        """Get spatial conditions at a position."""
        return self._intf.invoke(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._GetCondition_metadata, pos, out_arg())

    _RemoveCondition_metadata = { "name" : "RemoveCondition",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    def RemoveCondition(self, pos:int) -> None:
        """Remove spatial conditions at a position."""
        return self._intf.invoke(IAgCrdnVolumeCombined._metadata, IAgCrdnVolumeCombined._RemoveCondition_metadata, pos)


agcls.AgClassCatalog.add_catalog_entry("{96684FB4-3839-44DB-AD80-B772BF58A39A}", IAgCrdnVolumeCombined)
agcls.AgTypeNameMap["IAgCrdnVolumeCombined"] = IAgCrdnVolumeCombined

class IAgCrdnVolumeFromCalc(object):
    """An volume from calc volume interface."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{018666E1-C0E6-46F6-A682-F91FBF3C74F3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Operation" : 1,
                             "set_Operation" : 2,
                             "get_VolumeCalc" : 3,
                             "set_VolumeCalc" : 4,
                             "GetMinimum" : 5,
                             "SetMinimum" : 6,
                             "GetMaximum" : 7,
                             "SetMaximum" : 8,
                             "Set" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeFromCalc._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeFromCalc from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromCalc.__dict__ and type(IAgCrdnVolumeFromCalc.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeFromCalc.")
    
    _get_Operation_metadata = { "name" : "Operation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption),) }
    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        return self._intf.get_property(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._get_Operation_metadata)

    _set_Operation_metadata = { "name" : "Operation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption),) }
    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._set_Operation_metadata, operation)

    _get_VolumeCalc_metadata = { "name" : "VolumeCalc",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VolumeCalc(self) -> "IAgCrdnVolumeCalc":
        """Get the volume calc from the bounds."""
        return self._intf.get_property(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._get_VolumeCalc_metadata)

    _set_VolumeCalc_metadata = { "name" : "VolumeCalc",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolumeCalc"),) }
    @VolumeCalc.setter
    def VolumeCalc(self, volumeCalc:"IAgCrdnVolumeCalc") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._set_VolumeCalc_metadata, volumeCalc)

    _GetMinimum_metadata = { "name" : "GetMinimum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetMinimum(self) -> "IAgQuantity":
        """Get the minimum bound value from the bounds. Call SetMinimum to apply changes."""
        return self._intf.invoke(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._GetMinimum_metadata, out_arg())

    _SetMinimum_metadata = { "name" : "SetMinimum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    def SetMinimum(self, value:"IAgQuantity") -> None:
        """Set the minimum bound value for the bounds."""
        return self._intf.invoke(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._SetMinimum_metadata, value)

    _GetMaximum_metadata = { "name" : "GetMaximum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetMaximum(self) -> "IAgQuantity":
        """Get the maximum bound value from the bounds. Call SetMaximum to apply changes."""
        return self._intf.invoke(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._GetMaximum_metadata, out_arg())

    _SetMaximum_metadata = { "name" : "SetMaximum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    def SetMaximum(self, value:"IAgQuantity") -> None:
        """Set the maximum bound value for the condition."""
        return self._intf.invoke(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._SetMaximum_metadata, value)

    _Set_metadata = { "name" : "Set",
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgQuantity"), agmarshall.AgInterface_in_arg("IAgQuantity"),) }
    def Set(self, min:"IAgQuantity", max:"IAgQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(IAgCrdnVolumeFromCalc._metadata, IAgCrdnVolumeFromCalc._Set_metadata, min, max)


agcls.AgClassCatalog.add_catalog_entry("{018666E1-C0E6-46F6-A682-F91FBF3C74F3}", IAgCrdnVolumeFromCalc)
agcls.AgTypeNameMap["IAgCrdnVolumeFromCalc"] = IAgCrdnVolumeFromCalc

class IAgCrdnVolumeFromCondition(object):
    """A volume from conditioninterface."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Condition" : 1,
                             "set_Condition" : 2,
                             "get_UseCustomTimeLimits" : 3,
                             "set_UseCustomTimeLimits" : 4,
                             "get_CustomTimeLimits" : 5,
                             "set_CustomTimeLimits" : 6,
                             "get_Sampling" : 7,
                             "set_Sampling" : 8,
                             "get_Convergence" : 9,
                             "set_Convergence" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeFromCondition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeFromCondition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromCondition.__dict__ and type(IAgCrdnVolumeFromCondition.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeFromCondition.")
    
    _get_Condition_metadata = { "name" : "Condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """The condition component."""
        return self._intf.get_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._get_Condition_metadata)

    _set_Condition_metadata = { "name" : "Condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCondition"),) }
    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._set_Condition_metadata, condition)

    _get_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._get_UseCustomTimeLimits_metadata)

    _set_UseCustomTimeLimits_metadata = { "name" : "UseCustomTimeLimits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._set_UseCustomTimeLimits_metadata, useCustomTimeLimits)

    _get_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._get_CustomTimeLimits_metadata)

    _set_CustomTimeLimits_metadata = { "name" : "CustomTimeLimits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._set_CustomTimeLimits_metadata, customTimeLimits)

    _get_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._get_Sampling_metadata)

    _set_Sampling_metadata = { "name" : "Sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSampling"),) }
    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._set_Sampling_metadata, sampling)

    _get_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        return self._intf.get_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._get_Convergence_metadata)

    _set_Convergence_metadata = { "name" : "Convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnConverge"),) }
    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromCondition._metadata, IAgCrdnVolumeFromCondition._set_Convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}", IAgCrdnVolumeFromCondition)
agcls.AgTypeNameMap["IAgCrdnVolumeFromCondition"] = IAgCrdnVolumeFromCondition

class IAgCrdnVolumeFromGrid(object):
    """An over time volume interface."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_EdgeType" : 1,
                             "set_EdgeType" : 2,
                             "get_VolumeGrid" : 3,
                             "set_VolumeGrid" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeFromGrid._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeFromGrid from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromGrid.__dict__ and type(IAgCrdnVolumeFromGrid.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeFromGrid.")
    
    _get_EdgeType_metadata = { "name" : "EdgeType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType),) }
    @property
    def EdgeType(self) -> "AgECrdnVolumeFromGridEdgeType":
        """Sets/Returns the edge type."""
        return self._intf.get_property(IAgCrdnVolumeFromGrid._metadata, IAgCrdnVolumeFromGrid._get_EdgeType_metadata)

    _set_EdgeType_metadata = { "name" : "EdgeType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType),) }
    @EdgeType.setter
    def EdgeType(self, edgeType:"AgECrdnVolumeFromGridEdgeType") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromGrid._metadata, IAgCrdnVolumeFromGrid._set_EdgeType_metadata, edgeType)

    _get_VolumeGrid_metadata = { "name" : "VolumeGrid",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VolumeGrid(self) -> "IAgCrdnVolumeGrid":
        """Sets/Returns the volume grid for bounding."""
        return self._intf.get_property(IAgCrdnVolumeFromGrid._metadata, IAgCrdnVolumeFromGrid._get_VolumeGrid_metadata)

    _set_VolumeGrid_metadata = { "name" : "VolumeGrid",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolumeGrid"),) }
    @VolumeGrid.setter
    def VolumeGrid(self, volumeGrid:"IAgCrdnVolumeGrid") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromGrid._metadata, IAgCrdnVolumeFromGrid._set_VolumeGrid_metadata, volumeGrid)


agcls.AgClassCatalog.add_catalog_entry("{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}", IAgCrdnVolumeFromGrid)
agcls.AgTypeNameMap["IAgCrdnVolumeFromGrid"] = IAgCrdnVolumeFromGrid

class IAgCrdnVolumeFromTimeSatisfaction(object):
    """An volume from time satisfaction volume interface."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TimeSatisfaction" : 1,
                             "set_TimeSatisfaction" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeFromTimeSatisfaction._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeFromTimeSatisfaction from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromTimeSatisfaction.__dict__ and type(IAgCrdnVolumeFromTimeSatisfaction.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromTimeSatisfaction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeFromTimeSatisfaction.")
    
    _get_TimeSatisfaction_metadata = { "name" : "TimeSatisfaction",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TimeSatisfaction(self) -> "IAgCrdnEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(IAgCrdnVolumeFromTimeSatisfaction._metadata, IAgCrdnVolumeFromTimeSatisfaction._get_TimeSatisfaction_metadata)

    _set_TimeSatisfaction_metadata = { "name" : "TimeSatisfaction",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @TimeSatisfaction.setter
    def TimeSatisfaction(self, timeSatisfaction:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnVolumeFromTimeSatisfaction._metadata, IAgCrdnVolumeFromTimeSatisfaction._set_TimeSatisfaction_metadata, timeSatisfaction)


agcls.AgClassCatalog.add_catalog_entry("{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}", IAgCrdnVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap["IAgCrdnVolumeFromTimeSatisfaction"] = IAgCrdnVolumeFromTimeSatisfaction

class IAgCrdnVolumeGrid(object):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{88BBE781-85C1-439D-A4F4-58006B9A35EC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGrid._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGrid from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGrid.__dict__ and type(IAgCrdnVolumeGrid.__dict__[attrname]) == property:
            return IAgCrdnVolumeGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGrid.")
    

agcls.AgClassCatalog.add_catalog_entry("{88BBE781-85C1-439D-A4F4-58006B9A35EC}", IAgCrdnVolumeGrid)
agcls.AgTypeNameMap["IAgCrdnVolumeGrid"] = IAgCrdnVolumeGrid

class IAgCrdnVolumeGridBearingAlt(object):
    """A volume grid bearing alt (Surface Bearing) interface."""
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2814A890-E858-41A6-B640-19F9D27E5ACB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceCentralBody" : 1,
                             "set_ReferenceCentralBody" : 2,
                             "get_AlongBearingCoordinates" : 3,
                             "get_CrossBearingCoordinates" : 4,
                             "get_AltitudeCoordinates" : 5,
                             "get_AutoFitBounds" : 6,
                             "set_AutoFitBounds" : 7,
                             "get_BearingAngle" : 8,
                             "set_BearingAngle" : 9,
                             "get_ReferenceLocation" : 10,
                             "set_ReferenceLocation" : 11, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridBearingAlt._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridBearingAlt from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridBearingAlt.__dict__ and type(IAgCrdnVolumeGridBearingAlt.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridBearingAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridBearingAlt.")
    
    _get_ReferenceCentralBody_metadata = { "name" : "ReferenceCentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._get_ReferenceCentralBody_metadata)

    _set_ReferenceCentralBody_metadata = { "name" : "ReferenceCentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        return self._intf.set_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._set_ReferenceCentralBody_metadata, referenceCentralBody)

    _get_AlongBearingCoordinates_metadata = { "name" : "AlongBearingCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AlongBearingCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns AlongBearing Coordinates parameters for the surface bearing."""
        return self._intf.get_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._get_AlongBearingCoordinates_metadata)

    _get_CrossBearingCoordinates_metadata = { "name" : "CrossBearingCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CrossBearingCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns CrossBearing Coordinates parameters for the surface bearing."""
        return self._intf.get_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._get_CrossBearingCoordinates_metadata)

    _get_AltitudeCoordinates_metadata = { "name" : "AltitudeCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AltitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns altitude Coordinates parameters for the surface bearing."""
        return self._intf.get_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._get_AltitudeCoordinates_metadata)

    _get_AutoFitBounds_metadata = { "name" : "AutoFitBounds",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        return self._intf.get_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._get_AutoFitBounds_metadata)

    _set_AutoFitBounds_metadata = { "name" : "AutoFitBounds",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._set_AutoFitBounds_metadata, autoFitBounds)

    _get_BearingAngle_metadata = { "name" : "BearingAngle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def BearingAngle(self) -> float:
        """Specify the Bearing Angle."""
        return self._intf.get_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._get_BearingAngle_metadata)

    _set_BearingAngle_metadata = { "name" : "BearingAngle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @BearingAngle.setter
    def BearingAngle(self, bearingAngle:float) -> None:
        return self._intf.set_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._set_BearingAngle_metadata, bearingAngle)

    _get_ReferenceLocation_metadata = { "name" : "ReferenceLocation",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def ReferenceLocation(self) -> list:
        """Get lat/lon for reference location"""
        return self._intf.get_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._get_ReferenceLocation_metadata)

    _set_ReferenceLocation_metadata = { "name" : "ReferenceLocation",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @ReferenceLocation.setter
    def ReferenceLocation(self, referenceLocation:list) -> None:
        return self._intf.set_property(IAgCrdnVolumeGridBearingAlt._metadata, IAgCrdnVolumeGridBearingAlt._set_ReferenceLocation_metadata, referenceLocation)


agcls.AgClassCatalog.add_catalog_entry("{2814A890-E858-41A6-B640-19F9D27E5ACB}", IAgCrdnVolumeGridBearingAlt)
agcls.AgTypeNameMap["IAgCrdnVolumeGridBearingAlt"] = IAgCrdnVolumeGridBearingAlt

class IAgCrdnVolumeGridCartesian(object):
    """A volume grid Cartesian interface."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E959F851-165E-4201-8C13-81FA4C2D3E2D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceSystem" : 1,
                             "set_ReferenceSystem" : 2,
                             "get_XCoordinates" : 3,
                             "get_YCoordinates" : 4,
                             "get_ZCoordinates" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridCartesian._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridCartesian from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridCartesian.__dict__ and type(IAgCrdnVolumeGridCartesian.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridCartesian.")
    
    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which Cartesian parameters are computed."""
        return self._intf.get_property(IAgCrdnVolumeGridCartesian._metadata, IAgCrdnVolumeGridCartesian._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnVolumeGridCartesian._metadata, IAgCrdnVolumeGridCartesian._set_ReferenceSystem_metadata, referenceSystem)

    _get_XCoordinates_metadata = { "name" : "XCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def XCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns X Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(IAgCrdnVolumeGridCartesian._metadata, IAgCrdnVolumeGridCartesian._get_XCoordinates_metadata)

    _get_YCoordinates_metadata = { "name" : "YCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def YCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns Y Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(IAgCrdnVolumeGridCartesian._metadata, IAgCrdnVolumeGridCartesian._get_YCoordinates_metadata)

    _get_ZCoordinates_metadata = { "name" : "ZCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ZCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns Z Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(IAgCrdnVolumeGridCartesian._metadata, IAgCrdnVolumeGridCartesian._get_ZCoordinates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{E959F851-165E-4201-8C13-81FA4C2D3E2D}", IAgCrdnVolumeGridCartesian)
agcls.AgTypeNameMap["IAgCrdnVolumeGridCartesian"] = IAgCrdnVolumeGridCartesian

class IAgCrdnVolumeGridConstrained(object):
    """A volume grid constrained interface."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceGrid" : 1,
                             "set_ReferenceGrid" : 2,
                             "get_Constraint" : 3,
                             "set_Constraint" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridConstrained._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridConstrained from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridConstrained.__dict__ and type(IAgCrdnVolumeGridConstrained.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridConstrained.")
    
    _get_ReferenceGrid_metadata = { "name" : "ReferenceGrid",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceGrid(self) -> "IAgCrdnVolumeGrid":
        """Get the reference system in which spherical parameters are computed."""
        return self._intf.get_property(IAgCrdnVolumeGridConstrained._metadata, IAgCrdnVolumeGridConstrained._get_ReferenceGrid_metadata)

    _set_ReferenceGrid_metadata = { "name" : "ReferenceGrid",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolumeGrid"),) }
    @ReferenceGrid.setter
    def ReferenceGrid(self, referenceGrid:"IAgCrdnVolumeGrid") -> None:
        return self._intf.set_property(IAgCrdnVolumeGridConstrained._metadata, IAgCrdnVolumeGridConstrained._set_ReferenceGrid_metadata, referenceGrid)

    _get_Constraint_metadata = { "name" : "Constraint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Constraint(self) -> "IAgCrdnVolume":
        """Get the volume constraint on the grid."""
        return self._intf.get_property(IAgCrdnVolumeGridConstrained._metadata, IAgCrdnVolumeGridConstrained._get_Constraint_metadata)

    _set_Constraint_metadata = { "name" : "Constraint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolume"),) }
    @Constraint.setter
    def Constraint(self, constraint:"IAgCrdnVolume") -> None:
        return self._intf.set_property(IAgCrdnVolumeGridConstrained._metadata, IAgCrdnVolumeGridConstrained._set_Constraint_metadata, constraint)


agcls.AgClassCatalog.add_catalog_entry("{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}", IAgCrdnVolumeGridConstrained)
agcls.AgTypeNameMap["IAgCrdnVolumeGridConstrained"] = IAgCrdnVolumeGridConstrained

class IAgCrdnVolumeGridCylindrical(object):
    """A volume grid cylindrical interface."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0CF87427-CC2B-4282-9B41-0A2D86395AD4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceSystem" : 1,
                             "set_ReferenceSystem" : 2,
                             "get_ThetaCoordinates" : 3,
                             "get_RadiusCoordinates" : 4,
                             "get_HeightCoordinates" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridCylindrical._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridCylindrical from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridCylindrical.__dict__ and type(IAgCrdnVolumeGridCylindrical.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridCylindrical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridCylindrical.")
    
    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which cylindrical parameters are computed."""
        return self._intf.get_property(IAgCrdnVolumeGridCylindrical._metadata, IAgCrdnVolumeGridCylindrical._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnVolumeGridCylindrical._metadata, IAgCrdnVolumeGridCylindrical._set_ReferenceSystem_metadata, referenceSystem)

    _get_ThetaCoordinates_metadata = { "name" : "ThetaCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ThetaCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns theta Coordinates parameters for the Theta system."""
        return self._intf.get_property(IAgCrdnVolumeGridCylindrical._metadata, IAgCrdnVolumeGridCylindrical._get_ThetaCoordinates_metadata)

    _get_RadiusCoordinates_metadata = { "name" : "RadiusCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def RadiusCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns radius Coordinates parameters for the Radius system."""
        return self._intf.get_property(IAgCrdnVolumeGridCylindrical._metadata, IAgCrdnVolumeGridCylindrical._get_RadiusCoordinates_metadata)

    _get_HeightCoordinates_metadata = { "name" : "HeightCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def HeightCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns height Coordinates parameters for the Height system."""
        return self._intf.get_property(IAgCrdnVolumeGridCylindrical._metadata, IAgCrdnVolumeGridCylindrical._get_HeightCoordinates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{0CF87427-CC2B-4282-9B41-0A2D86395AD4}", IAgCrdnVolumeGridCylindrical)
agcls.AgTypeNameMap["IAgCrdnVolumeGridCylindrical"] = IAgCrdnVolumeGridCylindrical

class IAgCrdnVolumeGridLatLonAlt(object):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceCentralBody" : 1,
                             "set_ReferenceCentralBody" : 2,
                             "get_LatitudeCoordinates" : 3,
                             "get_LongitudeCoordinates" : 4,
                             "get_AltitudeCoordinates" : 5,
                             "get_AutoFitBounds" : 6,
                             "set_AutoFitBounds" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridLatLonAlt._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridLatLonAlt from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridLatLonAlt.__dict__ and type(IAgCrdnVolumeGridLatLonAlt.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridLatLonAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridLatLonAlt.")
    
    _get_ReferenceCentralBody_metadata = { "name" : "ReferenceCentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridLatLonAlt._metadata, IAgCrdnVolumeGridLatLonAlt._get_ReferenceCentralBody_metadata)

    _set_ReferenceCentralBody_metadata = { "name" : "ReferenceCentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        return self._intf.set_property(IAgCrdnVolumeGridLatLonAlt._metadata, IAgCrdnVolumeGridLatLonAlt._set_ReferenceCentralBody_metadata, referenceCentralBody)

    _get_LatitudeCoordinates_metadata = { "name" : "LatitudeCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def LatitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns latitude Coordinates parameters for the Theta system."""
        return self._intf.get_property(IAgCrdnVolumeGridLatLonAlt._metadata, IAgCrdnVolumeGridLatLonAlt._get_LatitudeCoordinates_metadata)

    _get_LongitudeCoordinates_metadata = { "name" : "LongitudeCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def LongitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns longtitude Coordinates parameters for the Radius system."""
        return self._intf.get_property(IAgCrdnVolumeGridLatLonAlt._metadata, IAgCrdnVolumeGridLatLonAlt._get_LongitudeCoordinates_metadata)

    _get_AltitudeCoordinates_metadata = { "name" : "AltitudeCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AltitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns altitude parameters for the Height system."""
        return self._intf.get_property(IAgCrdnVolumeGridLatLonAlt._metadata, IAgCrdnVolumeGridLatLonAlt._get_AltitudeCoordinates_metadata)

    _get_AutoFitBounds_metadata = { "name" : "AutoFitBounds",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        return self._intf.get_property(IAgCrdnVolumeGridLatLonAlt._metadata, IAgCrdnVolumeGridLatLonAlt._get_AutoFitBounds_metadata)

    _set_AutoFitBounds_metadata = { "name" : "AutoFitBounds",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeGridLatLonAlt._metadata, IAgCrdnVolumeGridLatLonAlt._set_AutoFitBounds_metadata, autoFitBounds)


agcls.AgClassCatalog.add_catalog_entry("{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}", IAgCrdnVolumeGridLatLonAlt)
agcls.AgTypeNameMap["IAgCrdnVolumeGridLatLonAlt"] = IAgCrdnVolumeGridLatLonAlt

class IAgCrdnVolumeGridResult(object):
    """An interface that generates Volume Grid results."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1C3B106C-011E-4C51-B321-20389C8EAF76}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Epoch" : 1,
                             "get_SizeI" : 2,
                             "get_SizeJ" : 3,
                             "get_SizeK" : 4,
                             "get_VolumeMetricDataVector" : 5,
                             "get_VolumeMetricPositionVector" : 6,
                             "get_VolumeMetricNativePositionVector" : 7,
                             "get_VolumeMetricGradientVector" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridResult.__dict__ and type(IAgCrdnVolumeGridResult.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridResult.")
    
    _get_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Epoch(self) -> typing.Any:
        """Epoch of returned volumetric data."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_Epoch_metadata)

    _get_SizeI_metadata = { "name" : "SizeI",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def SizeI(self) -> int:
        """Number of grid point coordinates representing first dimension of volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_SizeI_metadata)

    _get_SizeJ_metadata = { "name" : "SizeJ",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def SizeJ(self) -> int:
        """Number of grid point coordinates representing second dimension of volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_SizeJ_metadata)

    _get_SizeK_metadata = { "name" : "SizeK",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def SizeK(self) -> int:
        """Number of grid point coordinates representing third dimension of volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_SizeK_metadata)

    _get_VolumeMetricDataVector_metadata = { "name" : "VolumeMetricDataVector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def VolumeMetricDataVector(self) -> list:
        """Vector of scalar values representing volumetric data."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_VolumeMetricDataVector_metadata)

    _get_VolumeMetricPositionVector_metadata = { "name" : "VolumeMetricPositionVector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def VolumeMetricPositionVector(self) -> list:
        """Vector of Cartesian coordinates of all volume grid points."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_VolumeMetricPositionVector_metadata)

    _get_VolumeMetricNativePositionVector_metadata = { "name" : "VolumeMetricNativePositionVector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def VolumeMetricNativePositionVector(self) -> list:
        """Vector of native coordinates of all volume grid points."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_VolumeMetricNativePositionVector_metadata)

    _get_VolumeMetricGradientVector_metadata = { "name" : "VolumeMetricGradientVector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def VolumeMetricGradientVector(self) -> list:
        """Vector of Cartesian coordinates representing gradient vectors at all volume grid points."""
        return self._intf.get_property(IAgCrdnVolumeGridResult._metadata, IAgCrdnVolumeGridResult._get_VolumeMetricGradientVector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1C3B106C-011E-4C51-B321-20389C8EAF76}", IAgCrdnVolumeGridResult)
agcls.AgTypeNameMap["IAgCrdnVolumeGridResult"] = IAgCrdnVolumeGridResult

class IAgCrdnVolumeGridSpherical(object):
    """A volume grid spherical interface."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceSystem" : 1,
                             "set_ReferenceSystem" : 2,
                             "get_AzimuthCoordinates" : 3,
                             "get_ElevationCoordinates" : 4,
                             "get_RangeCoordinates" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeGridSpherical._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeGridSpherical from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridSpherical.__dict__ and type(IAgCrdnVolumeGridSpherical.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeGridSpherical.")
    
    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which spherical parameters are computed."""
        return self._intf.get_property(IAgCrdnVolumeGridSpherical._metadata, IAgCrdnVolumeGridSpherical._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnVolumeGridSpherical._metadata, IAgCrdnVolumeGridSpherical._set_ReferenceSystem_metadata, referenceSystem)

    _get_AzimuthCoordinates_metadata = { "name" : "AzimuthCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AzimuthCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns azimuth coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridSpherical._metadata, IAgCrdnVolumeGridSpherical._get_AzimuthCoordinates_metadata)

    _get_ElevationCoordinates_metadata = { "name" : "ElevationCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ElevationCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns elevation coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridSpherical._metadata, IAgCrdnVolumeGridSpherical._get_ElevationCoordinates_metadata)

    _get_RangeCoordinates_metadata = { "name" : "RangeCoordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def RangeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns range coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(IAgCrdnVolumeGridSpherical._metadata, IAgCrdnVolumeGridSpherical._get_RangeCoordinates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}", IAgCrdnVolumeGridSpherical)
agcls.AgTypeNameMap["IAgCrdnVolumeGridSpherical"] = IAgCrdnVolumeGridSpherical

class IAgCrdnVolumeInview(object):
    """An Inview volume interface."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EF724630-CEB6-4818-A5BB-F74CF1B9D931}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ConstraintObject" : 1,
                             "set_ConstraintObject" : 2,
                             "get_LightTimeDelay" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeInview._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeInview from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeInview.__dict__ and type(IAgCrdnVolumeInview.__dict__[attrname]) == property:
            return IAgCrdnVolumeInview.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeInview.")
    
    _get_ConstraintObject_metadata = { "name" : "ConstraintObject",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def ConstraintObject(self) -> typing.Any:
        """A constraint object of the access."""
        return self._intf.get_property(IAgCrdnVolumeInview._metadata, IAgCrdnVolumeInview._get_ConstraintObject_metadata)

    _set_ConstraintObject_metadata = { "name" : "ConstraintObject",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @ConstraintObject.setter
    def ConstraintObject(self, constraintObject:typing.Any) -> None:
        return self._intf.set_property(IAgCrdnVolumeInview._metadata, IAgCrdnVolumeInview._set_ConstraintObject_metadata, constraintObject)

    _get_LightTimeDelay_metadata = { "name" : "LightTimeDelay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def LightTimeDelay(self) -> "IAgCrdnLightTimeDelay":
        """Returns Light Time Delay options parameters."""
        return self._intf.get_property(IAgCrdnVolumeInview._metadata, IAgCrdnVolumeInview._get_LightTimeDelay_metadata)


agcls.AgClassCatalog.add_catalog_entry("{EF724630-CEB6-4818-A5BB-F74CF1B9D931}", IAgCrdnVolumeInview)
agcls.AgTypeNameMap["IAgCrdnVolumeInview"] = IAgCrdnVolumeInview

class IAgCrdnVolumeLighting(object):
    """A lighting volume interface."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CE134C08-274E-4E29-9337-03E9C73AA8F9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_EclipsingBodies" : 1,
                             "set_EclipsingBodies" : 2,
                             "get_UseObjectEclipsingBodies" : 3,
                             "set_UseObjectEclipsingBodies" : 4,
                             "get_LightingConditions" : 5,
                             "set_LightingConditions" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeLighting._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeLighting from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeLighting.__dict__ and type(IAgCrdnVolumeLighting.__dict__[attrname]) == property:
            return IAgCrdnVolumeLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeLighting.")
    
    _get_EclipsingBodies_metadata = { "name" : "EclipsingBodies",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(IAgCrdnVolumeLighting._metadata, IAgCrdnVolumeLighting._get_EclipsingBodies_metadata)

    _set_EclipsingBodies_metadata = { "name" : "EclipsingBodies",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(IAgCrdnVolumeLighting._metadata, IAgCrdnVolumeLighting._set_EclipsingBodies_metadata, eclipsingBodies)

    _get_UseObjectEclipsingBodies_metadata = { "name" : "UseObjectEclipsingBodies",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(IAgCrdnVolumeLighting._metadata, IAgCrdnVolumeLighting._get_UseObjectEclipsingBodies_metadata)

    _set_UseObjectEclipsingBodies_metadata = { "name" : "UseObjectEclipsingBodies",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(IAgCrdnVolumeLighting._metadata, IAgCrdnVolumeLighting._set_UseObjectEclipsingBodies_metadata, useObjectEclipsingBodies)

    _get_LightingConditions_metadata = { "name" : "LightingConditions",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType),) }
    @property
    def LightingConditions(self) -> "AgECrdnVolumeLightingConditionsType":
        """Sets/Returns the lighting conditions."""
        return self._intf.get_property(IAgCrdnVolumeLighting._metadata, IAgCrdnVolumeLighting._get_LightingConditions_metadata)

    _set_LightingConditions_metadata = { "name" : "LightingConditions",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType),) }
    @LightingConditions.setter
    def LightingConditions(self, lightingConditions:"AgECrdnVolumeLightingConditionsType") -> None:
        return self._intf.set_property(IAgCrdnVolumeLighting._metadata, IAgCrdnVolumeLighting._set_LightingConditions_metadata, lightingConditions)


agcls.AgClassCatalog.add_catalog_entry("{CE134C08-274E-4E29-9337-03E9C73AA8F9}", IAgCrdnVolumeLighting)
agcls.AgTypeNameMap["IAgCrdnVolumeLighting"] = IAgCrdnVolumeLighting

class IAgCrdnVolumeOverTime(object):
    """An over time volume interface."""
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_DurationType" : 1,
                             "set_DurationType" : 2,
                             "get_ReferenceVolume" : 3,
                             "set_ReferenceVolume" : 4,
                             "get_ReferenceIntervals" : 5,
                             "set_ReferenceIntervals" : 6,
                             "get_StartOffset" : 7,
                             "set_StartOffset" : 8,
                             "get_StopOffset" : 9,
                             "set_StopOffset" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVolumeOverTime._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVolumeOverTime from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeOverTime.__dict__ and type(IAgCrdnVolumeOverTime.__dict__[attrname]) == property:
            return IAgCrdnVolumeOverTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVolumeOverTime.")
    
    _get_DurationType_metadata = { "name" : "DurationType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType),) }
    @property
    def DurationType(self) -> "AgECrdnVolumeOverTimeDurationType":
        """Sets/Returns the lighting conditions."""
        return self._intf.get_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._get_DurationType_metadata)

    _set_DurationType_metadata = { "name" : "DurationType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType),) }
    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeOverTimeDurationType") -> None:
        return self._intf.set_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._set_DurationType_metadata, durationType)

    _get_ReferenceVolume_metadata = { "name" : "ReferenceVolume",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVolume(self) -> "IAgCrdnVolume":
        """Sets/Returns the reference volume."""
        return self._intf.get_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._get_ReferenceVolume_metadata)

    _set_ReferenceVolume_metadata = { "name" : "ReferenceVolume",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVolume"),) }
    @ReferenceVolume.setter
    def ReferenceVolume(self, referenceVolume:"IAgCrdnVolume") -> None:
        return self._intf.set_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._set_ReferenceVolume_metadata, referenceVolume)

    _get_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list for the over time volume."""
        return self._intf.get_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._get_ReferenceIntervals_metadata)

    _set_ReferenceIntervals_metadata = { "name" : "ReferenceIntervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEventIntervalList"),) }
    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        return self._intf.set_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._set_ReferenceIntervals_metadata, referenceIntervals)

    _get_StartOffset_metadata = { "name" : "StartOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when over time volume is set to Sliding Window."""
        return self._intf.get_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._get_StartOffset_metadata)

    _set_StartOffset_metadata = { "name" : "StartOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        return self._intf.set_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._set_StartOffset_metadata, startOffset)

    _get_StopOffset_metadata = { "name" : "StopOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when over time volume is set to Sliding Window."""
        return self._intf.get_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._get_StopOffset_metadata)

    _set_StopOffset_metadata = { "name" : "StopOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        return self._intf.set_property(IAgCrdnVolumeOverTime._metadata, IAgCrdnVolumeOverTime._set_StopOffset_metadata, stopOffset)


agcls.AgClassCatalog.add_catalog_entry("{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}", IAgCrdnVolumeOverTime)
agcls.AgTypeNameMap["IAgCrdnVolumeOverTime"] = IAgCrdnVolumeOverTime

class IAgCrdnTimeProperties(object):
    """Defines methods to compute time properties such as availability and special times."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E95B72AA-F8DE-4122-AC60-54E46A208E19}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "GetAvailability" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnTimeProperties._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnTimeProperties from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnTimeProperties.__dict__ and type(IAgCrdnTimeProperties.__dict__[attrname]) == property:
            return IAgCrdnTimeProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnTimeProperties.")
    
    _GetAvailability_metadata = { "name" : "GetAvailability",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetAvailability(self) -> "IAgCrdnIntervalCollection":
        """Returns a collection of availability intervals."""
        return self._intf.invoke(IAgCrdnTimeProperties._metadata, IAgCrdnTimeProperties._GetAvailability_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{E95B72AA-F8DE-4122-AC60-54E46A208E19}", IAgCrdnTimeProperties)
agcls.AgTypeNameMap["IAgCrdnTimeProperties"] = IAgCrdnTimeProperties

class IAgCrdnTypeInfo(object):
    """Provides information about the type of VGT components."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{67E20A46-9550-4A68-9276-697DC821A23A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TypeDescription" : 1,
                             "get_TypeName" : 2,
                             "get_ShortTypeDescription" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnTypeInfo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnTypeInfo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnTypeInfo.__dict__ and type(IAgCrdnTypeInfo.__dict__[attrname]) == property:
            return IAgCrdnTypeInfo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnTypeInfo.")
    
    _get_TypeDescription_metadata = { "name" : "TypeDescription",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def TypeDescription(self) -> str:
        """Return the type description."""
        return self._intf.get_property(IAgCrdnTypeInfo._metadata, IAgCrdnTypeInfo._get_TypeDescription_metadata)

    _get_TypeName_metadata = { "name" : "TypeName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def TypeName(self) -> str:
        """Return the type name."""
        return self._intf.get_property(IAgCrdnTypeInfo._metadata, IAgCrdnTypeInfo._get_TypeName_metadata)

    _get_ShortTypeDescription_metadata = { "name" : "ShortTypeDescription",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ShortTypeDescription(self) -> str:
        """Return the short type description."""
        return self._intf.get_property(IAgCrdnTypeInfo._metadata, IAgCrdnTypeInfo._get_ShortTypeDescription_metadata)


agcls.AgClassCatalog.add_catalog_entry("{67E20A46-9550-4A68-9276-697DC821A23A}", IAgCrdnTypeInfo)
agcls.AgTypeNameMap["IAgCrdnTypeInfo"] = IAgCrdnTypeInfo

class IAgCrdnRefTo(object):
    """A base interface for all VGT component references."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2F3A17A6-4304-4565-BC1C-7A064DCFE310}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Path" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnRefTo.__dict__ and type(IAgCrdnRefTo.__dict__[attrname]) == property:
            return IAgCrdnRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnRefTo.")
    
    _get_Path_metadata = { "name" : "Path",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Path(self) -> str:
        """Returns a path to the referenced VGT component."""
        return self._intf.get_property(IAgCrdnRefTo._metadata, IAgCrdnRefTo._get_Path_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2F3A17A6-4304-4565-BC1C-7A064DCFE310}", IAgCrdnRefTo)
agcls.AgTypeNameMap["IAgCrdnRefTo"] = IAgCrdnRefTo

class IAgCrdnTemplate(object):
    """The IAgCrdnTemplate interface enables to obtain information about the STK class that owns the VGT component."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ClassName" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnTemplate._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnTemplate from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnTemplate.__dict__ and type(IAgCrdnTemplate.__dict__[attrname]) == property:
            return IAgCrdnTemplate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnTemplate.")
    
    _get_ClassName_metadata = { "name" : "ClassName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ClassName(self) -> str:
        """Returns a class name (i.e. 'Satellite', 'Facility', etc.)."""
        return self._intf.get_property(IAgCrdnTemplate._metadata, IAgCrdnTemplate._get_ClassName_metadata)


agcls.AgClassCatalog.add_catalog_entry("{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}", IAgCrdnTemplate)
agcls.AgTypeNameMap["IAgCrdnTemplate"] = IAgCrdnTemplate

class IAgCrdnInstance(object):
    """The IAgCrdnInstance interface enables to obtain information about the parent object that owns the VGT component."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{17633665-9601-4FFF-8227-4D5DF0AAEA06}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_InstancePath" : 1,
                             "get_Template" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnInstance._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnInstance from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInstance.__dict__ and type(IAgCrdnInstance.__dict__[attrname]) == property:
            return IAgCrdnInstance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnInstance.")
    
    _get_InstancePath_metadata = { "name" : "InstancePath",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def InstancePath(self) -> str:
        """Returns a path to the parent object that owns the VGT component."""
        return self._intf.get_property(IAgCrdnInstance._metadata, IAgCrdnInstance._get_InstancePath_metadata)

    _get_Template_metadata = { "name" : "Template",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Template(self) -> "IAgCrdn":
        """Returns a template object the VGT component was created from or null if the VGT component was not created from a template."""
        return self._intf.get_property(IAgCrdnInstance._metadata, IAgCrdnInstance._get_Template_metadata)


agcls.AgClassCatalog.add_catalog_entry("{17633665-9601-4FFF-8227-4D5DF0AAEA06}", IAgCrdnInstance)
agcls.AgTypeNameMap["IAgCrdnInstance"] = IAgCrdnInstance

class IAgCrdnPointRefTo(object):
    """Represents a reference to a VGT point."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B553DE32-05C9-4944-918A-90552E039DBE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "SetPath" : 1,
                             "SetPoint" : 2,
                             "GetPoint" : 3,
                             "HasCyclicDependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointRefTo.__dict__ and type(IAgCrdnPointRefTo.__dict__[attrname]) == property:
            return IAgCrdnPointRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointRefTo.")
    
    _SetPath_metadata = { "name" : "SetPath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetPath(self, path:str) -> None:
        """Sets a new point."""
        return self._intf.invoke(IAgCrdnPointRefTo._metadata, IAgCrdnPointRefTo._SetPath_metadata, path)

    _SetPoint_metadata = { "name" : "SetPoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    def SetPoint(self, point:"IAgCrdnPoint") -> None:
        """Sets a new point."""
        return self._intf.invoke(IAgCrdnPointRefTo._metadata, IAgCrdnPointRefTo._SetPoint_metadata, point)

    _GetPoint_metadata = { "name" : "GetPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetPoint(self) -> "IAgCrdnPoint":
        """Returns the actual point object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IAgCrdnPointRefTo._metadata, IAgCrdnPointRefTo._GetPoint_metadata, out_arg())

    _HasCyclicDependency_metadata = { "name" : "HasCyclicDependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"), agmarshall.VARIANT_BOOL_arg,) }
    def HasCyclicDependency(self, point:"IAgCrdnPoint") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IAgCrdnPointRefTo._metadata, IAgCrdnPointRefTo._HasCyclicDependency_metadata, point, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{B553DE32-05C9-4944-918A-90552E039DBE}", IAgCrdnPointRefTo)
agcls.AgTypeNameMap["IAgCrdnPointRefTo"] = IAgCrdnPointRefTo

class IAgCrdnVectorRefTo(object):
    """Represents a reference to a VGT vector."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EDF2E070-340E-456C-BDA8-BE9B9B40E728}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "SetPath" : 1,
                             "SetVector" : 2,
                             "GetVector" : 3,
                             "HasCyclicDependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorRefTo.__dict__ and type(IAgCrdnVectorRefTo.__dict__[attrname]) == property:
            return IAgCrdnVectorRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorRefTo.")
    
    _SetPath_metadata = { "name" : "SetPath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetPath(self, path:str) -> None:
        """Sets a new vector."""
        return self._intf.invoke(IAgCrdnVectorRefTo._metadata, IAgCrdnVectorRefTo._SetPath_metadata, path)

    _SetVector_metadata = { "name" : "SetVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    def SetVector(self, vector:"IAgCrdnVector") -> None:
        """Sets a new vector."""
        return self._intf.invoke(IAgCrdnVectorRefTo._metadata, IAgCrdnVectorRefTo._SetVector_metadata, vector)

    _GetVector_metadata = { "name" : "GetVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetVector(self) -> "IAgCrdnVector":
        """Returns the actual vector object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IAgCrdnVectorRefTo._metadata, IAgCrdnVectorRefTo._GetVector_metadata, out_arg())

    _HasCyclicDependency_metadata = { "name" : "HasCyclicDependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"), agmarshall.VARIANT_BOOL_arg,) }
    def HasCyclicDependency(self, vector:"IAgCrdnVector") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IAgCrdnVectorRefTo._metadata, IAgCrdnVectorRefTo._HasCyclicDependency_metadata, vector, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{EDF2E070-340E-456C-BDA8-BE9B9B40E728}", IAgCrdnVectorRefTo)
agcls.AgTypeNameMap["IAgCrdnVectorRefTo"] = IAgCrdnVectorRefTo

class IAgCrdnAxesRefTo(object):
    """Represents a reference to a VGT axes."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "SetPath" : 1,
                             "SetAxes" : 2,
                             "GetAxes" : 3,
                             "HasCyclicDependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesRefTo.__dict__ and type(IAgCrdnAxesRefTo.__dict__[attrname]) == property:
            return IAgCrdnAxesRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesRefTo.")
    
    _SetPath_metadata = { "name" : "SetPath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetPath(self, path:str) -> None:
        """Sets a new axes."""
        return self._intf.invoke(IAgCrdnAxesRefTo._metadata, IAgCrdnAxesRefTo._SetPath_metadata, path)

    _SetAxes_metadata = { "name" : "SetAxes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    def SetAxes(self, axes:"IAgCrdnAxes") -> None:
        """Sets a new axes."""
        return self._intf.invoke(IAgCrdnAxesRefTo._metadata, IAgCrdnAxesRefTo._SetAxes_metadata, axes)

    _GetAxes_metadata = { "name" : "GetAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetAxes(self) -> "IAgCrdnAxes":
        """Returns the actual axes object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IAgCrdnAxesRefTo._metadata, IAgCrdnAxesRefTo._GetAxes_metadata, out_arg())

    _HasCyclicDependency_metadata = { "name" : "HasCyclicDependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.VARIANT_BOOL_arg,) }
    def HasCyclicDependency(self, axes:"IAgCrdnAxes") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IAgCrdnAxesRefTo._metadata, IAgCrdnAxesRefTo._HasCyclicDependency_metadata, axes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}", IAgCrdnAxesRefTo)
agcls.AgTypeNameMap["IAgCrdnAxesRefTo"] = IAgCrdnAxesRefTo

class IAgCrdnAngleRefTo(object):
    """Represents a reference to a VGT angle."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7A9D809F-D819-4458-9855-2DA8507F6E57}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "SetPath" : 1,
                             "SetAngle" : 2,
                             "GetAngle" : 3,
                             "HasCyclicDependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleRefTo.__dict__ and type(IAgCrdnAngleRefTo.__dict__[attrname]) == property:
            return IAgCrdnAngleRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleRefTo.")
    
    _SetPath_metadata = { "name" : "SetPath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetPath(self, path:str) -> None:
        """Sets a new angle."""
        return self._intf.invoke(IAgCrdnAngleRefTo._metadata, IAgCrdnAngleRefTo._SetPath_metadata, path)

    _SetAngle_metadata = { "name" : "SetAngle",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAngle"),) }
    def SetAngle(self, angle:"IAgCrdnAngle") -> None:
        """Sets a new angle."""
        return self._intf.invoke(IAgCrdnAngleRefTo._metadata, IAgCrdnAngleRefTo._SetAngle_metadata, angle)

    _GetAngle_metadata = { "name" : "GetAngle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetAngle(self) -> "IAgCrdnAngle":
        """Returns the actual angle object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IAgCrdnAngleRefTo._metadata, IAgCrdnAngleRefTo._GetAngle_metadata, out_arg())

    _HasCyclicDependency_metadata = { "name" : "HasCyclicDependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAngle"), agmarshall.VARIANT_BOOL_arg,) }
    def HasCyclicDependency(self, angle:"IAgCrdnAngle") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IAgCrdnAngleRefTo._metadata, IAgCrdnAngleRefTo._HasCyclicDependency_metadata, angle, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7A9D809F-D819-4458-9855-2DA8507F6E57}", IAgCrdnAngleRefTo)
agcls.AgTypeNameMap["IAgCrdnAngleRefTo"] = IAgCrdnAngleRefTo

class IAgCrdnSystemRefTo(object):
    """Represents a reference to a VGT system."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "SetPath" : 1,
                             "SetSystem" : 2,
                             "GetSystem" : 3,
                             "HasCyclicDependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemRefTo.__dict__ and type(IAgCrdnSystemRefTo.__dict__[attrname]) == property:
            return IAgCrdnSystemRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemRefTo.")
    
    _SetPath_metadata = { "name" : "SetPath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetPath(self, path:str) -> None:
        """Sets a new system."""
        return self._intf.invoke(IAgCrdnSystemRefTo._metadata, IAgCrdnSystemRefTo._SetPath_metadata, path)

    _SetSystem_metadata = { "name" : "SetSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    def SetSystem(self, system:"IAgCrdnSystem") -> None:
        """Sets a new system."""
        return self._intf.invoke(IAgCrdnSystemRefTo._metadata, IAgCrdnSystemRefTo._SetSystem_metadata, system)

    _GetSystem_metadata = { "name" : "GetSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetSystem(self) -> "IAgCrdnSystem":
        """Returns the actual system object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IAgCrdnSystemRefTo._metadata, IAgCrdnSystemRefTo._GetSystem_metadata, out_arg())

    _HasCyclicDependency_metadata = { "name" : "HasCyclicDependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.VARIANT_BOOL_arg,) }
    def HasCyclicDependency(self, system:"IAgCrdnSystem") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IAgCrdnSystemRefTo._metadata, IAgCrdnSystemRefTo._HasCyclicDependency_metadata, system, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}", IAgCrdnSystemRefTo)
agcls.AgTypeNameMap["IAgCrdnSystemRefTo"] = IAgCrdnSystemRefTo

class IAgCrdnPlaneRefTo(object):
    """Represents a reference to a VGT plane."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CE3D70F2-61E0-4A23-803F-A734005DC36D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "SetPath" : 1,
                             "SetPlane" : 2,
                             "GetPlane" : 3,
                             "HasCyclicDependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneRefTo.__dict__ and type(IAgCrdnPlaneRefTo.__dict__[attrname]) == property:
            return IAgCrdnPlaneRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneRefTo.")
    
    _SetPath_metadata = { "name" : "SetPath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetPath(self, path:str) -> None:
        """Sets a new plane using a specified path."""
        return self._intf.invoke(IAgCrdnPlaneRefTo._metadata, IAgCrdnPlaneRefTo._SetPath_metadata, path)

    _SetPlane_metadata = { "name" : "SetPlane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPlane"),) }
    def SetPlane(self, plane:"IAgCrdnPlane") -> None:
        """Sets a new plane."""
        return self._intf.invoke(IAgCrdnPlaneRefTo._metadata, IAgCrdnPlaneRefTo._SetPlane_metadata, plane)

    _GetPlane_metadata = { "name" : "GetPlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetPlane(self) -> "IAgCrdnPlane":
        """Returns the actual plane object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IAgCrdnPlaneRefTo._metadata, IAgCrdnPlaneRefTo._GetPlane_metadata, out_arg())

    _HasCyclicDependency_metadata = { "name" : "HasCyclicDependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPlane"), agmarshall.VARIANT_BOOL_arg,) }
    def HasCyclicDependency(self, plane:"IAgCrdnPlane") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IAgCrdnPlaneRefTo._metadata, IAgCrdnPlaneRefTo._HasCyclicDependency_metadata, plane, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{CE3D70F2-61E0-4A23-803F-A734005DC36D}", IAgCrdnPlaneRefTo)
agcls.AgTypeNameMap["IAgCrdnPlaneRefTo"] = IAgCrdnPlaneRefTo

class IAgCrdnAxesLabels(object):
    """Allows configuring the VGT axes labels."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0CD79528-D932-4473-9CC4-0BF5C936A6CD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_LabelX" : 1,
                             "set_LabelX" : 2,
                             "get_LabelY" : 3,
                             "set_LabelY" : 4,
                             "get_LabelZ" : 5,
                             "set_LabelZ" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesLabels._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesLabels from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesLabels.__dict__ and type(IAgCrdnAxesLabels.__dict__[attrname]) == property:
            return IAgCrdnAxesLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesLabels.")
    
    _get_LabelX_metadata = { "name" : "LabelX",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def LabelX(self) -> str:
        """Specify an X axis label."""
        return self._intf.get_property(IAgCrdnAxesLabels._metadata, IAgCrdnAxesLabels._get_LabelX_metadata)

    _set_LabelX_metadata = { "name" : "LabelX",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @LabelX.setter
    def LabelX(self, labelX:str) -> None:
        return self._intf.set_property(IAgCrdnAxesLabels._metadata, IAgCrdnAxesLabels._set_LabelX_metadata, labelX)

    _get_LabelY_metadata = { "name" : "LabelY",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def LabelY(self) -> str:
        """Specify a Y axis label."""
        return self._intf.get_property(IAgCrdnAxesLabels._metadata, IAgCrdnAxesLabels._get_LabelY_metadata)

    _set_LabelY_metadata = { "name" : "LabelY",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @LabelY.setter
    def LabelY(self, labelY:str) -> None:
        return self._intf.set_property(IAgCrdnAxesLabels._metadata, IAgCrdnAxesLabels._set_LabelY_metadata, labelY)

    _get_LabelZ_metadata = { "name" : "LabelZ",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def LabelZ(self) -> str:
        """Specify a Z axis label."""
        return self._intf.get_property(IAgCrdnAxesLabels._metadata, IAgCrdnAxesLabels._get_LabelZ_metadata)

    _set_LabelZ_metadata = { "name" : "LabelZ",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @LabelZ.setter
    def LabelZ(self, labelZ:str) -> None:
        return self._intf.set_property(IAgCrdnAxesLabels._metadata, IAgCrdnAxesLabels._set_LabelZ_metadata, labelZ)


agcls.AgClassCatalog.add_catalog_entry("{0CD79528-D932-4473-9CC4-0BF5C936A6CD}", IAgCrdnAxesLabels)
agcls.AgTypeNameMap["IAgCrdnAxesLabels"] = IAgCrdnAxesLabels

class IAgCrdnPlaneLabels(object):
    """Allows configuring the X and Y axes labels."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_XAxisLabel" : 1,
                             "set_XAxisLabel" : 2,
                             "get_YAxisLabel" : 3,
                             "set_YAxisLabel" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneLabels._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneLabels from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneLabels.__dict__ and type(IAgCrdnPlaneLabels.__dict__[attrname]) == property:
            return IAgCrdnPlaneLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneLabels.")
    
    _get_XAxisLabel_metadata = { "name" : "XAxisLabel",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def XAxisLabel(self) -> str:
        """Specify an X axis label."""
        return self._intf.get_property(IAgCrdnPlaneLabels._metadata, IAgCrdnPlaneLabels._get_XAxisLabel_metadata)

    _set_XAxisLabel_metadata = { "name" : "XAxisLabel",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @XAxisLabel.setter
    def XAxisLabel(self, xAxisLabel:str) -> None:
        return self._intf.set_property(IAgCrdnPlaneLabels._metadata, IAgCrdnPlaneLabels._set_XAxisLabel_metadata, xAxisLabel)

    _get_YAxisLabel_metadata = { "name" : "YAxisLabel",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def YAxisLabel(self) -> str:
        """Specify a Y axis label."""
        return self._intf.get_property(IAgCrdnPlaneLabels._metadata, IAgCrdnPlaneLabels._get_YAxisLabel_metadata)

    _set_YAxisLabel_metadata = { "name" : "YAxisLabel",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @YAxisLabel.setter
    def YAxisLabel(self, yAxisLabel:str) -> None:
        return self._intf.set_property(IAgCrdnPlaneLabels._metadata, IAgCrdnPlaneLabels._set_YAxisLabel_metadata, yAxisLabel)


agcls.AgClassCatalog.add_catalog_entry("{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}", IAgCrdnPlaneLabels)
agcls.AgTypeNameMap["IAgCrdnPlaneLabels"] = IAgCrdnPlaneLabels

class IAgCrdnAxesAlignedAndConstrained(object):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{19991E4F-F368-41CD-AE27-96CF11EC963F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_AlignmentReferenceVector" : 1,
                             "get_ConstraintReferenceVector" : 2,
                             "get_AlignmentDirection" : 3,
                             "get_ConstraintDirection" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesAlignedAndConstrained._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesAlignedAndConstrained from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAlignedAndConstrained.__dict__ and type(IAgCrdnAxesAlignedAndConstrained.__dict__[attrname]) == property:
            return IAgCrdnAxesAlignedAndConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesAlignedAndConstrained.")
    
    _get_AlignmentReferenceVector_metadata = { "name" : "AlignmentReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AlignmentReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify an alignment reference vector."""
        return self._intf.get_property(IAgCrdnAxesAlignedAndConstrained._metadata, IAgCrdnAxesAlignedAndConstrained._get_AlignmentReferenceVector_metadata)

    _get_ConstraintReferenceVector_metadata = { "name" : "ConstraintReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ConstraintReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a constraint reference vector."""
        return self._intf.get_property(IAgCrdnAxesAlignedAndConstrained._metadata, IAgCrdnAxesAlignedAndConstrained._get_ConstraintReferenceVector_metadata)

    _get_AlignmentDirection_metadata = { "name" : "AlignmentDirection",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AlignmentDirection(self) -> "IAgDirection":
        """Specify a desired alignment direction and the applicable parameters."""
        return self._intf.get_property(IAgCrdnAxesAlignedAndConstrained._metadata, IAgCrdnAxesAlignedAndConstrained._get_AlignmentDirection_metadata)

    _get_ConstraintDirection_metadata = { "name" : "ConstraintDirection",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ConstraintDirection(self) -> "IAgDirection":
        """Specify a desired constraint direction and the applicable parameters."""
        return self._intf.get_property(IAgCrdnAxesAlignedAndConstrained._metadata, IAgCrdnAxesAlignedAndConstrained._get_ConstraintDirection_metadata)


agcls.AgClassCatalog.add_catalog_entry("{19991E4F-F368-41CD-AE27-96CF11EC963F}", IAgCrdnAxesAlignedAndConstrained)
agcls.AgTypeNameMap["IAgCrdnAxesAlignedAndConstrained"] = IAgCrdnAxesAlignedAndConstrained

class IAgCrdnAxesAngularOffset(object):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0096F935-281A-4EC9-92A4-7400BD2DEF60}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SpinVector" : 1,
                             "get_RotationAngle" : 2,
                             "get_ReferenceAxes" : 3,
                             "get_FixedOffsetAngle" : 4,
                             "set_FixedOffsetAngle" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesAngularOffset._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesAngularOffset from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAngularOffset.__dict__ and type(IAgCrdnAxesAngularOffset.__dict__[attrname]) == property:
            return IAgCrdnAxesAngularOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesAngularOffset.")
    
    _get_SpinVector_metadata = { "name" : "SpinVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SpinVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a spin vector."""
        return self._intf.get_property(IAgCrdnAxesAngularOffset._metadata, IAgCrdnAxesAngularOffset._get_SpinVector_metadata)

    _get_RotationAngle_metadata = { "name" : "RotationAngle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def RotationAngle(self) -> "IAgCrdnAngleRefTo":
        """Specify a rotational angle."""
        return self._intf.get_property(IAgCrdnAxesAngularOffset._metadata, IAgCrdnAxesAngularOffset._get_RotationAngle_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnAxesAngularOffset._metadata, IAgCrdnAxesAngularOffset._get_ReferenceAxes_metadata)

    _get_FixedOffsetAngle_metadata = { "name" : "FixedOffsetAngle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def FixedOffsetAngle(self) -> float:
        """Specify an additional rotational offset."""
        return self._intf.get_property(IAgCrdnAxesAngularOffset._metadata, IAgCrdnAxesAngularOffset._get_FixedOffsetAngle_metadata)

    _set_FixedOffsetAngle_metadata = { "name" : "FixedOffsetAngle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @FixedOffsetAngle.setter
    def FixedOffsetAngle(self, fixedOffsetAngle:float) -> None:
        return self._intf.set_property(IAgCrdnAxesAngularOffset._metadata, IAgCrdnAxesAngularOffset._set_FixedOffsetAngle_metadata, fixedOffsetAngle)


agcls.AgClassCatalog.add_catalog_entry("{0096F935-281A-4EC9-92A4-7400BD2DEF60}", IAgCrdnAxesAngularOffset)
agcls.AgTypeNameMap["IAgCrdnAxesAngularOffset"] = IAgCrdnAxesAngularOffset

class IAgCrdnAxesFixedAtEpoch(object):
    """Axes based on another set fixed at a specified epoch."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CEB9E066-A9F8-4B74-AF7A-0301BF611843}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SourceAxes" : 1,
                             "get_ReferenceAxes" : 2,
                             "get_Epoch" : 3,
                             "set_Epoch" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesFixedAtEpoch._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesFixedAtEpoch from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFixedAtEpoch.__dict__ and type(IAgCrdnAxesFixedAtEpoch.__dict__[attrname]) == property:
            return IAgCrdnAxesFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesFixedAtEpoch.")
    
    _get_SourceAxes_metadata = { "name" : "SourceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a source axes."""
        return self._intf.get_property(IAgCrdnAxesFixedAtEpoch._metadata, IAgCrdnAxesFixedAtEpoch._get_SourceAxes_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnAxesFixedAtEpoch._metadata, IAgCrdnAxesFixedAtEpoch._get_ReferenceAxes_metadata)

    _get_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        return self._intf.get_property(IAgCrdnAxesFixedAtEpoch._metadata, IAgCrdnAxesFixedAtEpoch._get_Epoch_metadata)

    _set_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IAgCrdnAxesFixedAtEpoch._metadata, IAgCrdnAxesFixedAtEpoch._set_Epoch_metadata, epoch)


agcls.AgClassCatalog.add_catalog_entry("{CEB9E066-A9F8-4B74-AF7A-0301BF611843}", IAgCrdnAxesFixedAtEpoch)
agcls.AgTypeNameMap["IAgCrdnAxesFixedAtEpoch"] = IAgCrdnAxesFixedAtEpoch

class IAgCrdnAxesBPlane(object):
    """B-Plane axes using the selected target body and reference vector."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{72FD97D1-AE64-45D2-973E-E4F491B474AC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Trajectory" : 1,
                             "get_ReferenceVector" : 2,
                             "get_TargetBody" : 3,
                             "get_Direction" : 4,
                             "set_Direction" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesBPlane._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesBPlane from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesBPlane.__dict__ and type(IAgCrdnAxesBPlane.__dict__[attrname]) == property:
            return IAgCrdnAxesBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesBPlane.")
    
    _get_Trajectory_metadata = { "name" : "Trajectory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Trajectory(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IAgCrdnAxesBPlane._metadata, IAgCrdnAxesBPlane._get_Trajectory_metadata)

    _get_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IAgCrdnAxesBPlane._metadata, IAgCrdnAxesBPlane._get_ReferenceVector_metadata)

    _get_TargetBody_metadata = { "name" : "TargetBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TargetBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a target central body."""
        return self._intf.get_property(IAgCrdnAxesBPlane._metadata, IAgCrdnAxesBPlane._get_TargetBody_metadata)

    _get_Direction_metadata = { "name" : "Direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDirectionType),) }
    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        return self._intf.get_property(IAgCrdnAxesBPlane._metadata, IAgCrdnAxesBPlane._get_Direction_metadata)

    _set_Direction_metadata = { "name" : "Direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDirectionType),) }
    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        return self._intf.set_property(IAgCrdnAxesBPlane._metadata, IAgCrdnAxesBPlane._set_Direction_metadata, direction)


agcls.AgClassCatalog.add_catalog_entry("{72FD97D1-AE64-45D2-973E-E4F491B474AC}", IAgCrdnAxesBPlane)
agcls.AgTypeNameMap["IAgCrdnAxesBPlane"] = IAgCrdnAxesBPlane

class IAgCrdnAxesCustomScript(object):
    """Customized axes offset with respect to a set of reference Axes."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F5A690E6-0304-49E0-BAB5-229F848B0401}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceAxes" : 1,
                             "get_Filename" : 2,
                             "set_Filename" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesCustomScript._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesCustomScript from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesCustomScript.__dict__ and type(IAgCrdnAxesCustomScript.__dict__[attrname]) == property:
            return IAgCrdnAxesCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesCustomScript.")
    
    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnAxesCustomScript._metadata, IAgCrdnAxesCustomScript._get_ReferenceAxes_metadata)

    _get_Filename_metadata = { "name" : "Filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Filename(self) -> str:
        """Can be MATLAB (.m or .dll) or VB Script (.vbs) script file."""
        return self._intf.get_property(IAgCrdnAxesCustomScript._metadata, IAgCrdnAxesCustomScript._get_Filename_metadata)

    _set_Filename_metadata = { "name" : "Filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Filename.setter
    def Filename(self, filename:str) -> None:
        return self._intf.set_property(IAgCrdnAxesCustomScript._metadata, IAgCrdnAxesCustomScript._set_Filename_metadata, filename)


agcls.AgClassCatalog.add_catalog_entry("{F5A690E6-0304-49E0-BAB5-229F848B0401}", IAgCrdnAxesCustomScript)
agcls.AgTypeNameMap["IAgCrdnAxesCustomScript"] = IAgCrdnAxesCustomScript

class IAgCrdnAxesAttitudeFile(object):
    """Axes specified by data from a file."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E4A194BD-44ED-498F-ACB2-9911C19F52E8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Filename" : 1,
                             "set_Filename" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesAttitudeFile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesAttitudeFile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAttitudeFile.__dict__ and type(IAgCrdnAxesAttitudeFile.__dict__[attrname]) == property:
            return IAgCrdnAxesAttitudeFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesAttitudeFile.")
    
    _get_Filename_metadata = { "name" : "Filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        return self._intf.get_property(IAgCrdnAxesAttitudeFile._metadata, IAgCrdnAxesAttitudeFile._get_Filename_metadata)

    _set_Filename_metadata = { "name" : "Filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Filename.setter
    def Filename(self, filename:str) -> None:
        return self._intf.set_property(IAgCrdnAxesAttitudeFile._metadata, IAgCrdnAxesAttitudeFile._set_Filename_metadata, filename)


agcls.AgClassCatalog.add_catalog_entry("{E4A194BD-44ED-498F-ACB2-9911C19F52E8}", IAgCrdnAxesAttitudeFile)
agcls.AgTypeNameMap["IAgCrdnAxesAttitudeFile"] = IAgCrdnAxesAttitudeFile

class IAgCrdnAxesFixed(object):
    """Axes fixed in reference axes."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceAxes" : 1,
                             "get_FixedOrientation" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesFixed._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesFixed from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFixed.__dict__ and type(IAgCrdnAxesFixed.__dict__[attrname]) == property:
            return IAgCrdnAxesFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesFixed.")
    
    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnAxesFixed._metadata, IAgCrdnAxesFixed._get_ReferenceAxes_metadata)

    _get_FixedOrientation_metadata = { "name" : "FixedOrientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FixedOrientation(self) -> "IAgOrientation":
        """Specify a desired orientation and the applicable parameters."""
        return self._intf.get_property(IAgCrdnAxesFixed._metadata, IAgCrdnAxesFixed._get_FixedOrientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}", IAgCrdnAxesFixed)
agcls.AgTypeNameMap["IAgCrdnAxesFixed"] = IAgCrdnAxesFixed

class IAgCrdnAxesModelAttach(object):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3A20DEC4-2D89-416C-8B47-D76E859763B0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_PointableElementName" : 1,
                             "set_PointableElementName" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesModelAttach._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesModelAttach from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesModelAttach.__dict__ and type(IAgCrdnAxesModelAttach.__dict__[attrname]) == property:
            return IAgCrdnAxesModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesModelAttach.")
    
    _get_PointableElementName_metadata = { "name" : "PointableElementName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        return self._intf.get_property(IAgCrdnAxesModelAttach._metadata, IAgCrdnAxesModelAttach._get_PointableElementName_metadata)

    _set_PointableElementName_metadata = { "name" : "PointableElementName",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        return self._intf.set_property(IAgCrdnAxesModelAttach._metadata, IAgCrdnAxesModelAttach._set_PointableElementName_metadata, pointableElementName)


agcls.AgClassCatalog.add_catalog_entry("{3A20DEC4-2D89-416C-8B47-D76E859763B0}", IAgCrdnAxesModelAttach)
agcls.AgTypeNameMap["IAgCrdnAxesModelAttach"] = IAgCrdnAxesModelAttach

class IAgCrdnAxesSpinning(object):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ECB36015-B534-40C6-B50F-298217335C38}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SpinVector" : 1,
                             "get_ReferenceAxes" : 2,
                             "get_Epoch" : 3,
                             "set_Epoch" : 4,
                             "get_InitialOffset" : 5,
                             "set_InitialOffset" : 6,
                             "get_SpinRate" : 7,
                             "set_SpinRate" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesSpinning._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesSpinning from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSpinning.__dict__ and type(IAgCrdnAxesSpinning.__dict__[attrname]) == property:
            return IAgCrdnAxesSpinning.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesSpinning.")
    
    _get_SpinVector_metadata = { "name" : "SpinVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SpinVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a spin vector."""
        return self._intf.get_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._get_SpinVector_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._get_ReferenceAxes_metadata)

    _get_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch at which the axes are aligned with the reference axes."""
        return self._intf.get_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._get_Epoch_metadata)

    _set_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._set_Epoch_metadata, epoch)

    _get_InitialOffset_metadata = { "name" : "InitialOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def InitialOffset(self) -> float:
        """Specify an additional rotational offset."""
        return self._intf.get_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._get_InitialOffset_metadata)

    _set_InitialOffset_metadata = { "name" : "InitialOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @InitialOffset.setter
    def InitialOffset(self, initialOffset:float) -> None:
        return self._intf.set_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._set_InitialOffset_metadata, initialOffset)

    _get_SpinRate_metadata = { "name" : "SpinRate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def SpinRate(self) -> float:
        """Specify a spin rate the axes spins about the spin vector."""
        return self._intf.get_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._get_SpinRate_metadata)

    _set_SpinRate_metadata = { "name" : "SpinRate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @SpinRate.setter
    def SpinRate(self, spinRate:float) -> None:
        return self._intf.set_property(IAgCrdnAxesSpinning._metadata, IAgCrdnAxesSpinning._set_SpinRate_metadata, spinRate)


agcls.AgClassCatalog.add_catalog_entry("{ECB36015-B534-40C6-B50F-298217335C38}", IAgCrdnAxesSpinning)
agcls.AgTypeNameMap["IAgCrdnAxesSpinning"] = IAgCrdnAxesSpinning

class IAgCrdnAxesOnSurface(object):
    """Topocentric axes located at the reference point's projection on the central body."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2,
                             "get_UseMSL" : 3,
                             "set_UseMSL" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesOnSurface._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesOnSurface from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesOnSurface.__dict__ and type(IAgCrdnAxesOnSurface.__dict__[attrname]) == property:
            return IAgCrdnAxesOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesOnSurface.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnAxesOnSurface._metadata, IAgCrdnAxesOnSurface._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IAgCrdnAxesOnSurface._metadata, IAgCrdnAxesOnSurface._get_ReferencePoint_metadata)

    _get_UseMSL_metadata = { "name" : "UseMSL",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseMSL(self) -> bool:
        """Specify whether the reference shape is at the Mean Sea Level."""
        return self._intf.get_property(IAgCrdnAxesOnSurface._metadata, IAgCrdnAxesOnSurface._get_UseMSL_metadata)

    _set_UseMSL_metadata = { "name" : "UseMSL",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        return self._intf.set_property(IAgCrdnAxesOnSurface._metadata, IAgCrdnAxesOnSurface._set_UseMSL_metadata, useMSL)


agcls.AgClassCatalog.add_catalog_entry("{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}", IAgCrdnAxesOnSurface)
agcls.AgTypeNameMap["IAgCrdnAxesOnSurface"] = IAgCrdnAxesOnSurface

class IAgCrdnAxesTrajectory(object):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TrajectoryPoint" : 1,
                             "get_ReferenceSystem" : 2,
                             "get_TrajectoryAxesType" : 3,
                             "set_TrajectoryAxesType" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesTrajectory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesTrajectory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesTrajectory.__dict__ and type(IAgCrdnAxesTrajectory.__dict__[attrname]) == property:
            return IAgCrdnAxesTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesTrajectory.")
    
    _get_TrajectoryPoint_metadata = { "name" : "TrajectoryPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TrajectoryPoint(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IAgCrdnAxesTrajectory._metadata, IAgCrdnAxesTrajectory._get_TrajectoryPoint_metadata)

    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IAgCrdnAxesTrajectory._metadata, IAgCrdnAxesTrajectory._get_ReferenceSystem_metadata)

    _get_TrajectoryAxesType_metadata = { "name" : "TrajectoryAxesType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType),) }
    @property
    def TrajectoryAxesType(self) -> "AgECrdnTrajectoryAxesType":
        """Specify a type of the trajectory's coordinate frame."""
        return self._intf.get_property(IAgCrdnAxesTrajectory._metadata, IAgCrdnAxesTrajectory._get_TrajectoryAxesType_metadata)

    _set_TrajectoryAxesType_metadata = { "name" : "TrajectoryAxesType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType),) }
    @TrajectoryAxesType.setter
    def TrajectoryAxesType(self, trajectoryAxesType:"AgECrdnTrajectoryAxesType") -> None:
        return self._intf.set_property(IAgCrdnAxesTrajectory._metadata, IAgCrdnAxesTrajectory._set_TrajectoryAxesType_metadata, trajectoryAxesType)


agcls.AgClassCatalog.add_catalog_entry("{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}", IAgCrdnAxesTrajectory)
agcls.AgTypeNameMap["IAgCrdnAxesTrajectory"] = IAgCrdnAxesTrajectory

class IAgCrdnAxesLagrangeLibration(object):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_PrimaryCentralBody" : 1,
                             "get_PointType" : 2,
                             "set_PointType" : 3,
                             "get_SecondaryCentralBodies" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesLagrangeLibration._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesLagrangeLibration from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesLagrangeLibration.__dict__ and type(IAgCrdnAxesLagrangeLibration.__dict__[attrname]) == property:
            return IAgCrdnAxesLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesLagrangeLibration.")
    
    _get_PrimaryCentralBody_metadata = { "name" : "PrimaryCentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def PrimaryCentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a primary central body."""
        return self._intf.get_property(IAgCrdnAxesLagrangeLibration._metadata, IAgCrdnAxesLagrangeLibration._get_PrimaryCentralBody_metadata)

    _get_PointType_metadata = { "name" : "PointType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType),) }
    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        return self._intf.get_property(IAgCrdnAxesLagrangeLibration._metadata, IAgCrdnAxesLagrangeLibration._get_PointType_metadata)

    _set_PointType_metadata = { "name" : "PointType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType),) }
    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        return self._intf.set_property(IAgCrdnAxesLagrangeLibration._metadata, IAgCrdnAxesLagrangeLibration._set_PointType_metadata, pointType)

    _get_SecondaryCentralBodies_metadata = { "name" : "SecondaryCentralBodies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SecondaryCentralBodies(self) -> "IAgCrdnCentralBodyCollection":
        """Specify secondary central bodies."""
        return self._intf.get_property(IAgCrdnAxesLagrangeLibration._metadata, IAgCrdnAxesLagrangeLibration._get_SecondaryCentralBodies_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}", IAgCrdnAxesLagrangeLibration)
agcls.AgTypeNameMap["IAgCrdnAxesLagrangeLibration"] = IAgCrdnAxesLagrangeLibration

class IAgCrdnAxesCommonTasks(object):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "CreateTopocentricAxesQuaternion" : 1,
                             "CreateTopocentricAxesEulerAngles" : 2,
                             "CreateFixed" : 3,
                             "Sample" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesCommonTasks._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesCommonTasks from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesCommonTasks.__dict__ and type(IAgCrdnAxesCommonTasks.__dict__[attrname]) == property:
            return IAgCrdnAxesCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesCommonTasks.")
    
    _CreateTopocentricAxesQuaternion_metadata = { "name" : "CreateTopocentricAxesQuaternion",
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def CreateTopocentricAxesQuaternion(self, originPoint:"IAgCrdnPoint", qx:float, qy:float, qz:float, qs:float) -> "IAgCrdnAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The quaternion defines the axes's orientation."""
        return self._intf.invoke(IAgCrdnAxesCommonTasks._metadata, IAgCrdnAxesCommonTasks._CreateTopocentricAxesQuaternion_metadata, originPoint, qx, qy, qz, qs, out_arg())

    _CreateTopocentricAxesEulerAngles_metadata = { "name" : "CreateTopocentricAxesEulerAngles",
            "arg_types" : (agcom.PVOID, agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"), agmarshall.AgEnum_arg(AgEEulerOrientationSequence), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def CreateTopocentricAxesEulerAngles(self, originPoint:"IAgCrdnPoint", sequence:"AgEEulerOrientationSequence", a:typing.Any, b:typing.Any, c:typing.Any) -> "IAgCrdnAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The euler angles define the axes's orientation."""
        return self._intf.invoke(IAgCrdnAxesCommonTasks._metadata, IAgCrdnAxesCommonTasks._CreateTopocentricAxesEulerAngles_metadata, originPoint, sequence, a, b, c, out_arg())

    _CreateFixed_metadata = { "name" : "CreateFixed",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def CreateFixed(self, referenceAxes:"IAgCrdnAxes") -> "IAgCrdnAxesFixed":
        """Creates non-persistent fixed axes based on specified axes."""
        return self._intf.invoke(IAgCrdnAxesCommonTasks._metadata, IAgCrdnAxesCommonTasks._CreateFixed_metadata, referenceAxes, out_arg())

    _Sample_metadata = { "name" : "Sample",
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.LPSAFEARRAY_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Sample(self, axes:"IAgCrdnAxes", referenceAxes:"IAgCrdnAxes", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "IAgCrdnAxesSamplingResult":
        """Computes and returns tabulated orientations and angular velocities of axes with respect to reference axes using specified sampling parameters."""
        return self._intf.invoke(IAgCrdnAxesCommonTasks._metadata, IAgCrdnAxesCommonTasks._Sample_metadata, axes, referenceAxes, intervals, minStep, maxStep, targetRate, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}", IAgCrdnAxesCommonTasks)
agcls.AgTypeNameMap["IAgCrdnAxesCommonTasks"] = IAgCrdnAxesCommonTasks

class IAgCrdnAxesAtTimeInstant(object):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{193F4A55-5E79-43A1-8A2C-3C001F7608A5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceTimeInstant" : 1,
                             "set_ReferenceTimeInstant" : 2,
                             "get_SourceAxes" : 3,
                             "set_SourceAxes" : 4,
                             "get_ReferenceAxes" : 5,
                             "set_ReferenceAxes" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesAtTimeInstant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesAtTimeInstant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAtTimeInstant.__dict__ and type(IAgCrdnAxesAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnAxesAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesAtTimeInstant.")
    
    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(IAgCrdnAxesAtTimeInstant._metadata, IAgCrdnAxesAtTimeInstant._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnAxesAtTimeInstant._metadata, IAgCrdnAxesAtTimeInstant._set_ReferenceTimeInstant_metadata, referenceTimeInstant)

    _get_SourceAxes_metadata = { "name" : "SourceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourceAxes(self) -> "IAgCrdnAxes":
        """A base axes defining the orientation. Can be any VGT axes."""
        return self._intf.get_property(IAgCrdnAxesAtTimeInstant._metadata, IAgCrdnAxesAtTimeInstant._get_SourceAxes_metadata)

    _set_SourceAxes_metadata = { "name" : "SourceAxes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    @SourceAxes.setter
    def SourceAxes(self, sourceAxes:"IAgCrdnAxes") -> None:
        return self._intf.set_property(IAgCrdnAxesAtTimeInstant._metadata, IAgCrdnAxesAtTimeInstant._set_SourceAxes_metadata, sourceAxes)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """A reference axes. Can be any VGT axes."""
        return self._intf.get_property(IAgCrdnAxesAtTimeInstant._metadata, IAgCrdnAxesAtTimeInstant._get_ReferenceAxes_metadata)

    _set_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        return self._intf.set_property(IAgCrdnAxesAtTimeInstant._metadata, IAgCrdnAxesAtTimeInstant._set_ReferenceAxes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{193F4A55-5E79-43A1-8A2C-3C001F7608A5}", IAgCrdnAxesAtTimeInstant)
agcls.AgTypeNameMap["IAgCrdnAxesAtTimeInstant"] = IAgCrdnAxesAtTimeInstant

class IAgCrdnAxesPlugin(object):
    """A VGT axes plugin."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E63FD5E1-B844-4893-9E4C-3F02210AE74C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ProgID" : 1,
                             "get_DisplayName" : 2,
                             "get_AvailableProperties" : 3,
                             "Reset" : 4,
                             "SetProperty" : 5,
                             "GetProperty" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesPlugin._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesPlugin from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesPlugin.__dict__ and type(IAgCrdnAxesPlugin.__dict__[attrname]) == property:
            return IAgCrdnAxesPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesPlugin.")
    
    _get_ProgID_metadata = { "name" : "ProgID",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(IAgCrdnAxesPlugin._metadata, IAgCrdnAxesPlugin._get_ProgID_metadata)

    _get_DisplayName_metadata = { "name" : "DisplayName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(IAgCrdnAxesPlugin._metadata, IAgCrdnAxesPlugin._get_DisplayName_metadata)

    _get_AvailableProperties_metadata = { "name" : "AvailableProperties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(IAgCrdnAxesPlugin._metadata, IAgCrdnAxesPlugin._get_AvailableProperties_metadata)

    _Reset_metadata = { "name" : "Reset",
            "arg_types" : (),
            "marshallers" : () }
    def Reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(IAgCrdnAxesPlugin._metadata, IAgCrdnAxesPlugin._Reset_metadata, )

    _SetProperty_metadata = { "name" : "SetProperty",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(IAgCrdnAxesPlugin._metadata, IAgCrdnAxesPlugin._SetProperty_metadata, name, value)

    _GetProperty_metadata = { "name" : "GetProperty",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(IAgCrdnAxesPlugin._metadata, IAgCrdnAxesPlugin._GetProperty_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{E63FD5E1-B844-4893-9E4C-3F02210AE74C}", IAgCrdnAxesPlugin)
agcls.AgTypeNameMap["IAgCrdnAxesPlugin"] = IAgCrdnAxesPlugin

class IAgCrdnAngleBetweenVectors(object):
    """An angle between two vectors."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B3986E8E-A8CB-414F-8214-71C53ED00740}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_FromVector" : 1,
                             "get_ToVector" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleBetweenVectors._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleBetweenVectors from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleBetweenVectors.__dict__ and type(IAgCrdnAngleBetweenVectors.__dict__[attrname]) == property:
            return IAgCrdnAngleBetweenVectors.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleBetweenVectors.")
    
    _get_FromVector_metadata = { "name" : "FromVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FromVector(self) -> "IAgCrdnVectorRefTo":
        """Specify the first of the two vectors the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleBetweenVectors._metadata, IAgCrdnAngleBetweenVectors._get_FromVector_metadata)

    _get_ToVector_metadata = { "name" : "ToVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ToVector(self) -> "IAgCrdnVectorRefTo":
        """Specify the second of the two vectors the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleBetweenVectors._metadata, IAgCrdnAngleBetweenVectors._get_ToVector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B3986E8E-A8CB-414F-8214-71C53ED00740}", IAgCrdnAngleBetweenVectors)
agcls.AgTypeNameMap["IAgCrdnAngleBetweenVectors"] = IAgCrdnAngleBetweenVectors

class IAgCrdnAngleBetweenPlanes(object):
    """An angle between two planes."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_FromPlane" : 1,
                             "get_ToPlane" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleBetweenPlanes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleBetweenPlanes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleBetweenPlanes.__dict__ and type(IAgCrdnAngleBetweenPlanes.__dict__[attrname]) == property:
            return IAgCrdnAngleBetweenPlanes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleBetweenPlanes.")
    
    _get_FromPlane_metadata = { "name" : "FromPlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FromPlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify the first of the two planes the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleBetweenPlanes._metadata, IAgCrdnAngleBetweenPlanes._get_FromPlane_metadata)

    _get_ToPlane_metadata = { "name" : "ToPlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ToPlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify the second of the two planes the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleBetweenPlanes._metadata, IAgCrdnAngleBetweenPlanes._get_ToPlane_metadata)


agcls.AgClassCatalog.add_catalog_entry("{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}", IAgCrdnAngleBetweenPlanes)
agcls.AgTypeNameMap["IAgCrdnAngleBetweenPlanes"] = IAgCrdnAngleBetweenPlanes

class IAgCrdnAngleDihedral(object):
    """An angle between two vectors about an axis."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_FromVector" : 1,
                             "get_ToVector" : 2,
                             "get_PoleAbout" : 3,
                             "get_CounterClockwiseRotation" : 4,
                             "set_CounterClockwiseRotation" : 5,
                             "get_SignedAngle" : 6,
                             "set_SignedAngle" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleDihedral._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleDihedral from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleDihedral.__dict__ and type(IAgCrdnAngleDihedral.__dict__[attrname]) == property:
            return IAgCrdnAngleDihedral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleDihedral.")
    
    _get_FromVector_metadata = { "name" : "FromVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FromVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a first vector to measure the angle."""
        return self._intf.get_property(IAgCrdnAngleDihedral._metadata, IAgCrdnAngleDihedral._get_FromVector_metadata)

    _get_ToVector_metadata = { "name" : "ToVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ToVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a second vector to measure the angle."""
        return self._intf.get_property(IAgCrdnAngleDihedral._metadata, IAgCrdnAngleDihedral._get_ToVector_metadata)

    _get_PoleAbout_metadata = { "name" : "PoleAbout",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def PoleAbout(self) -> "IAgCrdnVectorRefTo":
        """Specify a vector about."""
        return self._intf.get_property(IAgCrdnAngleDihedral._metadata, IAgCrdnAngleDihedral._get_PoleAbout_metadata)

    _get_CounterClockwiseRotation_metadata = { "name" : "CounterClockwiseRotation",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def CounterClockwiseRotation(self) -> bool:
        """Specify whether the rotation is counter-clockwise."""
        return self._intf.get_property(IAgCrdnAngleDihedral._metadata, IAgCrdnAngleDihedral._get_CounterClockwiseRotation_metadata)

    _set_CounterClockwiseRotation_metadata = { "name" : "CounterClockwiseRotation",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @CounterClockwiseRotation.setter
    def CounterClockwiseRotation(self, counterClockwiseRotation:bool) -> None:
        return self._intf.set_property(IAgCrdnAngleDihedral._metadata, IAgCrdnAngleDihedral._set_CounterClockwiseRotation_metadata, counterClockwiseRotation)

    _get_SignedAngle_metadata = { "name" : "SignedAngle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def SignedAngle(self) -> bool:
        """Specify whether the axis of rotation for the angle is aligned with Positive or Negative direction of the about vector."""
        return self._intf.get_property(IAgCrdnAngleDihedral._metadata, IAgCrdnAngleDihedral._get_SignedAngle_metadata)

    _set_SignedAngle_metadata = { "name" : "SignedAngle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @SignedAngle.setter
    def SignedAngle(self, signedAngle:bool) -> None:
        return self._intf.set_property(IAgCrdnAngleDihedral._metadata, IAgCrdnAngleDihedral._set_SignedAngle_metadata, signedAngle)


agcls.AgClassCatalog.add_catalog_entry("{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}", IAgCrdnAngleDihedral)
agcls.AgTypeNameMap["IAgCrdnAngleDihedral"] = IAgCrdnAngleDihedral

class IAgCrdnAngleRotation(object):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9E842F77-B3A8-475C-96AA-E692B35E8E05}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_FromAxes" : 1,
                             "get_ToAxes" : 2,
                             "get_ReferenceDirection" : 3,
                             "set_ReferenceDirection" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleRotation._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleRotation from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleRotation.__dict__ and type(IAgCrdnAngleRotation.__dict__[attrname]) == property:
            return IAgCrdnAngleRotation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleRotation.")
    
    _get_FromAxes_metadata = { "name" : "FromAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FromAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify an axes to rotate from."""
        return self._intf.get_property(IAgCrdnAngleRotation._metadata, IAgCrdnAngleRotation._get_FromAxes_metadata)

    _get_ToAxes_metadata = { "name" : "ToAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ToAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify an axes to rotate to."""
        return self._intf.get_property(IAgCrdnAngleRotation._metadata, IAgCrdnAngleRotation._get_ToAxes_metadata)

    _get_ReferenceDirection_metadata = { "name" : "ReferenceDirection",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector),) }
    @property
    def ReferenceDirection(self) -> "AgECrdnDisplayAxisSelector":
        """Specify a rotation direction."""
        return self._intf.get_property(IAgCrdnAngleRotation._metadata, IAgCrdnAngleRotation._get_ReferenceDirection_metadata)

    _set_ReferenceDirection_metadata = { "name" : "ReferenceDirection",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector),) }
    @ReferenceDirection.setter
    def ReferenceDirection(self, referenceDirection:"AgECrdnDisplayAxisSelector") -> None:
        return self._intf.set_property(IAgCrdnAngleRotation._metadata, IAgCrdnAngleRotation._set_ReferenceDirection_metadata, referenceDirection)


agcls.AgClassCatalog.add_catalog_entry("{9E842F77-B3A8-475C-96AA-E692B35E8E05}", IAgCrdnAngleRotation)
agcls.AgTypeNameMap["IAgCrdnAngleRotation"] = IAgCrdnAngleRotation

class IAgCrdnAngleToPlane(object):
    """An angle between a vector and a plane."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DDFA25AD-174D-407B-B90C-747B3E43F7C9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceVector" : 1,
                             "get_ReferencePlane" : 2,
                             "get_Signed" : 3,
                             "set_Signed" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleToPlane._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleToPlane from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleToPlane.__dict__ and type(IAgCrdnAngleToPlane.__dict__[attrname]) == property:
            return IAgCrdnAngleToPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleToPlane.")
    
    _get_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IAgCrdnAngleToPlane._metadata, IAgCrdnAngleToPlane._get_ReferenceVector_metadata)

    _get_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IAgCrdnAngleToPlane._metadata, IAgCrdnAngleToPlane._get_ReferencePlane_metadata)

    _get_Signed_metadata = { "name" : "Signed",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignedAngleType),) }
    @property
    def Signed(self) -> "AgECrdnSignedAngleType":
        """Controls whether the angle is measured as either Positive or Negative when the reference Vector is directed toward the plane's normal, or always positive."""
        return self._intf.get_property(IAgCrdnAngleToPlane._metadata, IAgCrdnAngleToPlane._get_Signed_metadata)

    _set_Signed_metadata = { "name" : "Signed",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignedAngleType),) }
    @Signed.setter
    def Signed(self, signed:"AgECrdnSignedAngleType") -> None:
        return self._intf.set_property(IAgCrdnAngleToPlane._metadata, IAgCrdnAngleToPlane._set_Signed_metadata, signed)


agcls.AgClassCatalog.add_catalog_entry("{DDFA25AD-174D-407B-B90C-747B3E43F7C9}", IAgCrdnAngleToPlane)
agcls.AgTypeNameMap["IAgCrdnAngleToPlane"] = IAgCrdnAngleToPlane

class IAgCrdnPlaneNormal(object):
    """A plane normal to a vector at a given point."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AAF66E5C-B310-4387-BDAE-D45F24F226BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_NormalVector" : 1,
                             "get_ReferenceVector" : 2,
                             "get_ReferencePoint" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneNormal._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneNormal from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneNormal.__dict__ and type(IAgCrdnPlaneNormal.__dict__[attrname]) == property:
            return IAgCrdnPlaneNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneNormal.")
    
    _get_NormalVector_metadata = { "name" : "NormalVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def NormalVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a Normal vector."""
        return self._intf.get_property(IAgCrdnPlaneNormal._metadata, IAgCrdnPlaneNormal._get_NormalVector_metadata)

    _get_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IAgCrdnPlaneNormal._metadata, IAgCrdnPlaneNormal._get_ReferenceVector_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IAgCrdnPlaneNormal._metadata, IAgCrdnPlaneNormal._get_ReferencePoint_metadata)


agcls.AgClassCatalog.add_catalog_entry("{AAF66E5C-B310-4387-BDAE-D45F24F226BC}", IAgCrdnPlaneNormal)
agcls.AgTypeNameMap["IAgCrdnPlaneNormal"] = IAgCrdnPlaneNormal

class IAgCrdnPlaneQuadrant(object):
    """A plane based on a selected Quadrant of a reference system."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceSystem" : 1,
                             "get_Quadrant" : 2,
                             "set_Quadrant" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneQuadrant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneQuadrant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneQuadrant.__dict__ and type(IAgCrdnPlaneQuadrant.__dict__[attrname]) == property:
            return IAgCrdnPlaneQuadrant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneQuadrant.")
    
    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IAgCrdnPlaneQuadrant._metadata, IAgCrdnPlaneQuadrant._get_ReferenceSystem_metadata)

    _get_Quadrant_metadata = { "name" : "Quadrant",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnQuadrantType),) }
    @property
    def Quadrant(self) -> "AgECrdnQuadrantType":
        """Specify a quadrant."""
        return self._intf.get_property(IAgCrdnPlaneQuadrant._metadata, IAgCrdnPlaneQuadrant._get_Quadrant_metadata)

    _set_Quadrant_metadata = { "name" : "Quadrant",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnQuadrantType),) }
    @Quadrant.setter
    def Quadrant(self, quadrant:"AgECrdnQuadrantType") -> None:
        return self._intf.set_property(IAgCrdnPlaneQuadrant._metadata, IAgCrdnPlaneQuadrant._set_Quadrant_metadata, quadrant)


agcls.AgClassCatalog.add_catalog_entry("{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}", IAgCrdnPlaneQuadrant)
agcls.AgTypeNameMap["IAgCrdnPlaneQuadrant"] = IAgCrdnPlaneQuadrant

class IAgCrdnPlaneTrajectory(object):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Point" : 1,
                             "get_ReferenceSystem" : 2,
                             "get_RotationOffset" : 3,
                             "set_RotationOffset" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneTrajectory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneTrajectory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneTrajectory.__dict__ and type(IAgCrdnPlaneTrajectory.__dict__[attrname]) == property:
            return IAgCrdnPlaneTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneTrajectory.")
    
    _get_Point_metadata = { "name" : "Point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Point(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IAgCrdnPlaneTrajectory._metadata, IAgCrdnPlaneTrajectory._get_Point_metadata)

    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IAgCrdnPlaneTrajectory._metadata, IAgCrdnPlaneTrajectory._get_ReferenceSystem_metadata)

    _get_RotationOffset_metadata = { "name" : "RotationOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        return self._intf.get_property(IAgCrdnPlaneTrajectory._metadata, IAgCrdnPlaneTrajectory._get_RotationOffset_metadata)

    _set_RotationOffset_metadata = { "name" : "RotationOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        return self._intf.set_property(IAgCrdnPlaneTrajectory._metadata, IAgCrdnPlaneTrajectory._set_RotationOffset_metadata, rotationOffset)


agcls.AgClassCatalog.add_catalog_entry("{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}", IAgCrdnPlaneTrajectory)
agcls.AgTypeNameMap["IAgCrdnPlaneTrajectory"] = IAgCrdnPlaneTrajectory

class IAgCrdnPlaneTriad(object):
    """A Plane containing points A, B and ReferencePont with the first axis aligned with the direction from the ReferencePoint to point A and the second axis toward the direction from the ReferencePoint to point B."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_PointA" : 1,
                             "get_PointB" : 2,
                             "get_ReferencePoint" : 3,
                             "get_RotationOffset" : 4,
                             "set_RotationOffset" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneTriad._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneTriad from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneTriad.__dict__ and type(IAgCrdnPlaneTriad.__dict__[attrname]) == property:
            return IAgCrdnPlaneTriad.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneTriad.")
    
    _get_PointA_metadata = { "name" : "PointA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def PointA(self) -> "IAgCrdnPointRefTo":
        """Specify a point A."""
        return self._intf.get_property(IAgCrdnPlaneTriad._metadata, IAgCrdnPlaneTriad._get_PointA_metadata)

    _get_PointB_metadata = { "name" : "PointB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def PointB(self) -> "IAgCrdnPointRefTo":
        """Specify a point B."""
        return self._intf.get_property(IAgCrdnPlaneTriad._metadata, IAgCrdnPlaneTriad._get_PointB_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IAgCrdnPlaneTriad._metadata, IAgCrdnPlaneTriad._get_ReferencePoint_metadata)

    _get_RotationOffset_metadata = { "name" : "RotationOffset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        return self._intf.get_property(IAgCrdnPlaneTriad._metadata, IAgCrdnPlaneTriad._get_RotationOffset_metadata)

    _set_RotationOffset_metadata = { "name" : "RotationOffset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        return self._intf.set_property(IAgCrdnPlaneTriad._metadata, IAgCrdnPlaneTriad._set_RotationOffset_metadata, rotationOffset)


agcls.AgClassCatalog.add_catalog_entry("{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}", IAgCrdnPlaneTriad)
agcls.AgTypeNameMap["IAgCrdnPlaneTriad"] = IAgCrdnPlaneTriad

class IAgCrdnPlaneTwoVector(object):
    """A plane passing through point and containing two given vectors."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{345761f0-0ace-494c-8d9c-0f3e3af9c2da}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceVector" : 1,
                             "get_Vector2" : 2,
                             "get_ReferencePoint" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneTwoVector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneTwoVector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneTwoVector.__dict__ and type(IAgCrdnPlaneTwoVector.__dict__[attrname]) == property:
            return IAgCrdnPlaneTwoVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneTwoVector.")
    
    _get_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IAgCrdnPlaneTwoVector._metadata, IAgCrdnPlaneTwoVector._get_ReferenceVector_metadata)

    _get_Vector2_metadata = { "name" : "Vector2",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector2(self) -> "IAgCrdnVectorRefTo":
        """Specify a Normal vector."""
        return self._intf.get_property(IAgCrdnPlaneTwoVector._metadata, IAgCrdnPlaneTwoVector._get_Vector2_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IAgCrdnPlaneTwoVector._metadata, IAgCrdnPlaneTwoVector._get_ReferencePoint_metadata)


agcls.AgClassCatalog.add_catalog_entry("{345761f0-0ace-494c-8d9c-0f3e3af9c2da}", IAgCrdnPlaneTwoVector)
agcls.AgTypeNameMap["IAgCrdnPlaneTwoVector"] = IAgCrdnPlaneTwoVector

class IAgCrdnPointBPlane(object):
    """B-Plane point using the selected target body."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CC3B797F-5327-4D04-911D-8ED499E056AF}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_TargetBody" : 1,
                             "get_Trajectory" : 2,
                             "get_PointType" : 3,
                             "set_PointType" : 4,
                             "get_Direction" : 5,
                             "set_Direction" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointBPlane._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointBPlane from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointBPlane.__dict__ and type(IAgCrdnPointBPlane.__dict__[attrname]) == property:
            return IAgCrdnPointBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointBPlane.")
    
    _get_TargetBody_metadata = { "name" : "TargetBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def TargetBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a target central body."""
        return self._intf.get_property(IAgCrdnPointBPlane._metadata, IAgCrdnPointBPlane._get_TargetBody_metadata)

    _get_Trajectory_metadata = { "name" : "Trajectory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Trajectory(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IAgCrdnPointBPlane._metadata, IAgCrdnPointBPlane._get_Trajectory_metadata)

    _get_PointType_metadata = { "name" : "PointType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPointBPlaneType),) }
    @property
    def PointType(self) -> "AgECrdnPointBPlaneType":
        """Specify a point type."""
        return self._intf.get_property(IAgCrdnPointBPlane._metadata, IAgCrdnPointBPlane._get_PointType_metadata)

    _set_PointType_metadata = { "name" : "PointType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPointBPlaneType),) }
    @PointType.setter
    def PointType(self, pointType:"AgECrdnPointBPlaneType") -> None:
        return self._intf.set_property(IAgCrdnPointBPlane._metadata, IAgCrdnPointBPlane._set_PointType_metadata, pointType)

    _get_Direction_metadata = { "name" : "Direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDirectionType),) }
    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        return self._intf.get_property(IAgCrdnPointBPlane._metadata, IAgCrdnPointBPlane._get_Direction_metadata)

    _set_Direction_metadata = { "name" : "Direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDirectionType),) }
    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        return self._intf.set_property(IAgCrdnPointBPlane._metadata, IAgCrdnPointBPlane._set_Direction_metadata, direction)


agcls.AgClassCatalog.add_catalog_entry("{CC3B797F-5327-4D04-911D-8ED499E056AF}", IAgCrdnPointBPlane)
agcls.AgTypeNameMap["IAgCrdnPointBPlane"] = IAgCrdnPointBPlane

class IAgCrdnPointFile(object):
    """Point specified by data from a file."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9612277C-2238-42BD-89D7-E54D7701D8F2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Filename" : 1,
                             "set_Filename" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointFile._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointFile from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointFile.__dict__ and type(IAgCrdnPointFile.__dict__[attrname]) == property:
            return IAgCrdnPointFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointFile.")
    
    _get_Filename_metadata = { "name" : "Filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        return self._intf.get_property(IAgCrdnPointFile._metadata, IAgCrdnPointFile._get_Filename_metadata)

    _set_Filename_metadata = { "name" : "Filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Filename.setter
    def Filename(self, filename:str) -> None:
        return self._intf.set_property(IAgCrdnPointFile._metadata, IAgCrdnPointFile._set_Filename_metadata, filename)


agcls.AgClassCatalog.add_catalog_entry("{9612277C-2238-42BD-89D7-E54D7701D8F2}", IAgCrdnPointFile)
agcls.AgTypeNameMap["IAgCrdnPointFile"] = IAgCrdnPointFile

class IAgCrdnPointFixedInSystem(object):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Reference" : 1,
                             "get_FixedPoint" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointFixedInSystem._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointFixedInSystem from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointFixedInSystem.__dict__ and type(IAgCrdnPointFixedInSystem.__dict__[attrname]) == property:
            return IAgCrdnPointFixedInSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointFixedInSystem.")
    
    _get_Reference_metadata = { "name" : "Reference",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Reference(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IAgCrdnPointFixedInSystem._metadata, IAgCrdnPointFixedInSystem._get_Reference_metadata)

    _get_FixedPoint_metadata = { "name" : "FixedPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def FixedPoint(self) -> "IAgPosition":
        """Specify the point's position. The position is relative with respect to the specified reference system."""
        return self._intf.get_property(IAgCrdnPointFixedInSystem._metadata, IAgCrdnPointFixedInSystem._get_FixedPoint_metadata)


agcls.AgClassCatalog.add_catalog_entry("{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}", IAgCrdnPointFixedInSystem)
agcls.AgTypeNameMap["IAgCrdnPointFixedInSystem"] = IAgCrdnPointFixedInSystem

class IAgCrdnPointGrazing(object):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7FDF037E-1367-4590-A330-660EF3442DE1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2,
                             "get_DirectionVector" : 3,
                             "get_Altitude" : 4,
                             "set_Altitude" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointGrazing._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointGrazing from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointGrazing.__dict__ and type(IAgCrdnPointGrazing.__dict__[attrname]) == property:
            return IAgCrdnPointGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointGrazing.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnPointGrazing._metadata, IAgCrdnPointGrazing._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        return self._intf.get_property(IAgCrdnPointGrazing._metadata, IAgCrdnPointGrazing._get_ReferencePoint_metadata)

    _get_DirectionVector_metadata = { "name" : "DirectionVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def DirectionVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a direction vector to be used in conjunction with the position vector from the selected central body to the reference point to define a plane in which the line will lie."""
        return self._intf.get_property(IAgCrdnPointGrazing._metadata, IAgCrdnPointGrazing._get_DirectionVector_metadata)

    _get_Altitude_metadata = { "name" : "Altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Altitude(self) -> float:
        """The point of closest approach to the central body surface occurs at the specified altitude."""
        return self._intf.get_property(IAgCrdnPointGrazing._metadata, IAgCrdnPointGrazing._get_Altitude_metadata)

    _set_Altitude_metadata = { "name" : "Altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        return self._intf.set_property(IAgCrdnPointGrazing._metadata, IAgCrdnPointGrazing._set_Altitude_metadata, altitude)


agcls.AgClassCatalog.add_catalog_entry("{7FDF037E-1367-4590-A330-660EF3442DE1}", IAgCrdnPointGrazing)
agcls.AgTypeNameMap["IAgCrdnPointGrazing"] = IAgCrdnPointGrazing

class IAgCrdnPointGlint(object):
    """Point on central body surface that reflects from source to observer."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4168949-A6F2-42B7-8019-671FF808836D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_SourcePoint" : 2,
                             "get_ObserverPoint" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointGlint._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointGlint from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointGlint.__dict__ and type(IAgCrdnPointGlint.__dict__[attrname]) == property:
            return IAgCrdnPointGlint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointGlint.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnPointGlint._metadata, IAgCrdnPointGlint._get_CentralBody_metadata)

    _get_SourcePoint_metadata = { "name" : "SourcePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourcePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a source point."""
        return self._intf.get_property(IAgCrdnPointGlint._metadata, IAgCrdnPointGlint._get_SourcePoint_metadata)

    _get_ObserverPoint_metadata = { "name" : "ObserverPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ObserverPoint(self) -> "IAgCrdnPointRefTo":
        """Specify an observer point."""
        return self._intf.get_property(IAgCrdnPointGlint._metadata, IAgCrdnPointGlint._get_ObserverPoint_metadata)


agcls.AgClassCatalog.add_catalog_entry("{C4168949-A6F2-42B7-8019-671FF808836D}", IAgCrdnPointGlint)
agcls.AgTypeNameMap["IAgCrdnPointGlint"] = IAgCrdnPointGlint

class IAgCrdnPointCovarianceGrazing(object):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CC9E8B92-77D8-46A9-BD52-3DABB173913D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferencePoint" : 1,
                             "get_DirectionVector" : 2,
                             "get_TargetName" : 3,
                             "set_TargetName" : 4,
                             "get_Distance" : 5,
                             "set_Distance" : 6,
                             "get_Probability" : 7,
                             "set_Probability" : 8,
                             "get_Scale" : 9,
                             "set_Scale" : 10,
                             "get_UseProbability" : 11,
                             "set_UseProbability" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointCovarianceGrazing._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointCovarianceGrazing from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCovarianceGrazing.__dict__ and type(IAgCrdnPointCovarianceGrazing.__dict__[attrname]) == property:
            return IAgCrdnPointCovarianceGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointCovarianceGrazing.")
    
    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        return self._intf.get_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._get_ReferencePoint_metadata)

    _get_DirectionVector_metadata = { "name" : "DirectionVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def DirectionVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a direction vector to be used in conjunction with the displacement vector from the selected target object to the reference point to define a plane in which the line will lie."""
        return self._intf.get_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._get_DirectionVector_metadata)

    _get_TargetName_metadata = { "name" : "TargetName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def TargetName(self) -> str:
        """Specify a target object about which the covariance ellipsoid is centered."""
        return self._intf.get_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._get_TargetName_metadata)

    _set_TargetName_metadata = { "name" : "TargetName",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @TargetName.setter
    def TargetName(self, targetName:str) -> None:
        return self._intf.set_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._set_TargetName_metadata, targetName)

    _get_Distance_metadata = { "name" : "Distance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Distance(self) -> float:
        """The point of closest approach to the covariance ellipsoid surface occurs at the specified distance."""
        return self._intf.get_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._get_Distance_metadata)

    _set_Distance_metadata = { "name" : "Distance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Distance.setter
    def Distance(self, distance:float) -> None:
        return self._intf.set_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._set_Distance_metadata, distance)

    _get_Probability_metadata = { "name" : "Probability",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Probability(self) -> float:
        """Specify a probability that the true position is inside the ellipsoid boundary."""
        return self._intf.get_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._get_Probability_metadata)

    _set_Probability_metadata = { "name" : "Probability",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Probability.setter
    def Probability(self, probability:float) -> None:
        return self._intf.set_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._set_Probability_metadata, probability)

    _get_Scale_metadata = { "name" : "Scale",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Scale(self) -> float:
        """Specify a scale factor which is applied to the one sigma ellipsoid."""
        return self._intf.get_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._get_Scale_metadata)

    _set_Scale_metadata = { "name" : "Scale",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Scale.setter
    def Scale(self, scale:float) -> None:
        return self._intf.set_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._set_Scale_metadata, scale)

    _get_UseProbability_metadata = { "name" : "UseProbability",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseProbability(self) -> bool:
        """A flag controlling whether to use probability or scale factor."""
        return self._intf.get_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._get_UseProbability_metadata)

    _set_UseProbability_metadata = { "name" : "UseProbability",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseProbability.setter
    def UseProbability(self, useProbability:bool) -> None:
        return self._intf.set_property(IAgCrdnPointCovarianceGrazing._metadata, IAgCrdnPointCovarianceGrazing._set_UseProbability_metadata, useProbability)


agcls.AgClassCatalog.add_catalog_entry("{CC9E8B92-77D8-46A9-BD52-3DABB173913D}", IAgCrdnPointCovarianceGrazing)
agcls.AgTypeNameMap["IAgCrdnPointCovarianceGrazing"] = IAgCrdnPointCovarianceGrazing

class IAgCrdnPointPlaneIntersection(object):
    """Point on a plane located along a given direction looking from a given origin."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_DirectionVector" : 1,
                             "get_ReferencePlane" : 2,
                             "get_OriginPoint" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointPlaneIntersection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointPlaneIntersection from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointPlaneIntersection.__dict__ and type(IAgCrdnPointPlaneIntersection.__dict__[attrname]) == property:
            return IAgCrdnPointPlaneIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointPlaneIntersection.")
    
    _get_DirectionVector_metadata = { "name" : "DirectionVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def DirectionVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a direction vector."""
        return self._intf.get_property(IAgCrdnPointPlaneIntersection._metadata, IAgCrdnPointPlaneIntersection._get_DirectionVector_metadata)

    _get_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IAgCrdnPointPlaneIntersection._metadata, IAgCrdnPointPlaneIntersection._get_ReferencePlane_metadata)

    _get_OriginPoint_metadata = { "name" : "OriginPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginPoint(self) -> "IAgCrdnPointRefTo":
        """Specify the origin point."""
        return self._intf.get_property(IAgCrdnPointPlaneIntersection._metadata, IAgCrdnPointPlaneIntersection._get_OriginPoint_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}", IAgCrdnPointPlaneIntersection)
agcls.AgTypeNameMap["IAgCrdnPointPlaneIntersection"] = IAgCrdnPointPlaneIntersection

class IAgCrdnPointOnSurface(object):
    """The detic subpoint of the reference point as projected onto the central body."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AED0D41F-BB69-4672-A513-17A43B12873D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2,
                             "get_ReferenceShape" : 3,
                             "set_ReferenceShape" : 4,
                             "get_SurfaceType" : 5,
                             "set_SurfaceType" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointOnSurface._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointOnSurface from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointOnSurface.__dict__ and type(IAgCrdnPointOnSurface.__dict__[attrname]) == property:
            return IAgCrdnPointOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointOnSurface.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnPointOnSurface._metadata, IAgCrdnPointOnSurface._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IAgCrdnPointOnSurface._metadata, IAgCrdnPointOnSurface._get_ReferencePoint_metadata)

    _get_ReferenceShape_metadata = { "name" : "ReferenceShape",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnReferenceShapeType),) }
    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Specify a reference shape."""
        return self._intf.get_property(IAgCrdnPointOnSurface._metadata, IAgCrdnPointOnSurface._get_ReferenceShape_metadata)

    _set_ReferenceShape_metadata = { "name" : "ReferenceShape",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnReferenceShapeType),) }
    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        return self._intf.set_property(IAgCrdnPointOnSurface._metadata, IAgCrdnPointOnSurface._set_ReferenceShape_metadata, referenceShape)

    _get_SurfaceType_metadata = { "name" : "SurfaceType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSurfaceType),) }
    @property
    def SurfaceType(self) -> "AgECrdnSurfaceType":
        """Specify a surface type."""
        return self._intf.get_property(IAgCrdnPointOnSurface._metadata, IAgCrdnPointOnSurface._get_SurfaceType_metadata)

    _set_SurfaceType_metadata = { "name" : "SurfaceType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSurfaceType),) }
    @SurfaceType.setter
    def SurfaceType(self, surfaceType:"AgECrdnSurfaceType") -> None:
        return self._intf.set_property(IAgCrdnPointOnSurface._metadata, IAgCrdnPointOnSurface._set_SurfaceType_metadata, surfaceType)


agcls.AgClassCatalog.add_catalog_entry("{AED0D41F-BB69-4672-A513-17A43B12873D}", IAgCrdnPointOnSurface)
agcls.AgTypeNameMap["IAgCrdnPointOnSurface"] = IAgCrdnPointOnSurface

class IAgCrdnPointModelAttach(object):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFEB5448-9053-44F6-BCB5-35280361131F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_PointableElementName" : 1,
                             "set_PointableElementName" : 2,
                             "get_UseScale" : 3,
                             "set_UseScale" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointModelAttach._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointModelAttach from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointModelAttach.__dict__ and type(IAgCrdnPointModelAttach.__dict__[attrname]) == property:
            return IAgCrdnPointModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointModelAttach.")
    
    _get_PointableElementName_metadata = { "name" : "PointableElementName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def PointableElementName(self) -> str:
        """Specify a model attachment point."""
        return self._intf.get_property(IAgCrdnPointModelAttach._metadata, IAgCrdnPointModelAttach._get_PointableElementName_metadata)

    _set_PointableElementName_metadata = { "name" : "PointableElementName",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        return self._intf.set_property(IAgCrdnPointModelAttach._metadata, IAgCrdnPointModelAttach._set_PointableElementName_metadata, pointableElementName)

    _get_UseScale_metadata = { "name" : "UseScale",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseScale(self) -> bool:
        """Specify whether to use the model scale."""
        return self._intf.get_property(IAgCrdnPointModelAttach._metadata, IAgCrdnPointModelAttach._get_UseScale_metadata)

    _set_UseScale_metadata = { "name" : "UseScale",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseScale.setter
    def UseScale(self, useScale:bool) -> None:
        return self._intf.set_property(IAgCrdnPointModelAttach._metadata, IAgCrdnPointModelAttach._set_UseScale_metadata, useScale)


agcls.AgClassCatalog.add_catalog_entry("{CFEB5448-9053-44F6-BCB5-35280361131F}", IAgCrdnPointModelAttach)
agcls.AgTypeNameMap["IAgCrdnPointModelAttach"] = IAgCrdnPointModelAttach

class IAgCrdnPointSatelliteCollectionEntry(object):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_EntryName" : 1,
                             "set_EntryName" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointSatelliteCollectionEntry._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointSatelliteCollectionEntry from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSatelliteCollectionEntry.__dict__ and type(IAgCrdnPointSatelliteCollectionEntry.__dict__[attrname]) == property:
            return IAgCrdnPointSatelliteCollectionEntry.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointSatelliteCollectionEntry.")
    
    _get_EntryName_metadata = { "name" : "EntryName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def EntryName(self) -> str:
        """Specify a satellite collection entry name."""
        return self._intf.get_property(IAgCrdnPointSatelliteCollectionEntry._metadata, IAgCrdnPointSatelliteCollectionEntry._get_EntryName_metadata)

    _set_EntryName_metadata = { "name" : "EntryName",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @EntryName.setter
    def EntryName(self, entryName:str) -> None:
        return self._intf.set_property(IAgCrdnPointSatelliteCollectionEntry._metadata, IAgCrdnPointSatelliteCollectionEntry._set_EntryName_metadata, entryName)


agcls.AgClassCatalog.add_catalog_entry("{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}", IAgCrdnPointSatelliteCollectionEntry)
agcls.AgTypeNameMap["IAgCrdnPointSatelliteCollectionEntry"] = IAgCrdnPointSatelliteCollectionEntry

class IAgCrdnPointPlaneProjection(object):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SourcePoint" : 1,
                             "get_ReferencePlane" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointPlaneProjection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointPlaneProjection from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointPlaneProjection.__dict__ and type(IAgCrdnPointPlaneProjection.__dict__[attrname]) == property:
            return IAgCrdnPointPlaneProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointPlaneProjection.")
    
    _get_SourcePoint_metadata = { "name" : "SourcePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourcePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a source point."""
        return self._intf.get_property(IAgCrdnPointPlaneProjection._metadata, IAgCrdnPointPlaneProjection._get_SourcePoint_metadata)

    _get_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IAgCrdnPointPlaneProjection._metadata, IAgCrdnPointPlaneProjection._get_ReferencePlane_metadata)


agcls.AgClassCatalog.add_catalog_entry("{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}", IAgCrdnPointPlaneProjection)
agcls.AgTypeNameMap["IAgCrdnPointPlaneProjection"] = IAgCrdnPointPlaneProjection

class IAgCrdnPointLagrangeLibration(object):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_PointType" : 2,
                             "set_PointType" : 3,
                             "get_SecondaryCentralBodies" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointLagrangeLibration._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointLagrangeLibration from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointLagrangeLibration.__dict__ and type(IAgCrdnPointLagrangeLibration.__dict__[attrname]) == property:
            return IAgCrdnPointLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointLagrangeLibration.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnPointLagrangeLibration._metadata, IAgCrdnPointLagrangeLibration._get_CentralBody_metadata)

    _get_PointType_metadata = { "name" : "PointType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType),) }
    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        return self._intf.get_property(IAgCrdnPointLagrangeLibration._metadata, IAgCrdnPointLagrangeLibration._get_PointType_metadata)

    _set_PointType_metadata = { "name" : "PointType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType),) }
    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        return self._intf.set_property(IAgCrdnPointLagrangeLibration._metadata, IAgCrdnPointLagrangeLibration._set_PointType_metadata, pointType)

    _get_SecondaryCentralBodies_metadata = { "name" : "SecondaryCentralBodies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SecondaryCentralBodies(self) -> "IAgCrdnCentralBodyCollection":
        """Specify multiple secondary central bodies."""
        return self._intf.get_property(IAgCrdnPointLagrangeLibration._metadata, IAgCrdnPointLagrangeLibration._get_SecondaryCentralBodies_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}", IAgCrdnPointLagrangeLibration)
agcls.AgTypeNameMap["IAgCrdnPointLagrangeLibration"] = IAgCrdnPointLagrangeLibration

class IAgCrdnPointCommonTasks(object):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C357C0A5-3F2A-499C-83F3-6824532C969E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "CreateFixedInSystemCartographic" : 1,
                             "CreateFixedInSystemCartesian" : 2,
                             "Sample" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointCommonTasks._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointCommonTasks from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCommonTasks.__dict__ and type(IAgCrdnPointCommonTasks.__dict__[attrname]) == property:
            return IAgCrdnPointCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointCommonTasks.")
    
    _CreateFixedInSystemCartographic_metadata = { "name" : "CreateFixedInSystemCartographic",
            "arg_types" : (agcom.PVOID, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def CreateFixedInSystemCartographic(self, referenceSystem:"IAgCrdnSystem", latitude:typing.Any, longitude:typing.Any, altitude:float) -> "IAgCrdnPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        return self._intf.invoke(IAgCrdnPointCommonTasks._metadata, IAgCrdnPointCommonTasks._CreateFixedInSystemCartographic_metadata, referenceSystem, latitude, longitude, altitude, out_arg())

    _CreateFixedInSystemCartesian_metadata = { "name" : "CreateFixedInSystemCartesian",
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def CreateFixedInSystemCartesian(self, referenceSystem:"IAgCrdnSystem", x:float, y:float, z:float) -> "IAgCrdnPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        return self._intf.invoke(IAgCrdnPointCommonTasks._metadata, IAgCrdnPointCommonTasks._CreateFixedInSystemCartesian_metadata, referenceSystem, x, y, z, out_arg())

    _Sample_metadata = { "name" : "Sample",
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"), agmarshall.AgInterface_in_arg("IAgCrdnSystem"), agmarshall.LPSAFEARRAY_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Sample(self, point:"IAgCrdnPoint", referenceSystem:"IAgCrdnSystem", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "IAgCrdnPointSamplingResult":
        """Computes and returns tabulated positions and velocities of a point with respect to reference system using specified sampling parameters."""
        return self._intf.invoke(IAgCrdnPointCommonTasks._metadata, IAgCrdnPointCommonTasks._Sample_metadata, point, referenceSystem, intervals, minStep, maxStep, targetRate, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C357C0A5-3F2A-499C-83F3-6824532C969E}", IAgCrdnPointCommonTasks)
agcls.AgTypeNameMap["IAgCrdnPointCommonTasks"] = IAgCrdnPointCommonTasks

class IAgCrdnPointCentBodyIntersect(object):
    """Point on central body surface along direction vector originating at source point."""
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C0F5946B-9467-44AC-B16A-9276CE4EA141}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "set_CentralBody" : 2,
                             "get_ReferencePoint" : 3,
                             "set_ReferencePoint" : 4,
                             "get_DirectionVector" : 5,
                             "set_DirectionVector" : 6,
                             "get_IntersectionSurface" : 7,
                             "set_IntersectionSurface" : 8,
                             "get_Altitude" : 9,
                             "set_Altitude" : 10,
                             "get_UseRangeConstraint" : 11,
                             "set_UseRangeConstraint" : 12,
                             "get_MinimumRange" : 13,
                             "set_MinimumRange" : 14,
                             "get_MaximumRange" : 15,
                             "set_MaximumRange" : 16,
                             "get_UseMinimumRange" : 17,
                             "set_UseMinimumRange" : 18,
                             "get_UseMaximumRange" : 19,
                             "set_UseMaximumRange" : 20,
                             "SetRange" : 21,
                             "get_AllowIntersectionFromBelow" : 22,
                             "set_AllowIntersectionFromBelow" : 23, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointCentBodyIntersect._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointCentBodyIntersect from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCentBodyIntersect.__dict__ and type(IAgCrdnPointCentBodyIntersect.__dict__[attrname]) == property:
            return IAgCrdnPointCentBodyIntersect.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointCentBodyIntersect.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def CentralBody(self) -> str:
        """Central body."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_CentralBody_metadata)

    _set_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_CentralBody_metadata, centralBody)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """A reference point. Can be any point from VGT."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_ReferencePoint_metadata)

    _set_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_ReferencePoint_metadata, referencePoint)

    _get_DirectionVector_metadata = { "name" : "DirectionVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def DirectionVector(self) -> "IAgCrdnVector":
        """A direction vector. Can be any vector from VGT."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_DirectionVector_metadata)

    _set_DirectionVector_metadata = { "name" : "DirectionVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @DirectionVector.setter
    def DirectionVector(self, directionVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_DirectionVector_metadata, directionVector)

    _get_IntersectionSurface_metadata = { "name" : "IntersectionSurface",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntersectionSurface),) }
    @property
    def IntersectionSurface(self) -> "AgECrdnIntersectionSurface":
        """An intersection surface."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_IntersectionSurface_metadata)

    _set_IntersectionSurface_metadata = { "name" : "IntersectionSurface",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnIntersectionSurface),) }
    @IntersectionSurface.setter
    def IntersectionSurface(self, intersectionSurface:"AgECrdnIntersectionSurface") -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_IntersectionSurface_metadata, intersectionSurface)

    _get_Altitude_metadata = { "name" : "Altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Altitude(self) -> float:
        """An altitude."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_Altitude_metadata)

    _set_Altitude_metadata = { "name" : "Altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_Altitude_metadata, altitude)

    _get_UseRangeConstraint_metadata = { "name" : "UseRangeConstraint",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseRangeConstraint(self) -> bool:
        """Whether to use range constraint."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_UseRangeConstraint_metadata)

    _set_UseRangeConstraint_metadata = { "name" : "UseRangeConstraint",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseRangeConstraint.setter
    def UseRangeConstraint(self, useRangeConstraint:bool) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_UseRangeConstraint_metadata, useRangeConstraint)

    _get_MinimumRange_metadata = { "name" : "MinimumRange",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MinimumRange(self) -> float:
        """A minimum range. An exception is thrown if the value exceeds the MaximumRange. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_MinimumRange_metadata)

    _set_MinimumRange_metadata = { "name" : "MinimumRange",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MinimumRange.setter
    def MinimumRange(self, minimumRange:float) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_MinimumRange_metadata, minimumRange)

    _get_MaximumRange_metadata = { "name" : "MaximumRange",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def MaximumRange(self) -> float:
        """A maximum range. An exception is thrown if the value is less than the MinimumRange. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_MaximumRange_metadata)

    _set_MaximumRange_metadata = { "name" : "MaximumRange",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @MaximumRange.setter
    def MaximumRange(self, maximumRange:float) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_MaximumRange_metadata, maximumRange)

    _get_UseMinimumRange_metadata = { "name" : "UseMinimumRange",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseMinimumRange(self) -> bool:
        """Whether the minimum range is used. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_UseMinimumRange_metadata)

    _set_UseMinimumRange_metadata = { "name" : "UseMinimumRange",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseMinimumRange.setter
    def UseMinimumRange(self, useMinimumRange:bool) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_UseMinimumRange_metadata, useMinimumRange)

    _get_UseMaximumRange_metadata = { "name" : "UseMaximumRange",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseMaximumRange(self) -> bool:
        """Whether the maximum range is used. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_UseMaximumRange_metadata)

    _set_UseMaximumRange_metadata = { "name" : "UseMaximumRange",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseMaximumRange.setter
    def UseMaximumRange(self, useMaximumRange:bool) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_UseMaximumRange_metadata, useMaximumRange)

    _SetRange_metadata = { "name" : "SetRange",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def SetRange(self, minimum:float, maximum:float) -> None:
        """Set minimum and maximum range. An exception is thrown if Minimum exceeds Maximum. An exception is thrown if UseRangeConstraint is set to true. Applicable only if the range constraint is not used."""
        return self._intf.invoke(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._SetRange_metadata, minimum, maximum)

    _get_AllowIntersectionFromBelow_metadata = { "name" : "AllowIntersectionFromBelow",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def AllowIntersectionFromBelow(self) -> bool:
        """Whether intersection is computed when reference point is inside the surface. Applicable when the surface is not defined by terrain."""
        return self._intf.get_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._get_AllowIntersectionFromBelow_metadata)

    _set_AllowIntersectionFromBelow_metadata = { "name" : "AllowIntersectionFromBelow",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @AllowIntersectionFromBelow.setter
    def AllowIntersectionFromBelow(self, allowIntersectionFromBelow:bool) -> None:
        return self._intf.set_property(IAgCrdnPointCentBodyIntersect._metadata, IAgCrdnPointCentBodyIntersect._set_AllowIntersectionFromBelow_metadata, allowIntersectionFromBelow)


agcls.AgClassCatalog.add_catalog_entry("{C0F5946B-9467-44AC-B16A-9276CE4EA141}", IAgCrdnPointCentBodyIntersect)
agcls.AgTypeNameMap["IAgCrdnPointCentBodyIntersect"] = IAgCrdnPointCentBodyIntersect

class IAgCrdnPointAtTimeInstant(object):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceTimeInstant" : 1,
                             "set_ReferenceTimeInstant" : 2,
                             "get_SourcePoint" : 3,
                             "set_SourcePoint" : 4,
                             "get_ReferenceSystem" : 5,
                             "set_ReferenceSystem" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointAtTimeInstant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointAtTimeInstant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointAtTimeInstant.__dict__ and type(IAgCrdnPointAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnPointAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointAtTimeInstant.")
    
    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(IAgCrdnPointAtTimeInstant._metadata, IAgCrdnPointAtTimeInstant._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnPointAtTimeInstant._metadata, IAgCrdnPointAtTimeInstant._set_ReferenceTimeInstant_metadata, referenceTimeInstant)

    _get_SourcePoint_metadata = { "name" : "SourcePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourcePoint(self) -> "IAgCrdnPoint":
        """A source point. Can be any VGT point."""
        return self._intf.get_property(IAgCrdnPointAtTimeInstant._metadata, IAgCrdnPointAtTimeInstant._get_SourcePoint_metadata)

    _set_SourcePoint_metadata = { "name" : "SourcePoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @SourcePoint.setter
    def SourcePoint(self, sourcePoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnPointAtTimeInstant._metadata, IAgCrdnPointAtTimeInstant._set_SourcePoint_metadata, sourcePoint)

    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """A reference system. Can be any VGT system."""
        return self._intf.get_property(IAgCrdnPointAtTimeInstant._metadata, IAgCrdnPointAtTimeInstant._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnPointAtTimeInstant._metadata, IAgCrdnPointAtTimeInstant._set_ReferenceSystem_metadata, referenceSystem)


agcls.AgClassCatalog.add_catalog_entry("{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}", IAgCrdnPointAtTimeInstant)
agcls.AgTypeNameMap["IAgCrdnPointAtTimeInstant"] = IAgCrdnPointAtTimeInstant

class IAgCrdnPointPlugin(object):
    """A VGT point plugin."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ProgID" : 1,
                             "get_DisplayName" : 2,
                             "get_AvailableProperties" : 3,
                             "Reset" : 4,
                             "SetProperty" : 5,
                             "GetProperty" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointPlugin._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointPlugin from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointPlugin.__dict__ and type(IAgCrdnPointPlugin.__dict__[attrname]) == property:
            return IAgCrdnPointPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointPlugin.")
    
    _get_ProgID_metadata = { "name" : "ProgID",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(IAgCrdnPointPlugin._metadata, IAgCrdnPointPlugin._get_ProgID_metadata)

    _get_DisplayName_metadata = { "name" : "DisplayName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(IAgCrdnPointPlugin._metadata, IAgCrdnPointPlugin._get_DisplayName_metadata)

    _get_AvailableProperties_metadata = { "name" : "AvailableProperties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(IAgCrdnPointPlugin._metadata, IAgCrdnPointPlugin._get_AvailableProperties_metadata)

    _Reset_metadata = { "name" : "Reset",
            "arg_types" : (),
            "marshallers" : () }
    def Reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(IAgCrdnPointPlugin._metadata, IAgCrdnPointPlugin._Reset_metadata, )

    _SetProperty_metadata = { "name" : "SetProperty",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(IAgCrdnPointPlugin._metadata, IAgCrdnPointPlugin._SetProperty_metadata, name, value)

    _GetProperty_metadata = { "name" : "GetProperty",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(IAgCrdnPointPlugin._metadata, IAgCrdnPointPlugin._GetProperty_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}", IAgCrdnPointPlugin)
agcls.AgTypeNameMap["IAgCrdnPointPlugin"] = IAgCrdnPointPlugin

class IAgCrdnPointCBFixedOffset(object):
    """Point specified by fixed components with respect to central body."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "set_CentralBody" : 2,
                             "get_ReferenceShape" : 3,
                             "set_ReferenceShape" : 4,
                             "get_Position" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointCBFixedOffset._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointCBFixedOffset from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCBFixedOffset.__dict__ and type(IAgCrdnPointCBFixedOffset.__dict__[attrname]) == property:
            return IAgCrdnPointCBFixedOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointCBFixedOffset.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def CentralBody(self) -> str:
        """Get the central body."""
        return self._intf.get_property(IAgCrdnPointCBFixedOffset._metadata, IAgCrdnPointCBFixedOffset._get_CentralBody_metadata)

    _set_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        return self._intf.set_property(IAgCrdnPointCBFixedOffset._metadata, IAgCrdnPointCBFixedOffset._set_CentralBody_metadata, centralBody)

    _get_ReferenceShape_metadata = { "name" : "ReferenceShape",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnReferenceShapeType),) }
    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Choose the point height's reference. Available options are central body ellipsoid (WSG84), terrain or Mean Sea Level."""
        return self._intf.get_property(IAgCrdnPointCBFixedOffset._metadata, IAgCrdnPointCBFixedOffset._get_ReferenceShape_metadata)

    _set_ReferenceShape_metadata = { "name" : "ReferenceShape",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnReferenceShapeType),) }
    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        return self._intf.set_property(IAgCrdnPointCBFixedOffset._metadata, IAgCrdnPointCBFixedOffset._set_ReferenceShape_metadata, referenceShape)

    _get_Position_metadata = { "name" : "Position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Position(self) -> "IAgPosition":
        """A position of the point fixed on the central body."""
        return self._intf.get_property(IAgCrdnPointCBFixedOffset._metadata, IAgCrdnPointCBFixedOffset._get_Position_metadata)


agcls.AgClassCatalog.add_catalog_entry("{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}", IAgCrdnPointCBFixedOffset)
agcls.AgTypeNameMap["IAgCrdnPointCBFixedOffset"] = IAgCrdnPointCBFixedOffset

class IAgCrdnSystemAssembled(object):
    """A system assembled from an origin point and a set of reference axes."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginPoint" : 1,
                             "get_ReferenceAxes" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemAssembled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemAssembled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemAssembled.__dict__ and type(IAgCrdnSystemAssembled.__dict__[attrname]) == property:
            return IAgCrdnSystemAssembled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemAssembled.")
    
    _get_OriginPoint_metadata = { "name" : "OriginPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginPoint(self) -> "IAgCrdnPointRefTo":
        """Specify a point of origin."""
        return self._intf.get_property(IAgCrdnSystemAssembled._metadata, IAgCrdnSystemAssembled._get_OriginPoint_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnSystemAssembled._metadata, IAgCrdnSystemAssembled._get_ReferenceAxes_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}", IAgCrdnSystemAssembled)
agcls.AgTypeNameMap["IAgCrdnSystemAssembled"] = IAgCrdnSystemAssembled

class IAgCrdnSystemOnSurface(object):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{15798E36-1EC0-4A73-A910-FC28CC404082}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_AzimuthAngle" : 2,
                             "set_AzimuthAngle" : 3,
                             "get_UseMSL" : 4,
                             "set_UseMSL" : 5,
                             "get_Position" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemOnSurface._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemOnSurface from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemOnSurface.__dict__ and type(IAgCrdnSystemOnSurface.__dict__[attrname]) == property:
            return IAgCrdnSystemOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemOnSurface.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnSystemOnSurface._metadata, IAgCrdnSystemOnSurface._get_CentralBody_metadata)

    _get_AzimuthAngle_metadata = { "name" : "AzimuthAngle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def AzimuthAngle(self) -> float:
        """An angle by which the topocentric axes is rotated."""
        return self._intf.get_property(IAgCrdnSystemOnSurface._metadata, IAgCrdnSystemOnSurface._get_AzimuthAngle_metadata)

    _set_AzimuthAngle_metadata = { "name" : "AzimuthAngle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @AzimuthAngle.setter
    def AzimuthAngle(self, azimuthAngle:float) -> None:
        return self._intf.set_property(IAgCrdnSystemOnSurface._metadata, IAgCrdnSystemOnSurface._set_AzimuthAngle_metadata, azimuthAngle)

    _get_UseMSL_metadata = { "name" : "UseMSL",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseMSL(self) -> bool:
        """Specify whether to use the Mean Sea Level as the reference shape."""
        return self._intf.get_property(IAgCrdnSystemOnSurface._metadata, IAgCrdnSystemOnSurface._get_UseMSL_metadata)

    _set_UseMSL_metadata = { "name" : "UseMSL",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        return self._intf.set_property(IAgCrdnSystemOnSurface._metadata, IAgCrdnSystemOnSurface._set_UseMSL_metadata, useMSL)

    _get_Position_metadata = { "name" : "Position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Position(self) -> "IAgCrdnLLAPosition":
        """Specify the position of the system's origin."""
        return self._intf.get_property(IAgCrdnSystemOnSurface._metadata, IAgCrdnSystemOnSurface._get_Position_metadata)


agcls.AgClassCatalog.add_catalog_entry("{15798E36-1EC0-4A73-A910-FC28CC404082}", IAgCrdnSystemOnSurface)
agcls.AgTypeNameMap["IAgCrdnSystemOnSurface"] = IAgCrdnSystemOnSurface

class IAgCrdnLLAPosition(object):
    """A position represented by the Latitude, longtitude and Latitude."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Latitude" : 1,
                             "set_Latitude" : 2,
                             "get_Longitude" : 3,
                             "set_Longitude" : 4,
                             "get_Altitude" : 5,
                             "set_Altitude" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnLLAPosition._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnLLAPosition from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnLLAPosition.__dict__ and type(IAgCrdnLLAPosition.__dict__[attrname]) == property:
            return IAgCrdnLLAPosition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnLLAPosition.")
    
    _get_Latitude_metadata = { "name" : "Latitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Latitude(self) -> float:
        """Specify a latitude angle."""
        return self._intf.get_property(IAgCrdnLLAPosition._metadata, IAgCrdnLLAPosition._get_Latitude_metadata)

    _set_Latitude_metadata = { "name" : "Latitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Latitude.setter
    def Latitude(self, latitude:float) -> None:
        return self._intf.set_property(IAgCrdnLLAPosition._metadata, IAgCrdnLLAPosition._set_Latitude_metadata, latitude)

    _get_Longitude_metadata = { "name" : "Longitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Longitude(self) -> float:
        """Specify a longitude angle."""
        return self._intf.get_property(IAgCrdnLLAPosition._metadata, IAgCrdnLLAPosition._get_Longitude_metadata)

    _set_Longitude_metadata = { "name" : "Longitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Longitude.setter
    def Longitude(self, longitude:float) -> None:
        return self._intf.set_property(IAgCrdnLLAPosition._metadata, IAgCrdnLLAPosition._set_Longitude_metadata, longitude)

    _get_Altitude_metadata = { "name" : "Altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Altitude(self) -> float:
        """Specify an altitude value."""
        return self._intf.get_property(IAgCrdnLLAPosition._metadata, IAgCrdnLLAPosition._get_Altitude_metadata)

    _set_Altitude_metadata = { "name" : "Altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        return self._intf.set_property(IAgCrdnLLAPosition._metadata, IAgCrdnLLAPosition._set_Altitude_metadata, altitude)


agcls.AgClassCatalog.add_catalog_entry("{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}", IAgCrdnLLAPosition)
agcls.AgTypeNameMap["IAgCrdnLLAPosition"] = IAgCrdnLLAPosition

class IAgCrdnSystemCommonTasks(object):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "CreateEastNorthUpCartographic" : 1,
                             "CreateAssembled" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemCommonTasks._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemCommonTasks from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemCommonTasks.__dict__ and type(IAgCrdnSystemCommonTasks.__dict__[attrname]) == property:
            return IAgCrdnSystemCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemCommonTasks.")
    
    _CreateEastNorthUpCartographic_metadata = { "name" : "CreateEastNorthUpCartographic",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def CreateEastNorthUpCartographic(self, latitude:typing.Any, longitude:typing.Any, altitude:float) -> "IAgCrdnSystemAssembled":
        """Creates a non-persistent East-North-Up (ENU) reference frame with the origin at the specified geodetic location."""
        return self._intf.invoke(IAgCrdnSystemCommonTasks._metadata, IAgCrdnSystemCommonTasks._CreateEastNorthUpCartographic_metadata, latitude, longitude, altitude, out_arg())

    _CreateAssembled_metadata = { "name" : "CreateAssembled",
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"), agmarshall.AgInterface_in_arg("IAgCrdnAxes"), agmarshall.AgInterface_out_arg,) }
    def CreateAssembled(self, originPoint:"IAgCrdnPoint", referenceAxes:"IAgCrdnAxes") -> "IAgCrdnSystemAssembled":
        """Creates a non-persistent system component assembled from an origin point and a set of reference axes."""
        return self._intf.invoke(IAgCrdnSystemCommonTasks._metadata, IAgCrdnSystemCommonTasks._CreateAssembled_metadata, originPoint, referenceAxes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}", IAgCrdnSystemCommonTasks)
agcls.AgTypeNameMap["IAgCrdnSystemCommonTasks"] = IAgCrdnSystemCommonTasks

class IAgCrdnVectorAngleRate(object):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFC40EEB-A99F-4DAD-A366-1C7908C15128}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Angle" : 1,
                             "get_DifferencingTimeStep" : 2,
                             "set_DifferencingTimeStep" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorAngleRate._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorAngleRate from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorAngleRate.__dict__ and type(IAgCrdnVectorAngleRate.__dict__[attrname]) == property:
            return IAgCrdnVectorAngleRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorAngleRate.")
    
    _get_Angle_metadata = { "name" : "Angle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Angle(self) -> "IAgCrdnAngleRefTo":
        """Specify an angle. The angle vector will be perpendicular to the plane in which the angle is defined."""
        return self._intf.get_property(IAgCrdnVectorAngleRate._metadata, IAgCrdnVectorAngleRate._get_Angle_metadata)

    _get_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IAgCrdnVectorAngleRate._metadata, IAgCrdnVectorAngleRate._get_DifferencingTimeStep_metadata)

    _set_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnVectorAngleRate._metadata, IAgCrdnVectorAngleRate._set_DifferencingTimeStep_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{CFC40EEB-A99F-4DAD-A366-1C7908C15128}", IAgCrdnVectorAngleRate)
agcls.AgTypeNameMap["IAgCrdnVectorAngleRate"] = IAgCrdnVectorAngleRate

class IAgCrdnVectorApoapsis(object):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A082FC52-1C33-4D63-B02E-1D163FC2F837}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferencePoint" : 1,
                             "get_CentralBody" : 2,
                             "get_MeanElementType" : 3,
                             "set_MeanElementType" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorApoapsis._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorApoapsis from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorApoapsis.__dict__ and type(IAgCrdnVectorApoapsis.__dict__[attrname]) == property:
            return IAgCrdnVectorApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorApoapsis.")
    
    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IAgCrdnVectorApoapsis._metadata, IAgCrdnVectorApoapsis._get_ReferencePoint_metadata)

    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnVectorApoapsis._metadata, IAgCrdnVectorApoapsis._get_CentralBody_metadata)

    _get_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IAgCrdnVectorApoapsis._metadata, IAgCrdnVectorApoapsis._get_MeanElementType_metadata)

    _set_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        return self._intf.set_property(IAgCrdnVectorApoapsis._metadata, IAgCrdnVectorApoapsis._set_MeanElementType_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{A082FC52-1C33-4D63-B02E-1D163FC2F837}", IAgCrdnVectorApoapsis)
agcls.AgTypeNameMap["IAgCrdnVectorApoapsis"] = IAgCrdnVectorApoapsis

class IAgCrdnVectorFixedAtEpoch(object):
    """A vector based on another vector fixed at a specified epoch."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7F816808-CF9D-434A-82CE-78F4A88BC75D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Epoch" : 1,
                             "set_Epoch" : 2,
                             "get_SourceVector" : 3,
                             "get_ReferenceAxes" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorFixedAtEpoch._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorFixedAtEpoch from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFixedAtEpoch.__dict__ and type(IAgCrdnVectorFixedAtEpoch.__dict__[attrname]) == property:
            return IAgCrdnVectorFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorFixedAtEpoch.")
    
    _get_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        return self._intf.get_property(IAgCrdnVectorFixedAtEpoch._metadata, IAgCrdnVectorFixedAtEpoch._get_Epoch_metadata)

    _set_Epoch_metadata = { "name" : "Epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IAgCrdnVectorFixedAtEpoch._metadata, IAgCrdnVectorFixedAtEpoch._set_Epoch_metadata, epoch)

    _get_SourceVector_metadata = { "name" : "SourceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a source vector."""
        return self._intf.get_property(IAgCrdnVectorFixedAtEpoch._metadata, IAgCrdnVectorFixedAtEpoch._get_SourceVector_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnVectorFixedAtEpoch._metadata, IAgCrdnVectorFixedAtEpoch._get_ReferenceAxes_metadata)


agcls.AgClassCatalog.add_catalog_entry("{7F816808-CF9D-434A-82CE-78F4A88BC75D}", IAgCrdnVectorFixedAtEpoch)
agcls.AgTypeNameMap["IAgCrdnVectorFixedAtEpoch"] = IAgCrdnVectorFixedAtEpoch

class IAgCrdnVectorAngularVelocity(object):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Axes" : 1,
                             "get_ReferenceAxes" : 2,
                             "get_DifferencingTimeStep" : 3,
                             "set_DifferencingTimeStep" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorAngularVelocity._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorAngularVelocity from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorAngularVelocity.__dict__ and type(IAgCrdnVectorAngularVelocity.__dict__[attrname]) == property:
            return IAgCrdnVectorAngularVelocity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorAngularVelocity.")
    
    _get_Axes_metadata = { "name" : "Axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Axes(self) -> "IAgCrdnAxesRefTo":
        """Specify the axes."""
        return self._intf.get_property(IAgCrdnVectorAngularVelocity._metadata, IAgCrdnVectorAngularVelocity._get_Axes_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnVectorAngularVelocity._metadata, IAgCrdnVectorAngularVelocity._get_ReferenceAxes_metadata)

    _get_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IAgCrdnVectorAngularVelocity._metadata, IAgCrdnVectorAngularVelocity._get_DifferencingTimeStep_metadata)

    _set_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnVectorAngularVelocity._metadata, IAgCrdnVectorAngularVelocity._set_DifferencingTimeStep_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}", IAgCrdnVectorAngularVelocity)
agcls.AgTypeNameMap["IAgCrdnVectorAngularVelocity"] = IAgCrdnVectorAngularVelocity

class IAgCrdnVectorConing(object):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_AboutVector" : 1,
                             "get_ReferenceVector" : 2,
                             "get_StartClockAngle" : 3,
                             "set_StartClockAngle" : 4,
                             "get_StopClockAngle" : 5,
                             "set_StopClockAngle" : 6,
                             "get_StartEpoch" : 7,
                             "set_StartEpoch" : 8,
                             "get_ClockAngleRate" : 9,
                             "set_ClockAngleRate" : 10,
                             "get_Mode" : 11,
                             "set_Mode" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorConing._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorConing from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorConing.__dict__ and type(IAgCrdnVectorConing.__dict__[attrname]) == property:
            return IAgCrdnVectorConing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorConing.")
    
    _get_AboutVector_metadata = { "name" : "AboutVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AboutVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a vector around which the the reference vector is revolved."""
        return self._intf.get_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._get_AboutVector_metadata)

    _get_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._get_ReferenceVector_metadata)

    _get_StartClockAngle_metadata = { "name" : "StartClockAngle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StartClockAngle(self) -> float:
        """Specify a start angle."""
        return self._intf.get_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._get_StartClockAngle_metadata)

    _set_StartClockAngle_metadata = { "name" : "StartClockAngle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StartClockAngle.setter
    def StartClockAngle(self, startClockAngle:float) -> None:
        return self._intf.set_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._set_StartClockAngle_metadata, startClockAngle)

    _get_StopClockAngle_metadata = { "name" : "StopClockAngle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def StopClockAngle(self) -> float:
        """Specify a stop angle."""
        return self._intf.get_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._get_StopClockAngle_metadata)

    _set_StopClockAngle_metadata = { "name" : "StopClockAngle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @StopClockAngle.setter
    def StopClockAngle(self, stopClockAngle:float) -> None:
        return self._intf.set_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._set_StopClockAngle_metadata, stopClockAngle)

    _get_StartEpoch_metadata = { "name" : "StartEpoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def StartEpoch(self) -> typing.Any:
        """Specify an epoch at which the coning vector is aligned with the reference vector."""
        return self._intf.get_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._get_StartEpoch_metadata)

    _set_StartEpoch_metadata = { "name" : "StartEpoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @StartEpoch.setter
    def StartEpoch(self, startEpoch:typing.Any) -> None:
        return self._intf.set_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._set_StartEpoch_metadata, startEpoch)

    _get_ClockAngleRate_metadata = { "name" : "ClockAngleRate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ClockAngleRate(self) -> float:
        """Specify a rotation rate."""
        return self._intf.get_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._get_ClockAngleRate_metadata)

    _set_ClockAngleRate_metadata = { "name" : "ClockAngleRate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ClockAngleRate.setter
    def ClockAngleRate(self, clockAngleRate:float) -> None:
        return self._intf.set_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._set_ClockAngleRate_metadata, clockAngleRate)

    _get_Mode_metadata = { "name" : "Mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSweepMode),) }
    @property
    def Mode(self) -> "AgECrdnSweepMode":
        """Specify either unidirectional or bidirectional mode."""
        return self._intf.get_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._get_Mode_metadata)

    _set_Mode_metadata = { "name" : "Mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSweepMode),) }
    @Mode.setter
    def Mode(self, mode:"AgECrdnSweepMode") -> None:
        return self._intf.set_property(IAgCrdnVectorConing._metadata, IAgCrdnVectorConing._set_Mode_metadata, mode)


agcls.AgClassCatalog.add_catalog_entry("{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}", IAgCrdnVectorConing)
agcls.AgTypeNameMap["IAgCrdnVectorConing"] = IAgCrdnVectorConing

class IAgCrdnVectorCross(object):
    """The vector cross product of two vectors."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F695FE24-7AE1-4935-837F-D7106A3C99A4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_From" : 1,
                             "get_To" : 2,
                             "get_IsNormalized" : 3,
                             "set_IsNormalized" : 4,
                             "get_Dimension" : 5,
                             "set_Dimension" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorCross._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorCross from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorCross.__dict__ and type(IAgCrdnVectorCross.__dict__[attrname]) == property:
            return IAgCrdnVectorCross.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorCross.")
    
    _get_From_metadata = { "name" : "From",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def From(self) -> "IAgCrdnVectorRefTo":
        """Specify one of the two vectors which define the vector cross product."""
        return self._intf.get_property(IAgCrdnVectorCross._metadata, IAgCrdnVectorCross._get_From_metadata)

    _get_To_metadata = { "name" : "To",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def To(self) -> "IAgCrdnVectorRefTo":
        """Specify the second of the two vectors which define the vector cross product."""
        return self._intf.get_property(IAgCrdnVectorCross._metadata, IAgCrdnVectorCross._get_To_metadata)

    _get_IsNormalized_metadata = { "name" : "IsNormalized",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsNormalized(self) -> bool:
        """Whether to convert the cross product of two vectors to a unit vector."""
        return self._intf.get_property(IAgCrdnVectorCross._metadata, IAgCrdnVectorCross._get_IsNormalized_metadata)

    _set_IsNormalized_metadata = { "name" : "IsNormalized",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorCross._metadata, IAgCrdnVectorCross._set_IsNormalized_metadata, isNormalized)

    _get_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        return self._intf.get_property(IAgCrdnVectorCross._metadata, IAgCrdnVectorCross._get_Dimension_metadata)

    _set_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        return self._intf.set_property(IAgCrdnVectorCross._metadata, IAgCrdnVectorCross._set_Dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{F695FE24-7AE1-4935-837F-D7106A3C99A4}", IAgCrdnVectorCross)
agcls.AgTypeNameMap["IAgCrdnVectorCross"] = IAgCrdnVectorCross

class IAgCrdnVectorCustomScript(object):
    """Customized vector components defined with respect to reference axes."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{66756C64-795C-4E24-9D6A-E560851BBDE0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceAxes" : 1,
                             "get_ScriptFile" : 2,
                             "set_ScriptFile" : 3,
                             "get_InitializationScriptFile" : 4,
                             "set_InitializationScriptFile" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorCustomScript._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorCustomScript from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorCustomScript.__dict__ and type(IAgCrdnVectorCustomScript.__dict__[attrname]) == property:
            return IAgCrdnVectorCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorCustomScript.")
    
    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnVectorCustomScript._metadata, IAgCrdnVectorCustomScript._get_ReferenceAxes_metadata)

    _get_ScriptFile_metadata = { "name" : "ScriptFile",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ScriptFile(self) -> str:
        """Specify a script file."""
        return self._intf.get_property(IAgCrdnVectorCustomScript._metadata, IAgCrdnVectorCustomScript._get_ScriptFile_metadata)

    _set_ScriptFile_metadata = { "name" : "ScriptFile",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @ScriptFile.setter
    def ScriptFile(self, scriptFile:str) -> None:
        return self._intf.set_property(IAgCrdnVectorCustomScript._metadata, IAgCrdnVectorCustomScript._set_ScriptFile_metadata, scriptFile)

    _get_InitializationScriptFile_metadata = { "name" : "InitializationScriptFile",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def InitializationScriptFile(self) -> str:
        """Specify an initialization script file (optional). The initialization script is run once, at the beginning of the calculation."""
        return self._intf.get_property(IAgCrdnVectorCustomScript._metadata, IAgCrdnVectorCustomScript._get_InitializationScriptFile_metadata)

    _set_InitializationScriptFile_metadata = { "name" : "InitializationScriptFile",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @InitializationScriptFile.setter
    def InitializationScriptFile(self, initializationScriptFile:str) -> None:
        return self._intf.set_property(IAgCrdnVectorCustomScript._metadata, IAgCrdnVectorCustomScript._set_InitializationScriptFile_metadata, initializationScriptFile)


agcls.AgClassCatalog.add_catalog_entry("{66756C64-795C-4E24-9D6A-E560851BBDE0}", IAgCrdnVectorCustomScript)
agcls.AgTypeNameMap["IAgCrdnVectorCustomScript"] = IAgCrdnVectorCustomScript

class IAgCrdnVectorDerivative(object):
    """A vector derivative of a vector computed with respect to specified axes."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Vector" : 1,
                             "get_ReferenceAxes" : 2,
                             "get_DifferencingTimeStep" : 3,
                             "set_DifferencingTimeStep" : 4,
                             "get_ForceUseOfNumericalDifferences" : 5,
                             "set_ForceUseOfNumericalDifferences" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorDerivative._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorDerivative from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDerivative.__dict__ and type(IAgCrdnVectorDerivative.__dict__[attrname]) == property:
            return IAgCrdnVectorDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorDerivative.")
    
    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCrdnVectorRefTo":
        """Specify a base vector."""
        return self._intf.get_property(IAgCrdnVectorDerivative._metadata, IAgCrdnVectorDerivative._get_Vector_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnVectorDerivative._metadata, IAgCrdnVectorDerivative._get_ReferenceAxes_metadata)

    _get_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IAgCrdnVectorDerivative._metadata, IAgCrdnVectorDerivative._get_DifferencingTimeStep_metadata)

    _set_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnVectorDerivative._metadata, IAgCrdnVectorDerivative._set_DifferencingTimeStep_metadata, differencingTimeStep)

    _get_ForceUseOfNumericalDifferences_metadata = { "name" : "ForceUseOfNumericalDifferences",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        return self._intf.get_property(IAgCrdnVectorDerivative._metadata, IAgCrdnVectorDerivative._get_ForceUseOfNumericalDifferences_metadata)

    _set_ForceUseOfNumericalDifferences_metadata = { "name" : "ForceUseOfNumericalDifferences",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorDerivative._metadata, IAgCrdnVectorDerivative._set_ForceUseOfNumericalDifferences_metadata, forceUseOfNumericalDifferences)


agcls.AgClassCatalog.add_catalog_entry("{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}", IAgCrdnVectorDerivative)
agcls.AgTypeNameMap["IAgCrdnVectorDerivative"] = IAgCrdnVectorDerivative

class IAgCrdnVectorDisplacement(object):
    """Vector defined by its start and end points."""
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{457E8D69-0F1F-4C02-A9D6-F48F86F63853}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Origin" : 1,
                             "get_Destination" : 2,
                             "get_Apparent" : 3,
                             "set_Apparent" : 4,
                             "get_IgnoreAberration" : 5,
                             "set_IgnoreAberration" : 6,
                             "get_SignalSense" : 7,
                             "set_SignalSense" : 8,
                             "get_ReferenceSystem" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorDisplacement._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorDisplacement from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDisplacement.__dict__ and type(IAgCrdnVectorDisplacement.__dict__[attrname]) == property:
            return IAgCrdnVectorDisplacement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorDisplacement.")
    
    _get_Origin_metadata = { "name" : "Origin",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Origin(self) -> "IAgCrdnPointRefTo":
        """Specify the vector's origin point."""
        return self._intf.get_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._get_Origin_metadata)

    _get_Destination_metadata = { "name" : "Destination",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Destination(self) -> "IAgCrdnPointRefTo":
        """Specify the vector's destination point."""
        return self._intf.get_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._get_Destination_metadata)

    _get_Apparent_metadata = { "name" : "Apparent",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def Apparent(self) -> bool:
        """Controls whether to take a light speed delay into account."""
        return self._intf.get_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._get_Apparent_metadata)

    _set_Apparent_metadata = { "name" : "Apparent",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @Apparent.setter
    def Apparent(self, apparent:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._set_Apparent_metadata, apparent)

    _get_IgnoreAberration_metadata = { "name" : "IgnoreAberration",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IgnoreAberration(self) -> bool:
        """Set to true if you do not want to calculate the aberration correction. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._get_IgnoreAberration_metadata)

    _set_IgnoreAberration_metadata = { "name" : "IgnoreAberration",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IgnoreAberration.setter
    def IgnoreAberration(self, ignoreAberration:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._set_IgnoreAberration_metadata, ignoreAberration)

    _get_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """Specify a sense of signal transmission. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._get_SignalSense_metadata)

    _set_SignalSense_metadata = { "name" : "SignalSense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSignalSense),) }
    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        return self._intf.set_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._set_SignalSense_metadata, signalSense)

    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a frame in which the light time delay is computed. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(IAgCrdnVectorDisplacement._metadata, IAgCrdnVectorDisplacement._get_ReferenceSystem_metadata)


agcls.AgClassCatalog.add_catalog_entry("{457E8D69-0F1F-4C02-A9D6-F48F86F63853}", IAgCrdnVectorDisplacement)
agcls.AgTypeNameMap["IAgCrdnVectorDisplacement"] = IAgCrdnVectorDisplacement

class IAgCrdnVectorTwoPlanesIntersection(object):
    """Defined along the intersection of two planes."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_PlaneA" : 1,
                             "get_PlaneB" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorTwoPlanesIntersection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorTwoPlanesIntersection from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorTwoPlanesIntersection.__dict__ and type(IAgCrdnVectorTwoPlanesIntersection.__dict__[attrname]) == property:
            return IAgCrdnVectorTwoPlanesIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorTwoPlanesIntersection.")
    
    _get_PlaneA_metadata = { "name" : "PlaneA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def PlaneA(self) -> "IAgCrdnPlaneRefTo":
        """Specify the first of the two planes which intersection defines the vector."""
        return self._intf.get_property(IAgCrdnVectorTwoPlanesIntersection._metadata, IAgCrdnVectorTwoPlanesIntersection._get_PlaneA_metadata)

    _get_PlaneB_metadata = { "name" : "PlaneB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def PlaneB(self) -> "IAgCrdnPlaneRefTo":
        """Specify the second of the two planes which intersection defines the vector."""
        return self._intf.get_property(IAgCrdnVectorTwoPlanesIntersection._metadata, IAgCrdnVectorTwoPlanesIntersection._get_PlaneB_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}", IAgCrdnVectorTwoPlanesIntersection)
agcls.AgTypeNameMap["IAgCrdnVectorTwoPlanesIntersection"] = IAgCrdnVectorTwoPlanesIntersection

class IAgCrdnVectorModelAttach(object):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4CCEE5C-B053-413F-8456-6A43720BD314}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_PointableElementName" : 1,
                             "set_PointableElementName" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorModelAttach._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorModelAttach from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorModelAttach.__dict__ and type(IAgCrdnVectorModelAttach.__dict__[attrname]) == property:
            return IAgCrdnVectorModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorModelAttach.")
    
    _get_PointableElementName_metadata = { "name" : "PointableElementName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        return self._intf.get_property(IAgCrdnVectorModelAttach._metadata, IAgCrdnVectorModelAttach._get_PointableElementName_metadata)

    _set_PointableElementName_metadata = { "name" : "PointableElementName",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        return self._intf.set_property(IAgCrdnVectorModelAttach._metadata, IAgCrdnVectorModelAttach._set_PointableElementName_metadata, pointableElementName)


agcls.AgClassCatalog.add_catalog_entry("{C4CCEE5C-B053-413F-8456-6A43720BD314}", IAgCrdnVectorModelAttach)
agcls.AgTypeNameMap["IAgCrdnVectorModelAttach"] = IAgCrdnVectorModelAttach

class IAgCrdnVectorProjection(object):
    """A projection of a vector computed with respect to a reference plane."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2050D921-A98C-408C-8170-FDBB23FEA6E5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Source" : 1,
                             "get_ReferencePlane" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorProjection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorProjection from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorProjection.__dict__ and type(IAgCrdnVectorProjection.__dict__[attrname]) == property:
            return IAgCrdnVectorProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorProjection.")
    
    _get_Source_metadata = { "name" : "Source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Source(self) -> "IAgCrdnVectorRefTo":
        """Specify a source vector."""
        return self._intf.get_property(IAgCrdnVectorProjection._metadata, IAgCrdnVectorProjection._get_Source_metadata)

    _get_ReferencePlane_metadata = { "name" : "ReferencePlane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IAgCrdnVectorProjection._metadata, IAgCrdnVectorProjection._get_ReferencePlane_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2050D921-A98C-408C-8170-FDBB23FEA6E5}", IAgCrdnVectorProjection)
agcls.AgTypeNameMap["IAgCrdnVectorProjection"] = IAgCrdnVectorProjection

class IAgCrdnVectorScaled(object):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7D89412E-17A8-43D2-9153-58F45E7072F6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceVector" : 1,
                             "get_Scale" : 2,
                             "set_Scale" : 3,
                             "get_IsNormalized" : 4,
                             "set_IsNormalized" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorScaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorScaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorScaled.__dict__ and type(IAgCrdnVectorScaled.__dict__[attrname]) == property:
            return IAgCrdnVectorScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorScaled.")
    
    _get_ReferenceVector_metadata = { "name" : "ReferenceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """A vector being scaled."""
        return self._intf.get_property(IAgCrdnVectorScaled._metadata, IAgCrdnVectorScaled._get_ReferenceVector_metadata)

    _get_Scale_metadata = { "name" : "Scale",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def Scale(self) -> float:
        """A scaling multiple."""
        return self._intf.get_property(IAgCrdnVectorScaled._metadata, IAgCrdnVectorScaled._get_Scale_metadata)

    _set_Scale_metadata = { "name" : "Scale",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @Scale.setter
    def Scale(self, scale:float) -> None:
        return self._intf.set_property(IAgCrdnVectorScaled._metadata, IAgCrdnVectorScaled._set_Scale_metadata, scale)

    _get_IsNormalized_metadata = { "name" : "IsNormalized",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsNormalized(self) -> bool:
        """Controls whether to convert the reference vector to a unit vector before scalling."""
        return self._intf.get_property(IAgCrdnVectorScaled._metadata, IAgCrdnVectorScaled._get_IsNormalized_metadata)

    _set_IsNormalized_metadata = { "name" : "IsNormalized",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorScaled._metadata, IAgCrdnVectorScaled._set_IsNormalized_metadata, isNormalized)


agcls.AgClassCatalog.add_catalog_entry("{7D89412E-17A8-43D2-9153-58F45E7072F6}", IAgCrdnVectorScaled)
agcls.AgTypeNameMap["IAgCrdnVectorScaled"] = IAgCrdnVectorScaled

class IAgCrdnVectorEccentricity(object):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2,
                             "get_MeanElementType" : 3,
                             "set_MeanElementType" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorEccentricity._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorEccentricity from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorEccentricity.__dict__ and type(IAgCrdnVectorEccentricity.__dict__[attrname]) == property:
            return IAgCrdnVectorEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorEccentricity.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnVectorEccentricity._metadata, IAgCrdnVectorEccentricity._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IAgCrdnVectorEccentricity._metadata, IAgCrdnVectorEccentricity._get_ReferencePoint_metadata)

    _get_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IAgCrdnVectorEccentricity._metadata, IAgCrdnVectorEccentricity._get_MeanElementType_metadata)

    _set_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        return self._intf.set_property(IAgCrdnVectorEccentricity._metadata, IAgCrdnVectorEccentricity._set_MeanElementType_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}", IAgCrdnVectorEccentricity)
agcls.AgTypeNameMap["IAgCrdnVectorEccentricity"] = IAgCrdnVectorEccentricity

class IAgCrdnVectorFixedInAxes(object):
    """Vector fixed in the reference axes using the selected coordinate type."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{912ECDDB-B23C-4B7A-A173-AC22170DA343}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceAxes" : 1,
                             "get_Direction" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorFixedInAxes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorFixedInAxes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFixedInAxes.__dict__ and type(IAgCrdnVectorFixedInAxes.__dict__[attrname]) == property:
            return IAgCrdnVectorFixedInAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorFixedInAxes.")
    
    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnVectorFixedInAxes._metadata, IAgCrdnVectorFixedInAxes._get_ReferenceAxes_metadata)

    _get_Direction_metadata = { "name" : "Direction",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Direction(self) -> "IAgDirection":
        """Specify the vector direction."""
        return self._intf.get_property(IAgCrdnVectorFixedInAxes._metadata, IAgCrdnVectorFixedInAxes._get_Direction_metadata)


agcls.AgClassCatalog.add_catalog_entry("{912ECDDB-B23C-4B7A-A173-AC22170DA343}", IAgCrdnVectorFixedInAxes)
agcls.AgTypeNameMap["IAgCrdnVectorFixedInAxes"] = IAgCrdnVectorFixedInAxes

class IAgCrdnVectorLineOfNodes(object):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DC23EB21-198C-4E01-9898-D565E937AFF1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorLineOfNodes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorLineOfNodes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorLineOfNodes.__dict__ and type(IAgCrdnVectorLineOfNodes.__dict__[attrname]) == property:
            return IAgCrdnVectorLineOfNodes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorLineOfNodes.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnVectorLineOfNodes._metadata, IAgCrdnVectorLineOfNodes._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IAgCrdnVectorLineOfNodes._metadata, IAgCrdnVectorLineOfNodes._get_ReferencePoint_metadata)


agcls.AgClassCatalog.add_catalog_entry("{DC23EB21-198C-4E01-9898-D565E937AFF1}", IAgCrdnVectorLineOfNodes)
agcls.AgTypeNameMap["IAgCrdnVectorLineOfNodes"] = IAgCrdnVectorLineOfNodes

class IAgCrdnVectorOrbitAngularMomentum(object):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{22C8270A-7B36-40D7-9EC5-44FED3DEE541}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2,
                             "get_MeanElementType" : 3,
                             "set_MeanElementType" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorOrbitAngularMomentum._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorOrbitAngularMomentum from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorOrbitAngularMomentum.__dict__ and type(IAgCrdnVectorOrbitAngularMomentum.__dict__[attrname]) == property:
            return IAgCrdnVectorOrbitAngularMomentum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorOrbitAngularMomentum.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnVectorOrbitAngularMomentum._metadata, IAgCrdnVectorOrbitAngularMomentum._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IAgCrdnVectorOrbitAngularMomentum._metadata, IAgCrdnVectorOrbitAngularMomentum._get_ReferencePoint_metadata)

    _get_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IAgCrdnVectorOrbitAngularMomentum._metadata, IAgCrdnVectorOrbitAngularMomentum._get_MeanElementType_metadata)

    _set_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        return self._intf.set_property(IAgCrdnVectorOrbitAngularMomentum._metadata, IAgCrdnVectorOrbitAngularMomentum._set_MeanElementType_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{22C8270A-7B36-40D7-9EC5-44FED3DEE541}", IAgCrdnVectorOrbitAngularMomentum)
agcls.AgTypeNameMap["IAgCrdnVectorOrbitAngularMomentum"] = IAgCrdnVectorOrbitAngularMomentum

class IAgCrdnVectorOrbitNormal(object):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{296D4695-53FE-40B7-BA3E-41A3C04A805F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2,
                             "get_MeanElementType" : 3,
                             "set_MeanElementType" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorOrbitNormal._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorOrbitNormal from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorOrbitNormal.__dict__ and type(IAgCrdnVectorOrbitNormal.__dict__[attrname]) == property:
            return IAgCrdnVectorOrbitNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorOrbitNormal.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnVectorOrbitNormal._metadata, IAgCrdnVectorOrbitNormal._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IAgCrdnVectorOrbitNormal._metadata, IAgCrdnVectorOrbitNormal._get_ReferencePoint_metadata)

    _get_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IAgCrdnVectorOrbitNormal._metadata, IAgCrdnVectorOrbitNormal._get_MeanElementType_metadata)

    _set_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        return self._intf.set_property(IAgCrdnVectorOrbitNormal._metadata, IAgCrdnVectorOrbitNormal._set_MeanElementType_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{296D4695-53FE-40B7-BA3E-41A3C04A805F}", IAgCrdnVectorOrbitNormal)
agcls.AgTypeNameMap["IAgCrdnVectorOrbitNormal"] = IAgCrdnVectorOrbitNormal

class IAgCrdnVectorPeriapsis(object):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_CentralBody" : 1,
                             "get_ReferencePoint" : 2,
                             "get_MeanElementType" : 3,
                             "set_MeanElementType" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorPeriapsis._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorPeriapsis from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorPeriapsis.__dict__ and type(IAgCrdnVectorPeriapsis.__dict__[attrname]) == property:
            return IAgCrdnVectorPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorPeriapsis.")
    
    _get_CentralBody_metadata = { "name" : "CentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IAgCrdnVectorPeriapsis._metadata, IAgCrdnVectorPeriapsis._get_CentralBody_metadata)

    _get_ReferencePoint_metadata = { "name" : "ReferencePoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IAgCrdnVectorPeriapsis._metadata, IAgCrdnVectorPeriapsis._get_ReferencePoint_metadata)

    _get_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IAgCrdnVectorPeriapsis._metadata, IAgCrdnVectorPeriapsis._get_MeanElementType_metadata)

    _set_MeanElementType_metadata = { "name" : "MeanElementType",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnMeanElementTheory),) }
    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        return self._intf.set_property(IAgCrdnVectorPeriapsis._metadata, IAgCrdnVectorPeriapsis._set_MeanElementType_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}", IAgCrdnVectorPeriapsis)
agcls.AgTypeNameMap["IAgCrdnVectorPeriapsis"] = IAgCrdnVectorPeriapsis

class IAgCrdnVectorReflection(object):
    """A vector (incident vector) reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AF054174-278A-41E6-B8FA-0FC48E19A8BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IncomingVector" : 1,
                             "get_UseOppositeOfSelectedVector" : 2,
                             "set_UseOppositeOfSelectedVector" : 3,
                             "get_NormalVector" : 4,
                             "get_AllowReflectionsOnBackside" : 5,
                             "set_AllowReflectionsOnBackside" : 6,
                             "get_ScaleFactor" : 7,
                             "set_ScaleFactor" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorReflection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorReflection from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorReflection.__dict__ and type(IAgCrdnVectorReflection.__dict__[attrname]) == property:
            return IAgCrdnVectorReflection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorReflection.")
    
    _get_IncomingVector_metadata = { "name" : "IncomingVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def IncomingVector(self) -> "IAgCrdnVectorRefTo":
        """The reflecting vector."""
        return self._intf.get_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._get_IncomingVector_metadata)

    _get_UseOppositeOfSelectedVector_metadata = { "name" : "UseOppositeOfSelectedVector",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseOppositeOfSelectedVector(self) -> bool:
        """When set to false, resets the direction of the Incident Vector to default."""
        return self._intf.get_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._get_UseOppositeOfSelectedVector_metadata)

    _set_UseOppositeOfSelectedVector_metadata = { "name" : "UseOppositeOfSelectedVector",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseOppositeOfSelectedVector.setter
    def UseOppositeOfSelectedVector(self, useOppositeOfSelectedVector:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._set_UseOppositeOfSelectedVector_metadata, useOppositeOfSelectedVector)

    _get_NormalVector_metadata = { "name" : "NormalVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def NormalVector(self) -> "IAgCrdnVectorRefTo":
        """The vector defines the reflection surface."""
        return self._intf.get_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._get_NormalVector_metadata)

    _get_AllowReflectionsOnBackside_metadata = { "name" : "AllowReflectionsOnBackside",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def AllowReflectionsOnBackside(self) -> bool:
        """Controls whether to reflect the indicent vector on both sides of the plane."""
        return self._intf.get_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._get_AllowReflectionsOnBackside_metadata)

    _set_AllowReflectionsOnBackside_metadata = { "name" : "AllowReflectionsOnBackside",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @AllowReflectionsOnBackside.setter
    def AllowReflectionsOnBackside(self, allowReflectionsOnBackside:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._set_AllowReflectionsOnBackside_metadata, allowReflectionsOnBackside)

    _get_ScaleFactor_metadata = { "name" : "ScaleFactor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ScaleFactor(self) -> float:
        """The vector's scale factor."""
        return self._intf.get_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._get_ScaleFactor_metadata)

    _set_ScaleFactor_metadata = { "name" : "ScaleFactor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        return self._intf.set_property(IAgCrdnVectorReflection._metadata, IAgCrdnVectorReflection._set_ScaleFactor_metadata, scaleFactor)


agcls.AgClassCatalog.add_catalog_entry("{AF054174-278A-41E6-B8FA-0FC48E19A8BC}", IAgCrdnVectorReflection)
agcls.AgTypeNameMap["IAgCrdnVectorReflection"] = IAgCrdnVectorReflection

class IAgCrdnVectorRotationVector(object):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2dc152fa-f029-4bc6-bc47-f27d92219a32}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Axes" : 1,
                             "get_ReferenceAxes" : 2,
                             "get_ForceMinimumRotation" : 3,
                             "set_ForceMinimumRotation" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorRotationVector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorRotationVector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorRotationVector.__dict__ and type(IAgCrdnVectorRotationVector.__dict__[attrname]) == property:
            return IAgCrdnVectorRotationVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorRotationVector.")
    
    _get_Axes_metadata = { "name" : "Axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Axes(self) -> "IAgCrdnAxesRefTo":
        """Specify the axes."""
        return self._intf.get_property(IAgCrdnVectorRotationVector._metadata, IAgCrdnVectorRotationVector._get_Axes_metadata)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IAgCrdnVectorRotationVector._metadata, IAgCrdnVectorRotationVector._get_ReferenceAxes_metadata)

    _get_ForceMinimumRotation_metadata = { "name" : "ForceMinimumRotation",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ForceMinimumRotation(self) -> bool:
        """Insures that the rotation angle will be between 0 and pi. If the angle is increasing at pi, then the axis direction will be negated to keep phi less than pi."""
        return self._intf.get_property(IAgCrdnVectorRotationVector._metadata, IAgCrdnVectorRotationVector._get_ForceMinimumRotation_metadata)

    _set_ForceMinimumRotation_metadata = { "name" : "ForceMinimumRotation",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ForceMinimumRotation.setter
    def ForceMinimumRotation(self, forceMinimumRotation:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorRotationVector._metadata, IAgCrdnVectorRotationVector._set_ForceMinimumRotation_metadata, forceMinimumRotation)


agcls.AgClassCatalog.add_catalog_entry("{2dc152fa-f029-4bc6-bc47-f27d92219a32}", IAgCrdnVectorRotationVector)
agcls.AgTypeNameMap["IAgCrdnVectorRotationVector"] = IAgCrdnVectorRotationVector

class IAgCrdnVectorDirectionToStar(object):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SelectedStar" : 1,
                             "set_SelectedStar" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorDirectionToStar._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorDirectionToStar from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDirectionToStar.__dict__ and type(IAgCrdnVectorDirectionToStar.__dict__[attrname]) == property:
            return IAgCrdnVectorDirectionToStar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorDirectionToStar.")
    
    _get_SelectedStar_metadata = { "name" : "SelectedStar",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def SelectedStar(self) -> str:
        """A fully qualified path to a Star object."""
        return self._intf.get_property(IAgCrdnVectorDirectionToStar._metadata, IAgCrdnVectorDirectionToStar._get_SelectedStar_metadata)

    _set_SelectedStar_metadata = { "name" : "SelectedStar",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @SelectedStar.setter
    def SelectedStar(self, selectedStar:str) -> None:
        return self._intf.set_property(IAgCrdnVectorDirectionToStar._metadata, IAgCrdnVectorDirectionToStar._set_SelectedStar_metadata, selectedStar)


agcls.AgClassCatalog.add_catalog_entry("{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}", IAgCrdnVectorDirectionToStar)
agcls.AgTypeNameMap["IAgCrdnVectorDirectionToStar"] = IAgCrdnVectorDirectionToStar

class IAgCrdnVectorFixedAtTimeInstant(object):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B35CE60F-7CC5-4289-9052-2203B609087E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceTimeInstant" : 1,
                             "set_ReferenceTimeInstant" : 2,
                             "get_SourceVector" : 3,
                             "set_SourceVector" : 4,
                             "get_ReferenceAxes" : 5,
                             "set_ReferenceAxes" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorFixedAtTimeInstant._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorFixedAtTimeInstant from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFixedAtTimeInstant.__dict__ and type(IAgCrdnVectorFixedAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnVectorFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorFixedAtTimeInstant.")
    
    _get_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(IAgCrdnVectorFixedAtTimeInstant._metadata, IAgCrdnVectorFixedAtTimeInstant._get_ReferenceTimeInstant_metadata)

    _set_ReferenceTimeInstant_metadata = { "name" : "ReferenceTimeInstant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnEvent"),) }
    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        return self._intf.set_property(IAgCrdnVectorFixedAtTimeInstant._metadata, IAgCrdnVectorFixedAtTimeInstant._set_ReferenceTimeInstant_metadata, referenceTimeInstant)

    _get_SourceVector_metadata = { "name" : "SourceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourceVector(self) -> "IAgCrdnVector":
        """A source vector. Can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorFixedAtTimeInstant._metadata, IAgCrdnVectorFixedAtTimeInstant._get_SourceVector_metadata)

    _set_SourceVector_metadata = { "name" : "SourceVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @SourceVector.setter
    def SourceVector(self, sourceVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorFixedAtTimeInstant._metadata, IAgCrdnVectorFixedAtTimeInstant._set_SourceVector_metadata, sourceVector)

    _get_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """A reference axes. Can be any VGT axes."""
        return self._intf.get_property(IAgCrdnVectorFixedAtTimeInstant._metadata, IAgCrdnVectorFixedAtTimeInstant._get_ReferenceAxes_metadata)

    _set_ReferenceAxes_metadata = { "name" : "ReferenceAxes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnAxes"),) }
    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        return self._intf.set_property(IAgCrdnVectorFixedAtTimeInstant._metadata, IAgCrdnVectorFixedAtTimeInstant._set_ReferenceAxes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{B35CE60F-7CC5-4289-9052-2203B609087E}", IAgCrdnVectorFixedAtTimeInstant)
agcls.AgTypeNameMap["IAgCrdnVectorFixedAtTimeInstant"] = IAgCrdnVectorFixedAtTimeInstant

class IAgCrdnVectorLinearCombination(object):
    """Linear combination of two input vectors."""
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_VectorA" : 1,
                             "set_VectorA" : 2,
                             "get_ScaleFactorA" : 3,
                             "set_ScaleFactorA" : 4,
                             "get_NormalizeVectorA" : 5,
                             "set_NormalizeVectorA" : 6,
                             "get_VectorB" : 7,
                             "set_VectorB" : 8,
                             "get_ScaleFactorB" : 9,
                             "set_ScaleFactorB" : 10,
                             "get_NormalizeVectorB" : 11,
                             "set_NormalizeVectorB" : 12,
                             "get_OutputDimensionInheritance" : 13,
                             "set_OutputDimensionInheritance" : 14,
                             "get_OutputDimension" : 15,
                             "set_OutputDimension" : 16, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorLinearCombination._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorLinearCombination from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorLinearCombination.__dict__ and type(IAgCrdnVectorLinearCombination.__dict__[attrname]) == property:
            return IAgCrdnVectorLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorLinearCombination.")
    
    _get_VectorA_metadata = { "name" : "VectorA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorA(self) -> "IAgCrdnVector":
        """Vector A can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_VectorA_metadata)

    _set_VectorA_metadata = { "name" : "VectorA",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @VectorA.setter
    def VectorA(self, vectorA:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_VectorA_metadata, vectorA)

    _get_ScaleFactorA_metadata = { "name" : "ScaleFactorA",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_ScaleFactorA_metadata)

    _set_ScaleFactorA_metadata = { "name" : "ScaleFactorA",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_ScaleFactorA_metadata, scaleFactorA)

    _get_NormalizeVectorA_metadata = { "name" : "NormalizeVectorA",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_NormalizeVectorA_metadata)

    _set_NormalizeVectorA_metadata = { "name" : "NormalizeVectorA",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_NormalizeVectorA_metadata, normalizeVectorA)

    _get_VectorB_metadata = { "name" : "VectorB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorB(self) -> "IAgCrdnVector":
        """Vector B can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_VectorB_metadata)

    _set_VectorB_metadata = { "name" : "VectorB",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @VectorB.setter
    def VectorB(self, vectorB:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_VectorB_metadata, vectorB)

    _get_ScaleFactorB_metadata = { "name" : "ScaleFactorB",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_ScaleFactorB_metadata)

    _set_ScaleFactorB_metadata = { "name" : "ScaleFactorB",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_ScaleFactorB_metadata, scaleFactorB)

    _get_NormalizeVectorB_metadata = { "name" : "NormalizeVectorB",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_NormalizeVectorB_metadata)

    _set_NormalizeVectorB_metadata = { "name" : "NormalizeVectorB",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_NormalizeVectorB_metadata, normalizeVectorB)

    _get_OutputDimensionInheritance_metadata = { "name" : "OutputDimensionInheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDimensionInheritance),) }
    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_OutputDimensionInheritance_metadata)

    _set_OutputDimensionInheritance_metadata = { "name" : "OutputDimensionInheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDimensionInheritance),) }
    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_OutputDimensionInheritance_metadata, outputDimensionInheritance)

    _get_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        return self._intf.get_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._get_OutputDimension_metadata)

    _set_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        return self._intf.set_property(IAgCrdnVectorLinearCombination._metadata, IAgCrdnVectorLinearCombination._set_OutputDimension_metadata, outputDimension)


agcls.AgClassCatalog.add_catalog_entry("{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}", IAgCrdnVectorLinearCombination)
agcls.AgTypeNameMap["IAgCrdnVectorLinearCombination"] = IAgCrdnVectorLinearCombination

class IAgCrdnVectorProjectAlongVector(object):
    """A projection of a source vector in the direction of another vector."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_SourceVector" : 1,
                             "set_SourceVector" : 2,
                             "get_AlongVector" : 3,
                             "set_AlongVector" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorProjectAlongVector._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorProjectAlongVector from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorProjectAlongVector.__dict__ and type(IAgCrdnVectorProjectAlongVector.__dict__[attrname]) == property:
            return IAgCrdnVectorProjectAlongVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorProjectAlongVector.")
    
    _get_SourceVector_metadata = { "name" : "SourceVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def SourceVector(self) -> "IAgCrdnVector":
        """A source vector. Can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorProjectAlongVector._metadata, IAgCrdnVectorProjectAlongVector._get_SourceVector_metadata)

    _set_SourceVector_metadata = { "name" : "SourceVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @SourceVector.setter
    def SourceVector(self, sourceVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorProjectAlongVector._metadata, IAgCrdnVectorProjectAlongVector._set_SourceVector_metadata, sourceVector)

    _get_AlongVector_metadata = { "name" : "AlongVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AlongVector(self) -> "IAgCrdnVector":
        """A vector along which the source vector is projected. Can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorProjectAlongVector._metadata, IAgCrdnVectorProjectAlongVector._get_AlongVector_metadata)

    _set_AlongVector_metadata = { "name" : "AlongVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @AlongVector.setter
    def AlongVector(self, alongVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorProjectAlongVector._metadata, IAgCrdnVectorProjectAlongVector._set_AlongVector_metadata, alongVector)


agcls.AgClassCatalog.add_catalog_entry("{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}", IAgCrdnVectorProjectAlongVector)
agcls.AgTypeNameMap["IAgCrdnVectorProjectAlongVector"] = IAgCrdnVectorProjectAlongVector

class IAgCrdnVectorScalarLinearCombination(object):
    """Linear combination of two input vectors using scalars."""
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0886A066-8650-4C8D-B234-14D28A175A78}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_VectorA" : 1,
                             "set_VectorA" : 2,
                             "get_ScaleFactorA" : 3,
                             "set_ScaleFactorA" : 4,
                             "get_NormalizeVectorA" : 5,
                             "set_NormalizeVectorA" : 6,
                             "get_UseScaleFromScalarA" : 7,
                             "set_UseScaleFromScalarA" : 8,
                             "get_UseScaleFromScalarB" : 9,
                             "set_UseScaleFromScalarB" : 10,
                             "get_ScalarA" : 11,
                             "set_ScalarA" : 12,
                             "get_ScalarB" : 13,
                             "set_ScalarB" : 14,
                             "get_VectorB" : 15,
                             "set_VectorB" : 16,
                             "get_ScaleFactorB" : 17,
                             "set_ScaleFactorB" : 18,
                             "get_NormalizeVectorB" : 19,
                             "set_NormalizeVectorB" : 20,
                             "get_OutputDimensionInheritance" : 21,
                             "set_OutputDimensionInheritance" : 22,
                             "get_OutputDimension" : 23,
                             "set_OutputDimension" : 24, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorScalarLinearCombination._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorScalarLinearCombination from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorScalarLinearCombination.__dict__ and type(IAgCrdnVectorScalarLinearCombination.__dict__[attrname]) == property:
            return IAgCrdnVectorScalarLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorScalarLinearCombination.")
    
    _get_VectorA_metadata = { "name" : "VectorA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorA(self) -> "IAgCrdnVector":
        """Vector A can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_VectorA_metadata)

    _set_VectorA_metadata = { "name" : "VectorA",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @VectorA.setter
    def VectorA(self, vectorA:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_VectorA_metadata, vectorA)

    _get_ScaleFactorA_metadata = { "name" : "ScaleFactorA",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_ScaleFactorA_metadata)

    _set_ScaleFactorA_metadata = { "name" : "ScaleFactorA",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_ScaleFactorA_metadata, scaleFactorA)

    _get_NormalizeVectorA_metadata = { "name" : "NormalizeVectorA",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_NormalizeVectorA_metadata)

    _set_NormalizeVectorA_metadata = { "name" : "NormalizeVectorA",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_NormalizeVectorA_metadata, normalizeVectorA)

    _get_UseScaleFromScalarA_metadata = { "name" : "UseScaleFromScalarA",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseScaleFromScalarA(self) -> bool:
        """Whether to use a scale from scalar A."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_UseScaleFromScalarA_metadata)

    _set_UseScaleFromScalarA_metadata = { "name" : "UseScaleFromScalarA",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseScaleFromScalarA.setter
    def UseScaleFromScalarA(self, useScaleFromScalarA:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_UseScaleFromScalarA_metadata, useScaleFromScalarA)

    _get_UseScaleFromScalarB_metadata = { "name" : "UseScaleFromScalarB",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def UseScaleFromScalarB(self) -> bool:
        """Whether to use a scale from scalar B."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_UseScaleFromScalarB_metadata)

    _set_UseScaleFromScalarB_metadata = { "name" : "UseScaleFromScalarB",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @UseScaleFromScalarB.setter
    def UseScaleFromScalarB(self, useScaleFromScalarB:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_UseScaleFromScalarB_metadata, useScaleFromScalarB)

    _get_ScalarA_metadata = { "name" : "ScalarA",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ScalarA(self) -> "IAgCrdnCalcScalar":
        """Scalar scale A. Can be any Scalar calculation."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_ScalarA_metadata)

    _set_ScalarA_metadata = { "name" : "ScalarA",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @ScalarA.setter
    def ScalarA(self, scalarA:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_ScalarA_metadata, scalarA)

    _get_ScalarB_metadata = { "name" : "ScalarB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ScalarB(self) -> "IAgCrdnCalcScalar":
        """Scalar scale B. Can be any Scalar calculation."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_ScalarB_metadata)

    _set_ScalarB_metadata = { "name" : "ScalarB",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @ScalarB.setter
    def ScalarB(self, scalarB:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_ScalarB_metadata, scalarB)

    _get_VectorB_metadata = { "name" : "VectorB",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorB(self) -> "IAgCrdnVector":
        """Vector B can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_VectorB_metadata)

    _set_VectorB_metadata = { "name" : "VectorB",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @VectorB.setter
    def VectorB(self, vectorB:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_VectorB_metadata, vectorB)

    _get_ScaleFactorB_metadata = { "name" : "ScaleFactorB",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_ScaleFactorB_metadata)

    _set_ScaleFactorB_metadata = { "name" : "ScaleFactorB",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_ScaleFactorB_metadata, scaleFactorB)

    _get_NormalizeVectorB_metadata = { "name" : "NormalizeVectorB",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_NormalizeVectorB_metadata)

    _set_NormalizeVectorB_metadata = { "name" : "NormalizeVectorB",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_NormalizeVectorB_metadata, normalizeVectorB)

    _get_OutputDimensionInheritance_metadata = { "name" : "OutputDimensionInheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDimensionInheritance),) }
    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_OutputDimensionInheritance_metadata)

    _set_OutputDimensionInheritance_metadata = { "name" : "OutputDimensionInheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnDimensionInheritance),) }
    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_OutputDimensionInheritance_metadata, outputDimensionInheritance)

    _get_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        return self._intf.get_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._get_OutputDimension_metadata)

    _set_OutputDimension_metadata = { "name" : "OutputDimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarLinearCombination._metadata, IAgCrdnVectorScalarLinearCombination._set_OutputDimension_metadata, outputDimension)


agcls.AgClassCatalog.add_catalog_entry("{0886A066-8650-4C8D-B234-14D28A175A78}", IAgCrdnVectorScalarLinearCombination)
agcls.AgTypeNameMap["IAgCrdnVectorScalarLinearCombination"] = IAgCrdnVectorScalarLinearCombination

class IAgCrdnVectorScalarScaled(object):
    """Scaled version of the input vector using scalar."""
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{306C3852-C3E9-43EB-9371-1B9540B52097}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_InputVector" : 1,
                             "set_InputVector" : 2,
                             "get_InputScalar" : 3,
                             "set_InputScalar" : 4,
                             "get_ScaleFactor" : 5,
                             "set_ScaleFactor" : 6,
                             "get_Normalize" : 7,
                             "set_Normalize" : 8,
                             "get_DimensionInheritance" : 9,
                             "set_DimensionInheritance" : 10,
                             "get_Dimension" : 11,
                             "set_Dimension" : 12, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorScalarScaled._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorScalarScaled from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorScalarScaled.__dict__ and type(IAgCrdnVectorScalarScaled.__dict__[attrname]) == property:
            return IAgCrdnVectorScalarScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorScalarScaled.")
    
    _get_InputVector_metadata = { "name" : "InputVector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputVector(self) -> "IAgCrdnVector":
        """An input vector scaled by the scalar. Can be any VGT vector."""
        return self._intf.get_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._get_InputVector_metadata)

    _set_InputVector_metadata = { "name" : "InputVector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnVector"),) }
    @InputVector.setter
    def InputVector(self, inputVector:"IAgCrdnVector") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._set_InputVector_metadata, inputVector)

    _get_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """A variable scale applied to the input vector. Can be based on any Scalar calculation."""
        return self._intf.get_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._get_InputScalar_metadata)

    _set_InputScalar_metadata = { "name" : "InputScalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCalcScalar"),) }
    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._set_InputScalar_metadata, inputScalar)

    _get_ScaleFactor_metadata = { "name" : "ScaleFactor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def ScaleFactor(self) -> float:
        """A constant scale applied to the input vector."""
        return self._intf.get_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._get_ScaleFactor_metadata)

    _set_ScaleFactor_metadata = { "name" : "ScaleFactor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._set_ScaleFactor_metadata, scaleFactor)

    _get_Normalize_metadata = { "name" : "Normalize",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def Normalize(self) -> bool:
        """Whether to normalize the input vector before applying constant and variable scales."""
        return self._intf.get_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._get_Normalize_metadata)

    _set_Normalize_metadata = { "name" : "Normalize",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @Normalize.setter
    def Normalize(self, normalize:bool) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._set_Normalize_metadata, normalize)

    _get_DimensionInheritance_metadata = { "name" : "DimensionInheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance),) }
    @property
    def DimensionInheritance(self) -> "AgECrdnVectorScaledDimensionInheritance":
        """Whether or not to inherit dimension from the input vector or the scalar."""
        return self._intf.get_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._get_DimensionInheritance_metadata)

    _set_DimensionInheritance_metadata = { "name" : "DimensionInheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance),) }
    @DimensionInheritance.setter
    def DimensionInheritance(self, dimensionInheritance:"AgECrdnVectorScaledDimensionInheritance") -> None:
        return self._intf.set_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._set_DimensionInheritance_metadata, dimensionInheritance)

    _get_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Dimension(self) -> str:
        """A dimension assigned to the output vector."""
        return self._intf.get_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._get_Dimension_metadata)

    _set_Dimension_metadata = { "name" : "Dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        return self._intf.set_property(IAgCrdnVectorScalarScaled._metadata, IAgCrdnVectorScalarScaled._set_Dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{306C3852-C3E9-43EB-9371-1B9540B52097}", IAgCrdnVectorScalarScaled)
agcls.AgTypeNameMap["IAgCrdnVectorScalarScaled"] = IAgCrdnVectorScalarScaled

class IAgCrdnVectorVelocityAcceleration(object):
    """Velocity vector of a point in a coordinate system."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ReferenceSystem" : 1,
                             "set_ReferenceSystem" : 2,
                             "get_Point" : 3,
                             "set_Point" : 4,
                             "get_DifferencingTimeStep" : 5,
                             "set_DifferencingTimeStep" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorVelocityAcceleration._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorVelocityAcceleration from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorVelocityAcceleration.__dict__ and type(IAgCrdnVectorVelocityAcceleration.__dict__[attrname]) == property:
            return IAgCrdnVectorVelocityAcceleration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorVelocityAcceleration.")
    
    _get_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """A reference (coordinate) system. Can be any VGT system."""
        return self._intf.get_property(IAgCrdnVectorVelocityAcceleration._metadata, IAgCrdnVectorVelocityAcceleration._get_ReferenceSystem_metadata)

    _set_ReferenceSystem_metadata = { "name" : "ReferenceSystem",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnSystem"),) }
    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        return self._intf.set_property(IAgCrdnVectorVelocityAcceleration._metadata, IAgCrdnVectorVelocityAcceleration._set_ReferenceSystem_metadata, referenceSystem)

    _get_Point_metadata = { "name" : "Point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Point(self) -> "IAgCrdnPoint":
        """A point which velocity this vector represents. Can be any VGT point."""
        return self._intf.get_property(IAgCrdnVectorVelocityAcceleration._metadata, IAgCrdnVectorVelocityAcceleration._get_Point_metadata)

    _set_Point_metadata = { "name" : "Point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @Point.setter
    def Point(self, point:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnVectorVelocityAcceleration._metadata, IAgCrdnVectorVelocityAcceleration._set_Point_metadata, point)

    _get_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IAgCrdnVectorVelocityAcceleration._metadata, IAgCrdnVectorVelocityAcceleration._get_DifferencingTimeStep_metadata)

    _set_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnVectorVelocityAcceleration._metadata, IAgCrdnVectorVelocityAcceleration._set_DifferencingTimeStep_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}", IAgCrdnVectorVelocityAcceleration)
agcls.AgTypeNameMap["IAgCrdnVectorVelocityAcceleration"] = IAgCrdnVectorVelocityAcceleration

class IAgCrdnVectorPlugin(object):
    """A VGT vector plugin."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F889F617-059E-4BC9-9000-206091889FEB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_ProgID" : 1,
                             "get_DisplayName" : 2,
                             "get_AvailableProperties" : 3,
                             "Reset" : 4,
                             "SetProperty" : 5,
                             "GetProperty" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorPlugin._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorPlugin from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorPlugin.__dict__ and type(IAgCrdnVectorPlugin.__dict__[attrname]) == property:
            return IAgCrdnVectorPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorPlugin.")
    
    _get_ProgID_metadata = { "name" : "ProgID",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(IAgCrdnVectorPlugin._metadata, IAgCrdnVectorPlugin._get_ProgID_metadata)

    _get_DisplayName_metadata = { "name" : "DisplayName",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(IAgCrdnVectorPlugin._metadata, IAgCrdnVectorPlugin._get_DisplayName_metadata)

    _get_AvailableProperties_metadata = { "name" : "AvailableProperties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(IAgCrdnVectorPlugin._metadata, IAgCrdnVectorPlugin._get_AvailableProperties_metadata)

    _Reset_metadata = { "name" : "Reset",
            "arg_types" : (),
            "marshallers" : () }
    def Reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(IAgCrdnVectorPlugin._metadata, IAgCrdnVectorPlugin._Reset_metadata, )

    _SetProperty_metadata = { "name" : "SetProperty",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(IAgCrdnVectorPlugin._metadata, IAgCrdnVectorPlugin._SetProperty_metadata, name, value)

    _GetProperty_metadata = { "name" : "GetProperty",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(IAgCrdnVectorPlugin._metadata, IAgCrdnVectorPlugin._GetProperty_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{F889F617-059E-4BC9-9000-206091889FEB}", IAgCrdnVectorPlugin)
agcls.AgTypeNameMap["IAgCrdnVectorPlugin"] = IAgCrdnVectorPlugin

class IAgCrdnVectorDispSurface(object):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_OriginPoint" : 1,
                             "set_OriginPoint" : 2,
                             "get_DestinationPoint" : 3,
                             "set_DestinationPoint" : 4,
                             "get_SurfaceCentralBody" : 5,
                             "set_SurfaceCentralBody" : 6,
                             "get_DifferencingTimeStep" : 7,
                             "set_DifferencingTimeStep" : 8, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorDispSurface._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorDispSurface from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDispSurface.__dict__ and type(IAgCrdnVectorDispSurface.__dict__[attrname]) == property:
            return IAgCrdnVectorDispSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorDispSurface.")
    
    _get_OriginPoint_metadata = { "name" : "OriginPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginPoint(self) -> "IAgCrdnPoint":
        """An origin point."""
        return self._intf.get_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._get_OriginPoint_metadata)

    _set_OriginPoint_metadata = { "name" : "OriginPoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @OriginPoint.setter
    def OriginPoint(self, originPoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._set_OriginPoint_metadata, originPoint)

    _get_DestinationPoint_metadata = { "name" : "DestinationPoint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def DestinationPoint(self) -> "IAgCrdnPoint":
        """Destination point."""
        return self._intf.get_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._get_DestinationPoint_metadata)

    _set_DestinationPoint_metadata = { "name" : "DestinationPoint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnPoint"),) }
    @DestinationPoint.setter
    def DestinationPoint(self, destinationPoint:"IAgCrdnPoint") -> None:
        return self._intf.set_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._set_DestinationPoint_metadata, destinationPoint)

    _get_SurfaceCentralBody_metadata = { "name" : "SurfaceCentralBody",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def SurfaceCentralBody(self) -> str:
        """surface central body."""
        return self._intf.get_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._get_SurfaceCentralBody_metadata)

    _set_SurfaceCentralBody_metadata = { "name" : "SurfaceCentralBody",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        return self._intf.set_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._set_SurfaceCentralBody_metadata, surfaceCentralBody)

    _get_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in displacement on surface vector. (derivatives using central differencing)."""
        return self._intf.get_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._get_DifferencingTimeStep_metadata)

    _set_DifferencingTimeStep_metadata = { "name" : "DifferencingTimeStep",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IAgCrdnVectorDispSurface._metadata, IAgCrdnVectorDispSurface._set_DifferencingTimeStep_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}", IAgCrdnVectorDispSurface)
agcls.AgTypeNameMap["IAgCrdnVectorDispSurface"] = IAgCrdnVectorDispSurface

class IAgCrdnVectorFactory(object):
    """A Factory object to create vectors."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{09F7F253-392A-44D9-9701-51CC0110C033}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "IsTypeSupported" : 2,
                             "CreateDisplacementVector" : 3,
                             "get_AvailableVectorPluginDisplayNames" : 4,
                             "CreateVectorPluginFromDisplayName" : 5,
                             "CreateCrossProductVector" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFactory.__dict__ and type(IAgCrdnVectorFactory.__dict__[attrname]) == property:
            return IAgCrdnVectorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnVectorType), agmarshall.AgInterface_out_arg,) }
    def Create(self, vectorName:str, description:str, vectorType:"AgECrdnVectorType") -> "IAgCrdnVector":
        """Creates a VGT vector using specified name, description and type."""
        return self._intf.invoke(IAgCrdnVectorFactory._metadata, IAgCrdnVectorFactory._Create_metadata, vectorName, description, vectorType, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnVectorType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, type:"AgECrdnVectorType") -> bool:
        """Returns true if the type is supported."""
        return self._intf.invoke(IAgCrdnVectorFactory._metadata, IAgCrdnVectorFactory._IsTypeSupported_metadata, type, out_arg())

    _CreateDisplacementVector_metadata = { "name" : "CreateDisplacementVector",
            "arg_types" : (agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_in_arg("IAgCrdnPoint"), agmarshall.AgInterface_in_arg("IAgCrdnPoint"), agmarshall.AgInterface_out_arg,) }
    def CreateDisplacementVector(self, vectorName:str, originPoint:"IAgCrdnPoint", destPoint:"IAgCrdnPoint") -> "IAgCrdnVectorDisplacement":
        """Creates a displacement vector."""
        return self._intf.invoke(IAgCrdnVectorFactory._metadata, IAgCrdnVectorFactory._CreateDisplacementVector_metadata, vectorName, originPoint, destPoint, out_arg())

    _get_AvailableVectorPluginDisplayNames_metadata = { "name" : "AvailableVectorPluginDisplayNames",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableVectorPluginDisplayNames(self) -> list:
        """An array of display names associated with available vector plugins. The elements of the array are strings. Display names are used to create VGT vectors based on COM plugins using CreateVectorPluginFromDisplayName method."""
        return self._intf.get_property(IAgCrdnVectorFactory._metadata, IAgCrdnVectorFactory._get_AvailableVectorPluginDisplayNames_metadata)

    _CreateVectorPluginFromDisplayName_metadata = { "name" : "CreateVectorPluginFromDisplayName",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateVectorPluginFromDisplayName(self, vectorName:str, description:str, displayName:str) -> "IAgCrdnVector":
        """Create a vector component based on a COM vector plugin. For information how to implement and register VGT plugins, see"""
        return self._intf.invoke(IAgCrdnVectorFactory._metadata, IAgCrdnVectorFactory._CreateVectorPluginFromDisplayName_metadata, vectorName, description, displayName, out_arg())

    _CreateCrossProductVector_metadata = { "name" : "CreateCrossProductVector",
            "arg_types" : (agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_in_arg("IAgCrdnVector"), agmarshall.AgInterface_in_arg("IAgCrdnVector"), agmarshall.AgInterface_out_arg,) }
    def CreateCrossProductVector(self, vectorName:str, vectorA:"IAgCrdnVector", vectorB:"IAgCrdnVector") -> "IAgCrdnVectorCross":
        """Creates a cross product C = A x B."""
        return self._intf.invoke(IAgCrdnVectorFactory._metadata, IAgCrdnVectorFactory._CreateCrossProductVector_metadata, vectorName, vectorA, vectorB, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{09F7F253-392A-44D9-9701-51CC0110C033}", IAgCrdnVectorFactory)
agcls.AgTypeNameMap["IAgCrdnVectorFactory"] = IAgCrdnVectorFactory

class IAgCrdnAxesFactory(object):
    """A Factory object to create axes."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "IsTypeSupported" : 2,
                             "get_AvailableAxesPluginDisplayNames" : 3,
                             "CreateAxesPluginFromDisplayName" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFactory.__dict__ and type(IAgCrdnAxesFactory.__dict__[attrname]) == property:
            return IAgCrdnAxesFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnAxesType), agmarshall.AgInterface_out_arg,) }
    def Create(self, axesName:str, description:str, axesType:"AgECrdnAxesType") -> "IAgCrdnAxes":
        """Creates a VGT axes using specified name, description and type."""
        return self._intf.invoke(IAgCrdnAxesFactory._metadata, IAgCrdnAxesFactory._Create_metadata, axesName, description, axesType, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnAxesType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, type:"AgECrdnAxesType") -> bool:
        """Returns true if the type is supported."""
        return self._intf.invoke(IAgCrdnAxesFactory._metadata, IAgCrdnAxesFactory._IsTypeSupported_metadata, type, out_arg())

    _get_AvailableAxesPluginDisplayNames_metadata = { "name" : "AvailableAxesPluginDisplayNames",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailableAxesPluginDisplayNames(self) -> list:
        """An array of display names associated with available axes plugins. The elements of the array are strings. Display names are used to create VGT axes based on COM plugins using CreateAxesPluginFromDisplayName method."""
        return self._intf.get_property(IAgCrdnAxesFactory._metadata, IAgCrdnAxesFactory._get_AvailableAxesPluginDisplayNames_metadata)

    _CreateAxesPluginFromDisplayName_metadata = { "name" : "CreateAxesPluginFromDisplayName",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreateAxesPluginFromDisplayName(self, axesName:str, description:str, displayName:str) -> "IAgCrdnAxes":
        """Create an axes component based on a COM axes plugin. For information how to implement and register VGT plugins, see"""
        return self._intf.invoke(IAgCrdnAxesFactory._metadata, IAgCrdnAxesFactory._CreateAxesPluginFromDisplayName_metadata, axesName, description, displayName, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}", IAgCrdnAxesFactory)
agcls.AgTypeNameMap["IAgCrdnAxesFactory"] = IAgCrdnAxesFactory

class IAgCrdnSystemFactory(object):
    """A Factory interface to create VGT systems."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "IsTypeSupported" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemFactory.__dict__ and type(IAgCrdnSystemFactory.__dict__[attrname]) == property:
            return IAgCrdnSystemFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnSystemType), agmarshall.AgInterface_out_arg,) }
    def Create(self, systemName:str, description:str, systemType:"AgECrdnSystemType") -> "IAgCrdnSystem":
        """Creates a VGT system using the specified name, description and type."""
        return self._intf.invoke(IAgCrdnSystemFactory._metadata, IAgCrdnSystemFactory._Create_metadata, systemName, description, systemType, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnSystemType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, type:"AgECrdnSystemType") -> bool:
        """Returns true if the specified system type is supported."""
        return self._intf.invoke(IAgCrdnSystemFactory._metadata, IAgCrdnSystemFactory._IsTypeSupported_metadata, type, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}", IAgCrdnSystemFactory)
agcls.AgTypeNameMap["IAgCrdnSystemFactory"] = IAgCrdnSystemFactory

class IAgCrdnPointFactory(object):
    """A Factory object to create points."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18FA11DA-BC93-4467-B53F-4D894739C3A3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "IsTypeSupported" : 2,
                             "get_AvailablePointPluginDisplayNames" : 3,
                             "CreatePointPluginFromDisplayName" : 4,
                             "CreatePointFixedOnCentralBody" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointFactory.__dict__ and type(IAgCrdnPointFactory.__dict__[attrname]) == property:
            return IAgCrdnPointFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnPointType), agmarshall.AgInterface_out_arg,) }
    def Create(self, pointName:str, description:str, pointType:"AgECrdnPointType") -> "IAgCrdnPoint":
        """Creates a VGT point using the specified name, description and type."""
        return self._intf.invoke(IAgCrdnPointFactory._metadata, IAgCrdnPointFactory._Create_metadata, pointName, description, pointType, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPointType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, type:"AgECrdnPointType") -> bool:
        """Returns true if the type is supported."""
        return self._intf.invoke(IAgCrdnPointFactory._metadata, IAgCrdnPointFactory._IsTypeSupported_metadata, type, out_arg())

    _get_AvailablePointPluginDisplayNames_metadata = { "name" : "AvailablePointPluginDisplayNames",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def AvailablePointPluginDisplayNames(self) -> list:
        """An array of display names associated with available point plugins. The elements of the array are strings. Display names are used to create VGT points based on COM plugins using CreatePointPluginFromDisplayName method."""
        return self._intf.get_property(IAgCrdnPointFactory._metadata, IAgCrdnPointFactory._get_AvailablePointPluginDisplayNames_metadata)

    _CreatePointPluginFromDisplayName_metadata = { "name" : "CreatePointPluginFromDisplayName",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def CreatePointPluginFromDisplayName(self, pointName:str, description:str, displayName:str) -> "IAgCrdnPoint":
        """Create a point component based on a COM point plugin. For information how to implement and register VGT plugins, see"""
        return self._intf.invoke(IAgCrdnPointFactory._metadata, IAgCrdnPointFactory._CreatePointPluginFromDisplayName_metadata, pointName, description, displayName, out_arg())

    _CreatePointFixedOnCentralBody_metadata = { "name" : "CreatePointFixedOnCentralBody",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg, agmarshall.AgEnum_arg(AgECrdnReferenceShapeType), agmarshall.AgInterface_out_arg,) }
    def CreatePointFixedOnCentralBody(self, pointName:str, description:str, longitude:typing.Any, latitude:typing.Any, altitude:float, referenceShape:"AgECrdnReferenceShapeType") -> "IAgCrdnPoint":
        """Creates a point fixed on a central body."""
        return self._intf.invoke(IAgCrdnPointFactory._metadata, IAgCrdnPointFactory._CreatePointFixedOnCentralBody_metadata, pointName, description, longitude, latitude, altitude, referenceShape, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{18FA11DA-BC93-4467-B53F-4D894739C3A3}", IAgCrdnPointFactory)
agcls.AgTypeNameMap["IAgCrdnPointFactory"] = IAgCrdnPointFactory

class IAgCrdnPlaneFactory(object):
    """A Factory object to create VGT planes."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "IsTypeSupported" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFactory.__dict__ and type(IAgCrdnPlaneFactory.__dict__[attrname]) == property:
            return IAgCrdnPlaneFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnPlaneType), agmarshall.AgInterface_out_arg,) }
    def Create(self, planeName:str, description:str, planeType:"AgECrdnPlaneType") -> "IAgCrdnPlane":
        """Creates a VGT plane using the specified name, description and type."""
        return self._intf.invoke(IAgCrdnPlaneFactory._metadata, IAgCrdnPlaneFactory._Create_metadata, planeName, description, planeType, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnPlaneType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, type:"AgECrdnPlaneType") -> bool:
        """Returns true if the type is supported."""
        return self._intf.invoke(IAgCrdnPlaneFactory._metadata, IAgCrdnPlaneFactory._IsTypeSupported_metadata, type, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}", IAgCrdnPlaneFactory)
agcls.AgTypeNameMap["IAgCrdnPlaneFactory"] = IAgCrdnPlaneFactory

class IAgCrdnAngleFactory(object):
    """A Factory object to create angles."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{703883F3-9716-4D37-8930-184BECDE1461}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "Create" : 1,
                             "IsTypeSupported" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleFactory._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleFactory from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFactory.__dict__ and type(IAgCrdnAngleFactory.__dict__[attrname]) == property:
            return IAgCrdnAngleFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleFactory.")
    
    _Create_metadata = { "name" : "Create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(AgECrdnAngleType), agmarshall.AgInterface_out_arg,) }
    def Create(self, angleName:str, description:str, angleType:"AgECrdnAngleType") -> "IAgCrdnAngle":
        """Creates a VGT angle using specified name, description and type."""
        return self._intf.invoke(IAgCrdnAngleFactory._metadata, IAgCrdnAngleFactory._Create_metadata, angleName, description, angleType, out_arg())

    _IsTypeSupported_metadata = { "name" : "IsTypeSupported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnAngleType), agmarshall.VARIANT_BOOL_arg,) }
    def IsTypeSupported(self, type:"AgECrdnAngleType") -> bool:
        """Returns true if the type is supported."""
        return self._intf.invoke(IAgCrdnAngleFactory._metadata, IAgCrdnAngleFactory._IsTypeSupported_metadata, type, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{703883F3-9716-4D37-8930-184BECDE1461}", IAgCrdnAngleFactory)
agcls.AgTypeNameMap["IAgCrdnAngleFactory"] = IAgCrdnAngleFactory

class IAgCrdnVectorGroup(object):
    """Access or create VGT vectors associated with an object or a central body."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{4412F0DD-2138-4653-8D20-9B4A0CA450D4}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorGroup.__dict__ and type(IAgCrdnVectorGroup.__dict__[attrname]) == property:
            return IAgCrdnVectorGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnVector":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, vectorName:str) -> None:
        """Removes a specified vector."""
        return self._intf.invoke(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._Remove_metadata, vectorName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnVectorFactory":
        """Returns a Factory object used to create custom vectors."""
        return self._intf.get_property(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVector":
        """Returns a vector by name or at a specified position."""
        return self._intf.invoke(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnVector":
        """Retrieves a vector from the collection by index."""
        return self._intf.invoke(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnVector":
        """Retrieves a vector from the collection by name."""
        return self._intf.invoke(IAgCrdnVectorGroup._metadata, IAgCrdnVectorGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{4412F0DD-2138-4653-8D20-9B4A0CA450D4}", IAgCrdnVectorGroup)
agcls.AgTypeNameMap["IAgCrdnVectorGroup"] = IAgCrdnVectorGroup

class IAgCrdnPointGroup(object):
    """Access or create VGT points associated with an object or a central body."""
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{6FB1415A-EC77-476F-B650-CC6813BE740C}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "get_CommonTasks" : 8,
                             "GetItemByIndex" : 9,
                             "GetItemByName" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointGroup.__dict__ and type(IAgCrdnPointGroup.__dict__[attrname]) == property:
            return IAgCrdnPointGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnPoint":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, pointName:str) -> None:
        """Removes a specified point by name."""
        return self._intf.invoke(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._Remove_metadata, pointName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnPointFactory":
        """Returns a Factory object used to create custom points."""
        return self._intf.get_property(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnPoint":
        """Returns a point by name or at a specified position."""
        return self._intf.invoke(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._get__NewEnum_metadata)

    _get_CommonTasks_metadata = { "name" : "CommonTasks",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CommonTasks(self) -> "IAgCrdnPointCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known point types, etc."""
        return self._intf.get_property(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._get_CommonTasks_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnPoint":
        """Retrieves a point from the collection by index."""
        return self._intf.invoke(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnPoint":
        """Retrieves a point from the collection by name."""
        return self._intf.invoke(IAgCrdnPointGroup._metadata, IAgCrdnPointGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{6FB1415A-EC77-476F-B650-CC6813BE740C}", IAgCrdnPointGroup)
agcls.AgTypeNameMap["IAgCrdnPointGroup"] = IAgCrdnPointGroup

class IAgCrdnAngleGroup(object):
    """Access or create VGT angles associated with an object or a central body."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{C025A1BA-F856-4B26-9134-BBCC785B6C45}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleGroup.__dict__ and type(IAgCrdnAngleGroup.__dict__[attrname]) == property:
            return IAgCrdnAngleGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnAngle":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, angleName:str) -> None:
        """Removes a specified Angle."""
        return self._intf.invoke(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._Remove_metadata, angleName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnAngleFactory":
        """Returns a Factory object used to create custom angles."""
        return self._intf.get_property(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnAngle":
        """Returns an angle by name or at a specified position."""
        return self._intf.invoke(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnAngle":
        """Retrieves an angle from the collection by index."""
        return self._intf.invoke(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnAngle":
        """Retrieves an angle from the collection by name."""
        return self._intf.invoke(IAgCrdnAngleGroup._metadata, IAgCrdnAngleGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{C025A1BA-F856-4B26-9134-BBCC785B6C45}", IAgCrdnAngleGroup)
agcls.AgTypeNameMap["IAgCrdnAngleGroup"] = IAgCrdnAngleGroup

class IAgCrdnAxesGroup(object):
    """Access or create VGT axes associated with an object or a central body."""
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{21C67E72-992F-481F-B77F-1DFC43B4B705}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "get_CommonTasks" : 8,
                             "GetItemByIndex" : 9,
                             "GetItemByName" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesGroup.__dict__ and type(IAgCrdnAxesGroup.__dict__[attrname]) == property:
            return IAgCrdnAxesGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnAxes":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, axesName:str) -> None:
        """Removes a specified Axes."""
        return self._intf.invoke(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._Remove_metadata, axesName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        return self._intf.get_property(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnAxesFactory":
        """Returns a Factory object used to create custom axes."""
        return self._intf.get_property(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnAxes":
        """Returns an axes by name or at a specified position."""
        return self._intf.invoke(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._get__NewEnum_metadata)

    _get_CommonTasks_metadata = { "name" : "CommonTasks",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CommonTasks(self) -> "IAgCrdnAxesCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known axes, etc."""
        return self._intf.get_property(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._get_CommonTasks_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnAxes":
        """Retrieves an axes from the collection by index."""
        return self._intf.invoke(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnAxes":
        """Retrieves an axes from the collection by name."""
        return self._intf.invoke(IAgCrdnAxesGroup._metadata, IAgCrdnAxesGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{21C67E72-992F-481F-B77F-1DFC43B4B705}", IAgCrdnAxesGroup)
agcls.AgTypeNameMap["IAgCrdnAxesGroup"] = IAgCrdnAxesGroup

class IAgCrdnPlaneGroup(object):
    """Represents a single entry point to manipulate VGT Planes associated with an object."""
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "GetItemByIndex" : 8,
                             "GetItemByName" : 9, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneGroup.__dict__ and type(IAgCrdnPlaneGroup.__dict__[attrname]) == property:
            return IAgCrdnPlaneGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnPlane":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, planeName:str) -> None:
        """Removes a specified Plane."""
        return self._intf.invoke(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._Remove_metadata, planeName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        return self._intf.get_property(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnPlaneFactory":
        """Returns a Factory object used to create custom planes."""
        return self._intf.get_property(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnPlane":
        """Returns an Plane by name or at a specified position."""
        return self._intf.invoke(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnPlane":
        """Retrieves a plane from the collection by index."""
        return self._intf.invoke(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnPlane":
        """Retrieves a plane from the collection by name."""
        return self._intf.invoke(IAgCrdnPlaneGroup._metadata, IAgCrdnPlaneGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}", IAgCrdnPlaneGroup)
agcls.AgTypeNameMap["IAgCrdnPlaneGroup"] = IAgCrdnPlaneGroup

class IAgCrdnSystemGroup(object):
    """Access or create VGT systems associated with an object or a central body."""
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{05FF6322-1363-4B66-933E-03EA158B7523}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Remove" : 1,
                             "get_Context" : 2,
                             "Contains" : 3,
                             "get_Count" : 4,
                             "get_Factory" : 5,
                             "Item" : 6,
                             "get__NewEnum" : 7,
                             "get_CommonTasks" : 8,
                             "GetItemByIndex" : 9,
                             "GetItemByName" : 10, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemGroup._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemGroup from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemGroup.__dict__ and type(IAgCrdnSystemGroup.__dict__[attrname]) == property:
            return IAgCrdnSystemGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemGroup.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnSystem":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, systemName:str) -> None:
        """Removes a specified System."""
        return self._intf.invoke(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._Remove_metadata, systemName)

    _get_Context_metadata = { "name" : "Context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._get_Context_metadata)

    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        return self._intf.get_property(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._get_Count_metadata)

    _get_Factory_metadata = { "name" : "Factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Factory(self) -> "IAgCrdnSystemFactory":
        """Returns a Factory object used to create custom VGT systems."""
        return self._intf.get_property(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._get_Factory_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdnSystem":
        """Returns a System by name or at a specified position."""
        return self._intf.invoke(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._get__NewEnum_metadata)

    _get_CommonTasks_metadata = { "name" : "CommonTasks",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CommonTasks(self) -> "IAgCrdnSystemCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known systems, etc."""
        return self._intf.get_property(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._get_CommonTasks_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdnSystem":
        """Retrieves a system from the collection by index."""
        return self._intf.invoke(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdnSystem":
        """Retrieves a system from the collection by name."""
        return self._intf.invoke(IAgCrdnSystemGroup._metadata, IAgCrdnSystemGroup._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{05FF6322-1363-4B66-933E-03EA158B7523}", IAgCrdnSystemGroup)
agcls.AgTypeNameMap["IAgCrdnSystemGroup"] = IAgCrdnSystemGroup

class IAgCrdnProvider(object):
    """Allows accessing existing Vector Geometry Tool components."""
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Vectors" : 1,
                             "get_Points" : 2,
                             "get_Angles" : 3,
                             "get_Axes" : 4,
                             "get_Planes" : 5,
                             "get_Systems" : 6,
                             "get_WellKnownSystems" : 7,
                             "get_WellKnownAxes" : 8,
                             "get_Events" : 9,
                             "get_EventIntervals" : 10,
                             "get_CalcScalars" : 11,
                             "get_EventArrays" : 12,
                             "get_EventIntervalLists" : 13,
                             "get_EventIntervalCollections" : 14,
                             "get_ParameterSets" : 15,
                             "get_Conditions" : 16,
                             "Supports" : 17,
                             "get_ConditionSets" : 18,
                             "Import" : 19,
                             "get_VolumeGrids" : 20,
                             "get_Volumes" : 21,
                             "get_VolumeCalcs" : 22, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnProvider._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnProvider from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnProvider.__dict__ and type(IAgCrdnProvider.__dict__[attrname]) == property:
            return IAgCrdnProvider.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnProvider.")
    
    _get_Vectors_metadata = { "name" : "Vectors",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vectors(self) -> "IAgCrdnVectorGroup":
        """Returns a group of vectors."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Vectors_metadata)

    _get_Points_metadata = { "name" : "Points",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Points(self) -> "IAgCrdnPointGroup":
        """Returns a group of points."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Points_metadata)

    _get_Angles_metadata = { "name" : "Angles",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Angles(self) -> "IAgCrdnAngleGroup":
        """Returns a group of angles."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Angles_metadata)

    _get_Axes_metadata = { "name" : "Axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Axes(self) -> "IAgCrdnAxesGroup":
        """Returns a group of axes."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Axes_metadata)

    _get_Planes_metadata = { "name" : "Planes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Planes(self) -> "IAgCrdnPlaneGroup":
        """Returns a group of planes."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Planes_metadata)

    _get_Systems_metadata = { "name" : "Systems",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Systems(self) -> "IAgCrdnSystemGroup":
        """Returns a group of systems."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Systems_metadata)

    _get_WellKnownSystems_metadata = { "name" : "WellKnownSystems",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def WellKnownSystems(self) -> "IAgCrdnWellKnownSystems":
        """Returns well-known systems."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_WellKnownSystems_metadata)

    _get_WellKnownAxes_metadata = { "name" : "WellKnownAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def WellKnownAxes(self) -> "IAgCrdnWellKnownAxes":
        """Returns well-known axes."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_WellKnownAxes_metadata)

    _get_Events_metadata = { "name" : "Events",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Events(self) -> "IAgCrdnEventGroup":
        """Returns a group of events."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Events_metadata)

    _get_EventIntervals_metadata = { "name" : "EventIntervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def EventIntervals(self) -> "IAgCrdnEventIntervalGroup":
        """Returns a group of event intervals."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_EventIntervals_metadata)

    _get_CalcScalars_metadata = { "name" : "CalcScalars",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def CalcScalars(self) -> "IAgCrdnCalcScalarGroup":
        """Returns a group of calc scalars."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_CalcScalars_metadata)

    _get_EventArrays_metadata = { "name" : "EventArrays",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def EventArrays(self) -> "IAgCrdnEventArrayGroup":
        """Returns a group of event arrays."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_EventArrays_metadata)

    _get_EventIntervalLists_metadata = { "name" : "EventIntervalLists",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def EventIntervalLists(self) -> "IAgCrdnEventIntervalListGroup":
        """Returns a group of event interval lists."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_EventIntervalLists_metadata)

    _get_EventIntervalCollections_metadata = { "name" : "EventIntervalCollections",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def EventIntervalCollections(self) -> "IAgCrdnEventIntervalCollectionGroup":
        """Returns a group of event interval collections."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_EventIntervalCollections_metadata)

    _get_ParameterSets_metadata = { "name" : "ParameterSets",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ParameterSets(self) -> "IAgCrdnParameterSetGroup":
        """Access, add new or remove existing parameter set components."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_ParameterSets_metadata)

    _get_Conditions_metadata = { "name" : "Conditions",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Conditions(self) -> "IAgCrdnConditionGroup":
        """Returns a group of condition objects."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Conditions_metadata)

    _Supports_metadata = { "name" : "Supports",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(AgECrdnKind), agmarshall.VARIANT_BOOL_arg,) }
    def Supports(self, feature:"AgECrdnKind") -> bool:
        """Tests whether the specified VGT feature is supported."""
        return self._intf.invoke(IAgCrdnProvider._metadata, IAgCrdnProvider._Supports_metadata, feature, out_arg())

    _get_ConditionSets_metadata = { "name" : "ConditionSets",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ConditionSets(self) -> "IAgCrdnConditionSetGroup":
        """Returns a group of condition set objects."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_ConditionSets_metadata)

    _Import_metadata = { "name" : "Import",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def Import(self, filename:str) -> "IAgCrdnCollection":
        """Imports Analysis Workbench components from a file."""
        return self._intf.invoke(IAgCrdnProvider._metadata, IAgCrdnProvider._Import_metadata, filename, out_arg())

    _get_VolumeGrids_metadata = { "name" : "VolumeGrids",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VolumeGrids(self) -> "IAgCrdnVolumeGridGroup":
        """Returns a group of volume grid objects."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_VolumeGrids_metadata)

    _get_Volumes_metadata = { "name" : "Volumes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Volumes(self) -> "IAgCrdnVolumeGroup":
        """Returns a group of volume objects."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_Volumes_metadata)

    _get_VolumeCalcs_metadata = { "name" : "VolumeCalcs",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VolumeCalcs(self) -> "IAgCrdnVolumeCalcGroup":
        """Returns a group of volume calc objects."""
        return self._intf.get_property(IAgCrdnProvider._metadata, IAgCrdnProvider._get_VolumeCalcs_metadata)


agcls.AgClassCatalog.add_catalog_entry("{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}", IAgCrdnProvider)
agcls.AgTypeNameMap["IAgCrdnProvider"] = IAgCrdnProvider

class IAgCrdnRoot(object):
    """Represents a VGT root object."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FEF8B20D-5EEB-4299-8775-038EE30AA30B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "GetTemplateProvider" : 1,
                             "GetProvider" : 2,
                             "get_WellKnownSystems" : 3,
                             "get_WellKnownAxes" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnRoot._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnRoot from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnRoot.__dict__ and type(IAgCrdnRoot.__dict__[attrname]) == property:
            return IAgCrdnRoot.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnRoot.")
    
    _GetTemplateProvider_metadata = { "name" : "GetTemplateProvider",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetTemplateProvider(self, className:str) -> "IAgCrdnProvider":
        """Returns a template provider. The method takes a class name (i.e. ``Satellite``, ``Facility``, etc.)"""
        return self._intf.invoke(IAgCrdnRoot._metadata, IAgCrdnRoot._GetTemplateProvider_metadata, className, out_arg())

    _GetProvider_metadata = { "name" : "GetProvider",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetProvider(self, instPath:str) -> "IAgCrdnProvider":
        """Returns an instance provider. The method takes a short instance path to an STK object or a central body.(i.e. ``Satellite/Satellite1``, ``CentralBody/Earth``, etc.)"""
        return self._intf.invoke(IAgCrdnRoot._metadata, IAgCrdnRoot._GetProvider_metadata, instPath, out_arg())

    _get_WellKnownSystems_metadata = { "name" : "WellKnownSystems",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def WellKnownSystems(self) -> "IAgCrdnWellKnownSystems":
        """Returns the most commonly used systems (e.g. Sun Fixed, Earth Fixed, etc.)."""
        return self._intf.get_property(IAgCrdnRoot._metadata, IAgCrdnRoot._get_WellKnownSystems_metadata)

    _get_WellKnownAxes_metadata = { "name" : "WellKnownAxes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def WellKnownAxes(self) -> "IAgCrdnWellKnownAxes":
        """Returns the most commonly used axes (e.g. Sun ICRF, Earth Inertial, etc.)."""
        return self._intf.get_property(IAgCrdnRoot._metadata, IAgCrdnRoot._get_WellKnownAxes_metadata)


agcls.AgClassCatalog.add_catalog_entry("{FEF8B20D-5EEB-4299-8775-038EE30AA30B}", IAgCrdnRoot)
agcls.AgTypeNameMap["IAgCrdnRoot"] = IAgCrdnRoot

class IAgCrdnWellKnownEarthSystems(object):
    """Well-known Earth's coordinate systems."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{230A8949-FB8F-415E-A786-5EED50AEB11B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Fixed" : 1,
                             "get_ICRF" : 2,
                             "get_Inertial" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnWellKnownEarthSystems._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnWellKnownEarthSystems from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownEarthSystems.__dict__ and type(IAgCrdnWellKnownEarthSystems.__dict__[attrname]) == property:
            return IAgCrdnWellKnownEarthSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnWellKnownEarthSystems.")
    
    _get_Fixed_metadata = { "name" : "Fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Fixed(self) -> "IAgCrdnSystem":
        """Earth's Fixed coordinate system."""
        return self._intf.get_property(IAgCrdnWellKnownEarthSystems._metadata, IAgCrdnWellKnownEarthSystems._get_Fixed_metadata)

    _get_ICRF_metadata = { "name" : "ICRF",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ICRF(self) -> "IAgCrdnSystem":
        """Earth's ICRF."""
        return self._intf.get_property(IAgCrdnWellKnownEarthSystems._metadata, IAgCrdnWellKnownEarthSystems._get_ICRF_metadata)

    _get_Inertial_metadata = { "name" : "Inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Inertial(self) -> "IAgCrdnSystem":
        """Earth's Inertial coordinate system (as defined in STK)."""
        return self._intf.get_property(IAgCrdnWellKnownEarthSystems._metadata, IAgCrdnWellKnownEarthSystems._get_Inertial_metadata)


agcls.AgClassCatalog.add_catalog_entry("{230A8949-FB8F-415E-A786-5EED50AEB11B}", IAgCrdnWellKnownEarthSystems)
agcls.AgTypeNameMap["IAgCrdnWellKnownEarthSystems"] = IAgCrdnWellKnownEarthSystems

class IAgCrdnWellKnownEarthAxes(object):
    """Well-known Earth's axes."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Fixed" : 1,
                             "get_ICRF" : 2,
                             "get_Inertial" : 3,
                             "get_J2000" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnWellKnownEarthAxes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnWellKnownEarthAxes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownEarthAxes.__dict__ and type(IAgCrdnWellKnownEarthAxes.__dict__[attrname]) == property:
            return IAgCrdnWellKnownEarthAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnWellKnownEarthAxes.")
    
    _get_Fixed_metadata = { "name" : "Fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Fixed(self) -> "IAgCrdnAxes":
        """Earth's Fixed axes."""
        return self._intf.get_property(IAgCrdnWellKnownEarthAxes._metadata, IAgCrdnWellKnownEarthAxes._get_Fixed_metadata)

    _get_ICRF_metadata = { "name" : "ICRF",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ICRF(self) -> "IAgCrdnAxes":
        """Earth's ICRF axes."""
        return self._intf.get_property(IAgCrdnWellKnownEarthAxes._metadata, IAgCrdnWellKnownEarthAxes._get_ICRF_metadata)

    _get_Inertial_metadata = { "name" : "Inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Inertial(self) -> "IAgCrdnAxes":
        """Earth's Inertial axes (as defined in STK)."""
        return self._intf.get_property(IAgCrdnWellKnownEarthAxes._metadata, IAgCrdnWellKnownEarthAxes._get_Inertial_metadata)

    _get_J2000_metadata = { "name" : "J2000",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def J2000(self) -> "IAgCrdnAxes":
        """The Earth's J2000 axes."""
        return self._intf.get_property(IAgCrdnWellKnownEarthAxes._metadata, IAgCrdnWellKnownEarthAxes._get_J2000_metadata)


agcls.AgClassCatalog.add_catalog_entry("{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}", IAgCrdnWellKnownEarthAxes)
agcls.AgTypeNameMap["IAgCrdnWellKnownEarthAxes"] = IAgCrdnWellKnownEarthAxes

class IAgCrdnWellKnownSunSystems(object):
    """The Sun's well-known coordinate reference systems."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Fixed" : 1,
                             "get_ICRF" : 2,
                             "get_Inertial" : 3,
                             "get_J2000" : 4,
                             "get_Barycenter" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnWellKnownSunSystems._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnWellKnownSunSystems from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownSunSystems.__dict__ and type(IAgCrdnWellKnownSunSystems.__dict__[attrname]) == property:
            return IAgCrdnWellKnownSunSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnWellKnownSunSystems.")
    
    _get_Fixed_metadata = { "name" : "Fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Fixed(self) -> "IAgCrdnSystem":
        """The Sun's Fixed coordinate system."""
        return self._intf.get_property(IAgCrdnWellKnownSunSystems._metadata, IAgCrdnWellKnownSunSystems._get_Fixed_metadata)

    _get_ICRF_metadata = { "name" : "ICRF",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ICRF(self) -> "IAgCrdnSystem":
        """The Sun's International Celestial Reference Frame (ICRF)."""
        return self._intf.get_property(IAgCrdnWellKnownSunSystems._metadata, IAgCrdnWellKnownSunSystems._get_ICRF_metadata)

    _get_Inertial_metadata = { "name" : "Inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Inertial(self) -> "IAgCrdnSystem":
        """The Sun's Inertial coordinate system (as defined in STK)."""
        return self._intf.get_property(IAgCrdnWellKnownSunSystems._metadata, IAgCrdnWellKnownSunSystems._get_Inertial_metadata)

    _get_J2000_metadata = { "name" : "J2000",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def J2000(self) -> "IAgCrdnSystem":
        """The Sun's J2000 coordinate system."""
        return self._intf.get_property(IAgCrdnWellKnownSunSystems._metadata, IAgCrdnWellKnownSunSystems._get_J2000_metadata)

    _get_Barycenter_metadata = { "name" : "Barycenter",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Barycenter(self) -> "IAgCrdnSystem":
        """The Inertial system at the Sun's barycenter."""
        return self._intf.get_property(IAgCrdnWellKnownSunSystems._metadata, IAgCrdnWellKnownSunSystems._get_Barycenter_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}", IAgCrdnWellKnownSunSystems)
agcls.AgTypeNameMap["IAgCrdnWellKnownSunSystems"] = IAgCrdnWellKnownSunSystems

class IAgCrdnWellKnownSunAxes(object):
    """Well-known Sun's axes."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Fixed" : 1,
                             "get_ICRF" : 2,
                             "get_Inertial" : 3,
                             "get_J2000" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnWellKnownSunAxes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnWellKnownSunAxes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownSunAxes.__dict__ and type(IAgCrdnWellKnownSunAxes.__dict__[attrname]) == property:
            return IAgCrdnWellKnownSunAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnWellKnownSunAxes.")
    
    _get_Fixed_metadata = { "name" : "Fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Fixed(self) -> "IAgCrdnAxes":
        """Sun's Fixed axes."""
        return self._intf.get_property(IAgCrdnWellKnownSunAxes._metadata, IAgCrdnWellKnownSunAxes._get_Fixed_metadata)

    _get_ICRF_metadata = { "name" : "ICRF",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def ICRF(self) -> "IAgCrdnAxes":
        """Sun's ICRF."""
        return self._intf.get_property(IAgCrdnWellKnownSunAxes._metadata, IAgCrdnWellKnownSunAxes._get_ICRF_metadata)

    _get_Inertial_metadata = { "name" : "Inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Inertial(self) -> "IAgCrdnAxes":
        """Sun's Inertial axes (as defined in STK)."""
        return self._intf.get_property(IAgCrdnWellKnownSunAxes._metadata, IAgCrdnWellKnownSunAxes._get_Inertial_metadata)

    _get_J2000_metadata = { "name" : "J2000",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def J2000(self) -> "IAgCrdnAxes":
        """The Sun's J2000 axes."""
        return self._intf.get_property(IAgCrdnWellKnownSunAxes._metadata, IAgCrdnWellKnownSunAxes._get_J2000_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}", IAgCrdnWellKnownSunAxes)
agcls.AgTypeNameMap["IAgCrdnWellKnownSunAxes"] = IAgCrdnWellKnownSunAxes

class IAgCrdnWellKnownSystems(object):
    """Well-known coordinate reference systems."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D93C6B6F-D457-4D20-BA7B-960773E3652B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Earth" : 1,
                             "get_Sun" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnWellKnownSystems._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnWellKnownSystems from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownSystems.__dict__ and type(IAgCrdnWellKnownSystems.__dict__[attrname]) == property:
            return IAgCrdnWellKnownSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnWellKnownSystems.")
    
    _get_Earth_metadata = { "name" : "Earth",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Earth(self) -> "IAgCrdnWellKnownEarthSystems":
        """Earth's coordinate reference systems."""
        return self._intf.get_property(IAgCrdnWellKnownSystems._metadata, IAgCrdnWellKnownSystems._get_Earth_metadata)

    _get_Sun_metadata = { "name" : "Sun",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sun(self) -> "IAgCrdnWellKnownSunSystems":
        """The Sun's coordinate reference systems."""
        return self._intf.get_property(IAgCrdnWellKnownSystems._metadata, IAgCrdnWellKnownSystems._get_Sun_metadata)


agcls.AgClassCatalog.add_catalog_entry("{D93C6B6F-D457-4D20-BA7B-960773E3652B}", IAgCrdnWellKnownSystems)
agcls.AgTypeNameMap["IAgCrdnWellKnownSystems"] = IAgCrdnWellKnownSystems

class IAgCrdnWellKnownAxes(object):
    """Well-known Axes."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B2546963-CC14-4F18-91DE-7091EBEA34C5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Earth" : 1,
                             "get_Sun" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnWellKnownAxes._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnWellKnownAxes from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownAxes.__dict__ and type(IAgCrdnWellKnownAxes.__dict__[attrname]) == property:
            return IAgCrdnWellKnownAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnWellKnownAxes.")
    
    _get_Earth_metadata = { "name" : "Earth",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Earth(self) -> "IAgCrdnWellKnownEarthAxes":
        """Earth's well-known axes."""
        return self._intf.get_property(IAgCrdnWellKnownAxes._metadata, IAgCrdnWellKnownAxes._get_Earth_metadata)

    _get_Sun_metadata = { "name" : "Sun",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Sun(self) -> "IAgCrdnWellKnownSunAxes":
        """The Sun's well-known axes."""
        return self._intf.get_property(IAgCrdnWellKnownAxes._metadata, IAgCrdnWellKnownAxes._get_Sun_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B2546963-CC14-4F18-91DE-7091EBEA34C5}", IAgCrdnWellKnownAxes)
agcls.AgTypeNameMap["IAgCrdnWellKnownAxes"] = IAgCrdnWellKnownAxes

class IAgCrdnAngleFindAngleResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngle method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Angle" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleFindAngleResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleFindAngleResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindAngleResult.__dict__ and type(IAgCrdnAngleFindAngleResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindAngleResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleFindAngleResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnAngleFindAngleResult._metadata, IAgCrdnAngleFindAngleResult._get_IsValid_metadata)

    _get_Angle_metadata = { "name" : "Angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IAgCrdnAngleFindAngleResult._metadata, IAgCrdnAngleFindAngleResult._get_Angle_metadata)


agcls.AgClassCatalog.add_catalog_entry("{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}", IAgCrdnAngleFindAngleResult)
agcls.AgTypeNameMap["IAgCrdnAngleFindAngleResult"] = IAgCrdnAngleFindAngleResult

class IAgCrdnAngleFindAngleWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngleWithRate method."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E46570BA-661C-4974-A780-32DFEAFB9630}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Angle" : 2,
                             "get_AngleRate" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleFindAngleWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleFindAngleWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindAngleWithRateResult.__dict__ and type(IAgCrdnAngleFindAngleWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindAngleWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleFindAngleWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnAngleFindAngleWithRateResult._metadata, IAgCrdnAngleFindAngleWithRateResult._get_IsValid_metadata)

    _get_Angle_metadata = { "name" : "Angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IAgCrdnAngleFindAngleWithRateResult._metadata, IAgCrdnAngleFindAngleWithRateResult._get_Angle_metadata)

    _get_AngleRate_metadata = { "name" : "AngleRate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        return self._intf.get_property(IAgCrdnAngleFindAngleWithRateResult._metadata, IAgCrdnAngleFindAngleWithRateResult._get_AngleRate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{E46570BA-661C-4974-A780-32DFEAFB9630}", IAgCrdnAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["IAgCrdnAngleFindAngleWithRateResult"] = IAgCrdnAngleFindAngleWithRateResult

class IAgCrdnAngleFindWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinatesWithRate method."""
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4E80CE7-2E38-4364-96D5-004EE425471D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Angle" : 2,
                             "get_AngleRate" : 3,
                             "get_VectorFrom" : 4,
                             "get_VectorTo" : 5,
                             "get_VectorAbout" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleFindWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleFindWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindWithRateResult.__dict__ and type(IAgCrdnAngleFindWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleFindWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnAngleFindWithRateResult._metadata, IAgCrdnAngleFindWithRateResult._get_IsValid_metadata)

    _get_Angle_metadata = { "name" : "Angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IAgCrdnAngleFindWithRateResult._metadata, IAgCrdnAngleFindWithRateResult._get_Angle_metadata)

    _get_AngleRate_metadata = { "name" : "AngleRate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        return self._intf.get_property(IAgCrdnAngleFindWithRateResult._metadata, IAgCrdnAngleFindWithRateResult._get_AngleRate_metadata)

    _get_VectorFrom_metadata = { "name" : "VectorFrom",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorFrom(self) -> "IAgCartesian3Vector":
        """The first of the two vectors the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleFindWithRateResult._metadata, IAgCrdnAngleFindWithRateResult._get_VectorFrom_metadata)

    _get_VectorTo_metadata = { "name" : "VectorTo",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorTo(self) -> "IAgCartesian3Vector":
        """The second of the two vectors the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleFindWithRateResult._metadata, IAgCrdnAngleFindWithRateResult._get_VectorTo_metadata)

    _get_VectorAbout_metadata = { "name" : "VectorAbout",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorAbout(self) -> "IAgCartesian3Vector":
        """The vector the angle is rotated about."""
        return self._intf.get_property(IAgCrdnAngleFindWithRateResult._metadata, IAgCrdnAngleFindWithRateResult._get_VectorAbout_metadata)


agcls.AgClassCatalog.add_catalog_entry("{C4E80CE7-2E38-4364-96D5-004EE425471D}", IAgCrdnAngleFindWithRateResult)
agcls.AgTypeNameMap["IAgCrdnAngleFindWithRateResult"] = IAgCrdnAngleFindWithRateResult

class IAgCrdnAngleFindResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinates method."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{36DD880D-214E-4987-A70A-EA31E7E26B84}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Angle" : 2,
                             "get_VectorFrom" : 3,
                             "get_VectorTo" : 4,
                             "get_VectorAbout" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAngleFindResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAngleFindResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindResult.__dict__ and type(IAgCrdnAngleFindResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAngleFindResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnAngleFindResult._metadata, IAgCrdnAngleFindResult._get_IsValid_metadata)

    _get_Angle_metadata = { "name" : "Angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IAgCrdnAngleFindResult._metadata, IAgCrdnAngleFindResult._get_Angle_metadata)

    _get_VectorFrom_metadata = { "name" : "VectorFrom",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorFrom(self) -> "IAgCartesian3Vector":
        """The first of the two vectors the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleFindResult._metadata, IAgCrdnAngleFindResult._get_VectorFrom_metadata)

    _get_VectorTo_metadata = { "name" : "VectorTo",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorTo(self) -> "IAgCartesian3Vector":
        """The second of the two vectors the angle is measured."""
        return self._intf.get_property(IAgCrdnAngleFindResult._metadata, IAgCrdnAngleFindResult._get_VectorTo_metadata)

    _get_VectorAbout_metadata = { "name" : "VectorAbout",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def VectorAbout(self) -> "IAgCartesian3Vector":
        """The vector the angle is rotated about."""
        return self._intf.get_property(IAgCrdnAngleFindResult._metadata, IAgCrdnAngleFindResult._get_VectorAbout_metadata)


agcls.AgClassCatalog.add_catalog_entry("{36DD880D-214E-4987-A70A-EA31E7E26B84}", IAgCrdnAngleFindResult)
agcls.AgTypeNameMap["IAgCrdnAngleFindResult"] = IAgCrdnAngleFindResult

class IAgCrdnAxesTransformResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFrom method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D4EC98BE-0D20-4284-96D0-3C40A3100A06}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesTransformResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesTransformResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesTransformResult.__dict__ and type(IAgCrdnAxesTransformResult.__dict__[attrname]) == property:
            return IAgCrdnAxesTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesTransformResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnAxesTransformResult._metadata, IAgCrdnAxesTransformResult._get_IsValid_metadata)

    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The output vector in the current axes."""
        return self._intf.get_property(IAgCrdnAxesTransformResult._metadata, IAgCrdnAxesTransformResult._get_Vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{D4EC98BE-0D20-4284-96D0-3C40A3100A06}", IAgCrdnAxesTransformResult)
agcls.AgTypeNameMap["IAgCrdnAxesTransformResult"] = IAgCrdnAxesTransformResult

class IAgCrdnAxesTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFromWithRate method."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6434061B-3584-49FF-99C5-2C2D6B385CF1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Vector" : 2,
                             "get_Velocity" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesTransformWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesTransformWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesTransformWithRateResult.__dict__ and type(IAgCrdnAxesTransformWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAxesTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesTransformWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnAxesTransformWithRateResult._metadata, IAgCrdnAxesTransformWithRateResult._get_IsValid_metadata)

    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The output vector in the current axes."""
        return self._intf.get_property(IAgCrdnAxesTransformWithRateResult._metadata, IAgCrdnAxesTransformWithRateResult._get_Vector_metadata)

    _get_Velocity_metadata = { "name" : "Velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """The vector velocity."""
        return self._intf.get_property(IAgCrdnAxesTransformWithRateResult._metadata, IAgCrdnAxesTransformWithRateResult._get_Velocity_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6434061B-3584-49FF-99C5-2C2D6B385CF1}", IAgCrdnAxesTransformWithRateResult)
agcls.AgTypeNameMap["IAgCrdnAxesTransformWithRateResult"] = IAgCrdnAxesTransformWithRateResult

class IAgCrdnPlaneFindInAxesResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxes method."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_XAxis" : 2,
                             "get_YAxis" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneFindInAxesResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneFindInAxesResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInAxesResult.__dict__ and type(IAgCrdnPlaneFindInAxesResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneFindInAxesResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesResult._metadata, IAgCrdnPlaneFindInAxesResult._get_IsValid_metadata)

    _get_XAxis_metadata = { "name" : "XAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference axes."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesResult._metadata, IAgCrdnPlaneFindInAxesResult._get_XAxis_metadata)

    _get_YAxis_metadata = { "name" : "YAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesResult._metadata, IAgCrdnPlaneFindInAxesResult._get_YAxis_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}", IAgCrdnPlaneFindInAxesResult)
agcls.AgTypeNameMap["IAgCrdnPlaneFindInAxesResult"] = IAgCrdnPlaneFindInAxesResult

class IAgCrdnPlaneFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxesWithRate method."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CD4424A8-28CF-4AE5-8242-480B6625F0EB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_XAxis" : 2,
                             "get_XAxisRate" : 3,
                             "get_YAxis" : 4,
                             "get_YAxisRate" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneFindInAxesWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneFindInAxesWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInAxesWithRateResult.__dict__ and type(IAgCrdnPlaneFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneFindInAxesWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesWithRateResult._metadata, IAgCrdnPlaneFindInAxesWithRateResult._get_IsValid_metadata)

    _get_XAxis_metadata = { "name" : "XAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference axes."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesWithRateResult._metadata, IAgCrdnPlaneFindInAxesWithRateResult._get_XAxis_metadata)

    _get_XAxisRate_metadata = { "name" : "XAxisRate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def XAxisRate(self) -> "IAgCartesian3Vector":
        """The rate of change of X-axis vector in the specified reference axes."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesWithRateResult._metadata, IAgCrdnPlaneFindInAxesWithRateResult._get_XAxisRate_metadata)

    _get_YAxis_metadata = { "name" : "YAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesWithRateResult._metadata, IAgCrdnPlaneFindInAxesWithRateResult._get_YAxis_metadata)

    _get_YAxisRate_metadata = { "name" : "YAxisRate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def YAxisRate(self) -> "IAgCartesian3Vector":
        """The rate of change of Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IAgCrdnPlaneFindInAxesWithRateResult._metadata, IAgCrdnPlaneFindInAxesWithRateResult._get_YAxisRate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{CD4424A8-28CF-4AE5-8242-480B6625F0EB}", IAgCrdnPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["IAgCrdnPlaneFindInAxesWithRateResult"] = IAgCrdnPlaneFindInAxesWithRateResult

class IAgCrdnPlaneFindInSystemResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystem method."""
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{85D16885-3BEB-4590-963B-F1CC8D016097}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_OriginPosition" : 2,
                             "get_XAxis" : 3,
                             "get_YAxis" : 4, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneFindInSystemResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneFindInSystemResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInSystemResult.__dict__ and type(IAgCrdnPlaneFindInSystemResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneFindInSystemResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemResult._metadata, IAgCrdnPlaneFindInSystemResult._get_IsValid_metadata)

    _get_OriginPosition_metadata = { "name" : "OriginPosition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginPosition(self) -> "IAgCartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemResult._metadata, IAgCrdnPlaneFindInSystemResult._get_OriginPosition_metadata)

    _get_XAxis_metadata = { "name" : "XAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemResult._metadata, IAgCrdnPlaneFindInSystemResult._get_XAxis_metadata)

    _get_YAxis_metadata = { "name" : "YAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemResult._metadata, IAgCrdnPlaneFindInSystemResult._get_YAxis_metadata)


agcls.AgClassCatalog.add_catalog_entry("{85D16885-3BEB-4590-963B-F1CC8D016097}", IAgCrdnPlaneFindInSystemResult)
agcls.AgTypeNameMap["IAgCrdnPlaneFindInSystemResult"] = IAgCrdnPlaneFindInSystemResult

class IAgCrdnPlaneFindInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystemWithRate method."""
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{888499CB-4BF7-46A6-A11B-3FFC05EA6804}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_OriginPosition" : 2,
                             "get_OriginVelocity" : 3,
                             "get_XAxis" : 4,
                             "get_XAxisRate" : 5,
                             "get_YAxis" : 6,
                             "get_YAxisRate" : 7, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPlaneFindInSystemWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPlaneFindInSystemWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInSystemWithRateResult.__dict__ and type(IAgCrdnPlaneFindInSystemWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPlaneFindInSystemWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemWithRateResult._metadata, IAgCrdnPlaneFindInSystemWithRateResult._get_IsValid_metadata)

    _get_OriginPosition_metadata = { "name" : "OriginPosition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginPosition(self) -> "IAgCartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemWithRateResult._metadata, IAgCrdnPlaneFindInSystemWithRateResult._get_OriginPosition_metadata)

    _get_OriginVelocity_metadata = { "name" : "OriginVelocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def OriginVelocity(self) -> "IAgCartesian3Vector":
        """The rate of change of the position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemWithRateResult._metadata, IAgCrdnPlaneFindInSystemWithRateResult._get_OriginVelocity_metadata)

    _get_XAxis_metadata = { "name" : "XAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemWithRateResult._metadata, IAgCrdnPlaneFindInSystemWithRateResult._get_XAxis_metadata)

    _get_XAxisRate_metadata = { "name" : "XAxisRate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def XAxisRate(self) -> "IAgCartesian3Vector":
        """A rate of change of the X-axis vector in the specified reference system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemWithRateResult._metadata, IAgCrdnPlaneFindInSystemWithRateResult._get_XAxisRate_metadata)

    _get_YAxis_metadata = { "name" : "YAxis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemWithRateResult._metadata, IAgCrdnPlaneFindInSystemWithRateResult._get_YAxis_metadata)

    _get_YAxisRate_metadata = { "name" : "YAxisRate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def YAxisRate(self) -> "IAgCartesian3Vector":
        """A rate of change of the Y-axis vector in the specified reference system."""
        return self._intf.get_property(IAgCrdnPlaneFindInSystemWithRateResult._metadata, IAgCrdnPlaneFindInSystemWithRateResult._get_YAxisRate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{888499CB-4BF7-46A6-A11B-3FFC05EA6804}", IAgCrdnPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["IAgCrdnPlaneFindInSystemWithRateResult"] = IAgCrdnPlaneFindInSystemWithRateResult

class IAgCrdnAxesFindInAxesResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxes method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Orientation" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesFindInAxesResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesFindInAxesResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFindInAxesResult.__dict__ and type(IAgCrdnAxesFindInAxesResult.__dict__[attrname]) == property:
            return IAgCrdnAxesFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesFindInAxesResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnAxesFindInAxesResult._metadata, IAgCrdnAxesFindInAxesResult._get_IsValid_metadata)

    _get_Orientation_metadata = { "name" : "Orientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Orientation(self) -> "IAgOrientation":
        """The axes' orientation."""
        return self._intf.get_property(IAgCrdnAxesFindInAxesResult._metadata, IAgCrdnAxesFindInAxesResult._get_Orientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}", IAgCrdnAxesFindInAxesResult)
agcls.AgTypeNameMap["IAgCrdnAxesFindInAxesResult"] = IAgCrdnAxesFindInAxesResult

class IAgCrdnAxesFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxesWithRate method."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{72644DD0-D129-4D7A-8A81-586E86E639BD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_AngularVelocity" : 2,
                             "get_Orientation" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesFindInAxesWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesFindInAxesWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFindInAxesWithRateResult.__dict__ and type(IAgCrdnAxesFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAxesFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesFindInAxesWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnAxesFindInAxesWithRateResult._metadata, IAgCrdnAxesFindInAxesWithRateResult._get_IsValid_metadata)

    _get_AngularVelocity_metadata = { "name" : "AngularVelocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def AngularVelocity(self) -> "IAgCartesian3Vector":
        """Axes' angular velocity."""
        return self._intf.get_property(IAgCrdnAxesFindInAxesWithRateResult._metadata, IAgCrdnAxesFindInAxesWithRateResult._get_AngularVelocity_metadata)

    _get_Orientation_metadata = { "name" : "Orientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Orientation(self) -> "IAgOrientation":
        """The axes' orientation."""
        return self._intf.get_property(IAgCrdnAxesFindInAxesWithRateResult._metadata, IAgCrdnAxesFindInAxesWithRateResult._get_Orientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{72644DD0-D129-4D7A-8A81-586E86E639BD}", IAgCrdnAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["IAgCrdnAxesFindInAxesWithRateResult"] = IAgCrdnAxesFindInAxesWithRateResult

class IAgCrdnPointLocateInSystemResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystem method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{84453DEC-5D01-4D47-A177-F8A737F0496D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Position" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointLocateInSystemResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointLocateInSystemResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointLocateInSystemResult.__dict__ and type(IAgCrdnPointLocateInSystemResult.__dict__[attrname]) == property:
            return IAgCrdnPointLocateInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointLocateInSystemResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnPointLocateInSystemResult._metadata, IAgCrdnPointLocateInSystemResult._get_IsValid_metadata)

    _get_Position_metadata = { "name" : "Position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Position(self) -> "IAgCartesian3Vector":
        """The point position in the specified coordinate system."""
        return self._intf.get_property(IAgCrdnPointLocateInSystemResult._metadata, IAgCrdnPointLocateInSystemResult._get_Position_metadata)


agcls.AgClassCatalog.add_catalog_entry("{84453DEC-5D01-4D47-A177-F8A737F0496D}", IAgCrdnPointLocateInSystemResult)
agcls.AgTypeNameMap["IAgCrdnPointLocateInSystemResult"] = IAgCrdnPointLocateInSystemResult

class IAgCrdnPointLocateInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystemWithRate method."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Position" : 2,
                             "get_Velocity" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointLocateInSystemWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointLocateInSystemWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointLocateInSystemWithRateResult.__dict__ and type(IAgCrdnPointLocateInSystemWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnPointLocateInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointLocateInSystemWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnPointLocateInSystemWithRateResult._metadata, IAgCrdnPointLocateInSystemWithRateResult._get_IsValid_metadata)

    _get_Position_metadata = { "name" : "Position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Position(self) -> "IAgCartesian3Vector":
        """The point position in the specified coordinate system."""
        return self._intf.get_property(IAgCrdnPointLocateInSystemWithRateResult._metadata, IAgCrdnPointLocateInSystemWithRateResult._get_Position_metadata)

    _get_Velocity_metadata = { "name" : "Velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """The point velocity in the specified coordinate system."""
        return self._intf.get_property(IAgCrdnPointLocateInSystemWithRateResult._metadata, IAgCrdnPointLocateInSystemWithRateResult._get_Velocity_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}", IAgCrdnPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["IAgCrdnPointLocateInSystemWithRateResult"] = IAgCrdnPointLocateInSystemWithRateResult

class IAgCrdnSystemTransformResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFrom and IAgCrdnSystem.TransformTo methods."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemTransformResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemTransformResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemTransformResult.__dict__ and type(IAgCrdnSystemTransformResult.__dict__[attrname]) == property:
            return IAgCrdnSystemTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemTransformResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnSystemTransformResult._metadata, IAgCrdnSystemTransformResult._get_IsValid_metadata)

    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The transformed vector."""
        return self._intf.get_property(IAgCrdnSystemTransformResult._metadata, IAgCrdnSystemTransformResult._get_Vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}", IAgCrdnSystemTransformResult)
agcls.AgTypeNameMap["IAgCrdnSystemTransformResult"] = IAgCrdnSystemTransformResult

class IAgCrdnSystemTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFromWithRate and IAgCrdnSystem.TransformToWithRate methods."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A9E92350-230F-45C7-A617-DB684FF89C78}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Vector" : 2,
                             "get_Velocity" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemTransformWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemTransformWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemTransformWithRateResult.__dict__ and type(IAgCrdnSystemTransformWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnSystemTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemTransformWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnSystemTransformWithRateResult._metadata, IAgCrdnSystemTransformWithRateResult._get_IsValid_metadata)

    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The transformed vector."""
        return self._intf.get_property(IAgCrdnSystemTransformWithRateResult._metadata, IAgCrdnSystemTransformWithRateResult._get_Vector_metadata)

    _get_Velocity_metadata = { "name" : "Velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """The vector's velocity."""
        return self._intf.get_property(IAgCrdnSystemTransformWithRateResult._metadata, IAgCrdnSystemTransformWithRateResult._get_Velocity_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A9E92350-230F-45C7-A617-DB684FF89C78}", IAgCrdnSystemTransformWithRateResult)
agcls.AgTypeNameMap["IAgCrdnSystemTransformWithRateResult"] = IAgCrdnSystemTransformWithRateResult

class IAgCrdnSystemFindInSystemResult(object):
    """Contains the results returned with IAgCrdnSystem.FindInSystem method."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Position" : 2,
                             "get_Velocity" : 3,
                             "get_Rate" : 4,
                             "get_Orientation" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnSystemFindInSystemResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnSystemFindInSystemResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemFindInSystemResult.__dict__ and type(IAgCrdnSystemFindInSystemResult.__dict__[attrname]) == property:
            return IAgCrdnSystemFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnSystemFindInSystemResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnSystemFindInSystemResult._metadata, IAgCrdnSystemFindInSystemResult._get_IsValid_metadata)

    _get_Position_metadata = { "name" : "Position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Position(self) -> "IAgCartesian3Vector":
        """A position vector."""
        return self._intf.get_property(IAgCrdnSystemFindInSystemResult._metadata, IAgCrdnSystemFindInSystemResult._get_Position_metadata)

    _get_Velocity_metadata = { "name" : "Velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """A velocity vector."""
        return self._intf.get_property(IAgCrdnSystemFindInSystemResult._metadata, IAgCrdnSystemFindInSystemResult._get_Velocity_metadata)

    _get_Rate_metadata = { "name" : "Rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Rate(self) -> "IAgCartesian3Vector":
        """Rate of change."""
        return self._intf.get_property(IAgCrdnSystemFindInSystemResult._metadata, IAgCrdnSystemFindInSystemResult._get_Rate_metadata)

    _get_Orientation_metadata = { "name" : "Orientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Orientation(self) -> "IAgOrientation":
        """Orientation."""
        return self._intf.get_property(IAgCrdnSystemFindInSystemResult._metadata, IAgCrdnSystemFindInSystemResult._get_Orientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}", IAgCrdnSystemFindInSystemResult)
agcls.AgTypeNameMap["IAgCrdnSystemFindInSystemResult"] = IAgCrdnSystemFindInSystemResult

class IAgCrdnVectorFindInAxesResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxes method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorFindInAxesResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorFindInAxesResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFindInAxesResult.__dict__ and type(IAgCrdnVectorFindInAxesResult.__dict__[attrname]) == property:
            return IAgCrdnVectorFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorFindInAxesResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnVectorFindInAxesResult._metadata, IAgCrdnVectorFindInAxesResult._get_IsValid_metadata)

    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The vector in a specified axes."""
        return self._intf.get_property(IAgCrdnVectorFindInAxesResult._metadata, IAgCrdnVectorFindInAxesResult._get_Vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}", IAgCrdnVectorFindInAxesResult)
agcls.AgTypeNameMap["IAgCrdnVectorFindInAxesResult"] = IAgCrdnVectorFindInAxesResult

class IAgCrdnVectorFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxesWithRate method."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A5EB9B7C-559C-4ABB-839E-47109CDC8446}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Vector" : 2,
                             "get_Rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnVectorFindInAxesWithRateResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnVectorFindInAxesWithRateResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFindInAxesWithRateResult.__dict__ and type(IAgCrdnVectorFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnVectorFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnVectorFindInAxesWithRateResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnVectorFindInAxesWithRateResult._metadata, IAgCrdnVectorFindInAxesWithRateResult._get_IsValid_metadata)

    _get_Vector_metadata = { "name" : "Vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The vector in a specified axes."""
        return self._intf.get_property(IAgCrdnVectorFindInAxesWithRateResult._metadata, IAgCrdnVectorFindInAxesWithRateResult._get_Vector_metadata)

    _get_Rate_metadata = { "name" : "Rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Rate(self) -> "IAgCartesian3Vector":
        """The vector rate in a specified axes."""
        return self._intf.get_property(IAgCrdnVectorFindInAxesWithRateResult._metadata, IAgCrdnVectorFindInAxesWithRateResult._get_Rate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A5EB9B7C-559C-4ABB-839E-47109CDC8446}", IAgCrdnVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["IAgCrdnVectorFindInAxesWithRateResult"] = IAgCrdnVectorFindInAxesWithRateResult

class IAgCrdnMethodCallResult(object):
    """Instances of the interface are used to return the result of a computation."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnMethodCallResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnMethodCallResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnMethodCallResult.__dict__ and type(IAgCrdnMethodCallResult.__dict__[attrname]) == property:
            return IAgCrdnMethodCallResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnMethodCallResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAgCrdnMethodCallResult._metadata, IAgCrdnMethodCallResult._get_IsValid_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}", IAgCrdnMethodCallResult)
agcls.AgTypeNameMap["IAgCrdnMethodCallResult"] = IAgCrdnMethodCallResult

class IAgCrdnCentralBody(object):
    """The interface represents a central body."""
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8742150E-1663-4DCC-A442-278479FF93DC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Name" : 1, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCentralBody._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCentralBody from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCentralBody.__dict__ and type(IAgCrdnCentralBody.__dict__[attrname]) == property:
            return IAgCrdnCentralBody.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCentralBody.")
    
    _get_Name_metadata = { "name" : "Name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def Name(self) -> str:
        """A name of the central body."""
        return self._intf.get_property(IAgCrdnCentralBody._metadata, IAgCrdnCentralBody._get_Name_metadata)


agcls.AgClassCatalog.add_catalog_entry("{8742150E-1663-4DCC-A442-278479FF93DC}", IAgCrdnCentralBody)
agcls.AgTypeNameMap["IAgCrdnCentralBody"] = IAgCrdnCentralBody

class IAgCrdnCentralBodyRefTo(object):
    """Represents a reference to a VGT CentralBody."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{40596A74-4E5F-4406-85FF-70FA79893BFC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "SetPath" : 1,
                             "SetCentralBody" : 2,
                             "GetCentralBody" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCentralBodyRefTo._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCentralBodyRefTo from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCentralBodyRefTo.__dict__ and type(IAgCrdnCentralBodyRefTo.__dict__[attrname]) == property:
            return IAgCrdnCentralBodyRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCentralBodyRefTo.")
    
    _SetPath_metadata = { "name" : "SetPath",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def SetPath(self, path:str) -> None:
        """Sets a new central body using specified path."""
        return self._intf.invoke(IAgCrdnCentralBodyRefTo._metadata, IAgCrdnCentralBodyRefTo._SetPath_metadata, path)

    _SetCentralBody_metadata = { "name" : "SetCentralBody",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAgCrdnCentralBody"),) }
    def SetCentralBody(self, centralBody:"IAgCrdnCentralBody") -> None:
        """Sets a new central body."""
        return self._intf.invoke(IAgCrdnCentralBodyRefTo._metadata, IAgCrdnCentralBodyRefTo._SetCentralBody_metadata, centralBody)

    _GetCentralBody_metadata = { "name" : "GetCentralBody",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def GetCentralBody(self) -> "IAgCrdnCentralBody":
        """Returns a central body or null if the central body is invalid."""
        return self._intf.invoke(IAgCrdnCentralBodyRefTo._metadata, IAgCrdnCentralBodyRefTo._GetCentralBody_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{40596A74-4E5F-4406-85FF-70FA79893BFC}", IAgCrdnCentralBodyRefTo)
agcls.AgTypeNameMap["IAgCrdnCentralBodyRefTo"] = IAgCrdnCentralBodyRefTo

class IAgCrdnCentralBodyCollection(object):
    """A collection of central body names."""
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{FB32C9FA-327D-4AF9-9330-7DE8854F827E}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_Count" : 1,
                             "Item" : 2,
                             "get__NewEnum" : 3,
                             "Add" : 4,
                             "Remove" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCentralBodyCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCentralBodyCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCentralBodyCollection.__dict__ and type(IAgCrdnCentralBodyCollection.__dict__[attrname]) == property:
            return IAgCrdnCentralBodyCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCentralBodyCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> str:
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        return self._intf.get_property(IAgCrdnCentralBodyCollection._metadata, IAgCrdnCentralBodyCollection._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.BSTR_arg,) }
    def Item(self, index:int) -> str:
        """Returns a central body name at a specified index."""
        return self._intf.invoke(IAgCrdnCentralBodyCollection._metadata, IAgCrdnCentralBodyCollection._Item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator"""
        return self._intf.get_property(IAgCrdnCentralBodyCollection._metadata, IAgCrdnCentralBodyCollection._get__NewEnum_metadata)

    _Add_metadata = { "name" : "Add",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Add(self, centralBodyName:str) -> bool:
        """Adds a central body to the collection of central bodies. True indicates success."""
        return self._intf.invoke(IAgCrdnCentralBodyCollection._metadata, IAgCrdnCentralBodyCollection._Add_metadata, centralBodyName, out_arg())

    _Remove_metadata = { "name" : "Remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def Remove(self, centralBodyName:str) -> None:
        """Removes a central body with the specified name from the collection of the central bodies."""
        return self._intf.invoke(IAgCrdnCentralBodyCollection._metadata, IAgCrdnCentralBodyCollection._Remove_metadata, centralBodyName)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FB32C9FA-327D-4AF9-9330-7DE8854F827E}", IAgCrdnCentralBodyCollection)
agcls.AgTypeNameMap["IAgCrdnCentralBodyCollection"] = IAgCrdnCentralBodyCollection

class IAgCrdnCollection(object):
    """A collection of VGT objects."""
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "Contains" : 1,
                             "get_Count" : 2,
                             "Item" : 3,
                             "get__NewEnum" : 4,
                             "GetItemByIndex" : 5,
                             "GetItemByName" : 6, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCollection.__dict__ and type(IAgCrdnCollection.__dict__[attrname]) == property:
            return IAgCrdnCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdn":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _Contains_metadata = { "name" : "Contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAgCrdnCollection._metadata, IAgCrdnCollection._Contains_metadata, name, out_arg())

    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        return self._intf.get_property(IAgCrdnCollection._metadata, IAgCrdnCollection._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, indexOrName:typing.Any) -> "IAgCrdn":
        """Retrieves an element of the collection using the name of the element or a position in the collection."""
        return self._intf.invoke(IAgCrdnCollection._metadata, IAgCrdnCollection._Item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnCollection._metadata, IAgCrdnCollection._get__NewEnum_metadata)

    _GetItemByIndex_metadata = { "name" : "GetItemByIndex",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByIndex(self, index:int) -> "IAgCrdn":
        """Retrieves an item from the crdn collection by index."""
        return self._intf.invoke(IAgCrdnCollection._metadata, IAgCrdnCollection._GetItemByIndex_metadata, index, out_arg())

    _GetItemByName_metadata = { "name" : "GetItemByName",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def GetItemByName(self, name:str) -> "IAgCrdn":
        """Retrieves an item from the crdn collection by name."""
        return self._intf.invoke(IAgCrdnCollection._metadata, IAgCrdnCollection._GetItemByName_metadata, name, out_arg())

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}", IAgCrdnCollection)
agcls.AgTypeNameMap["IAgCrdnCollection"] = IAgCrdnCollection

class IAgCrdnPointSamplingResult(object):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5131DB47-EFEA-4021-BEC5-DD13A73D9917}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointSamplingResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointSamplingResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSamplingResult.__dict__ and type(IAgCrdnPointSamplingResult.__dict__[attrname]) == property:
            return IAgCrdnPointSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointSamplingResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnPointSamplingResult._metadata, IAgCrdnPointSamplingResult._get_IsValid_metadata)

    _get_Intervals_metadata = { "name" : "Intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Intervals(self) -> "IAgCrdnPointSamplingIntervalCollection":
        """A collection of sampling intervals."""
        return self._intf.get_property(IAgCrdnPointSamplingResult._metadata, IAgCrdnPointSamplingResult._get_Intervals_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5131DB47-EFEA-4021-BEC5-DD13A73D9917}", IAgCrdnPointSamplingResult)
agcls.AgTypeNameMap["IAgCrdnPointSamplingResult"] = IAgCrdnPointSamplingResult

class IAgCrdnPointSamplingInterval(object):
    """The interface represents an interval with the time, position and velocity arrays."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Times" : 1,
                             "get_Positions" : 2,
                             "get_Velocities" : 3,
                             "get_Start" : 4,
                             "get_Stop" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointSamplingInterval._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointSamplingInterval from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSamplingInterval.__dict__ and type(IAgCrdnPointSamplingInterval.__dict__[attrname]) == property:
            return IAgCrdnPointSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointSamplingInterval.")
    
    _get_Times_metadata = { "name" : "Times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        return self._intf.get_property(IAgCrdnPointSamplingInterval._metadata, IAgCrdnPointSamplingInterval._get_Times_metadata)

    _get_Positions_metadata = { "name" : "Positions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Positions(self) -> list:
        """An array of 3-tuples each tuple representing the point's cartesian position (x,y,z)."""
        return self._intf.get_property(IAgCrdnPointSamplingInterval._metadata, IAgCrdnPointSamplingInterval._get_Positions_metadata)

    _get_Velocities_metadata = { "name" : "Velocities",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Velocities(self) -> list:
        """An array of velocities."""
        return self._intf.get_property(IAgCrdnPointSamplingInterval._metadata, IAgCrdnPointSamplingInterval._get_Velocities_metadata)

    _get_Start_metadata = { "name" : "Start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(IAgCrdnPointSamplingInterval._metadata, IAgCrdnPointSamplingInterval._get_Start_metadata)

    _get_Stop_metadata = { "name" : "Stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(IAgCrdnPointSamplingInterval._metadata, IAgCrdnPointSamplingInterval._get_Stop_metadata)


agcls.AgClassCatalog.add_catalog_entry("{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}", IAgCrdnPointSamplingInterval)
agcls.AgTypeNameMap["IAgCrdnPointSamplingInterval"] = IAgCrdnPointSamplingInterval

class IAgCrdnPointSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Count" : 1,
                             "Item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnPointSamplingIntervalCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnPointSamplingIntervalCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSamplingIntervalCollection.__dict__ and type(IAgCrdnPointSamplingIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnPointSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnPointSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnPointSamplingInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(IAgCrdnPointSamplingIntervalCollection._metadata, IAgCrdnPointSamplingIntervalCollection._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, index:int) -> "IAgCrdnPointSamplingInterval":
        """Accesses an element at the specified position."""
        return self._intf.invoke(IAgCrdnPointSamplingIntervalCollection._metadata, IAgCrdnPointSamplingIntervalCollection._Item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnPointSamplingIntervalCollection._metadata, IAgCrdnPointSamplingIntervalCollection._get__NewEnum_metadata)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}", IAgCrdnPointSamplingIntervalCollection)
agcls.AgTypeNameMap["IAgCrdnPointSamplingIntervalCollection"] = IAgCrdnPointSamplingIntervalCollection

class IAgCrdnAxesSamplingResult(object):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F01C2A06-2998-406C-9898-CB60F5711EF1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_IsValid" : 1,
                             "get_Intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesSamplingResult._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesSamplingResult from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSamplingResult.__dict__ and type(IAgCrdnAxesSamplingResult.__dict__[attrname]) == property:
            return IAgCrdnAxesSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesSamplingResult.")
    
    _get_IsValid_metadata = { "name" : "IsValid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        return self._intf.get_property(IAgCrdnAxesSamplingResult._metadata, IAgCrdnAxesSamplingResult._get_IsValid_metadata)

    _get_Intervals_metadata = { "name" : "Intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def Intervals(self) -> "IAgCrdnAxesSamplingIntervalCollection":
        """A collection of sampling intervals."""
        return self._intf.get_property(IAgCrdnAxesSamplingResult._metadata, IAgCrdnAxesSamplingResult._get_Intervals_metadata)


agcls.AgClassCatalog.add_catalog_entry("{F01C2A06-2998-406C-9898-CB60F5711EF1}", IAgCrdnAxesSamplingResult)
agcls.AgTypeNameMap["IAgCrdnAxesSamplingResult"] = IAgCrdnAxesSamplingResult

class IAgCrdnAxesSamplingInterval(object):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5BF49282-A56A-48F1-85C9-92CF71C803D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Times" : 1,
                             "get_Quaternions" : 2,
                             "get_Velocities" : 3,
                             "get_Start" : 4,
                             "get_Stop" : 5, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesSamplingInterval._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesSamplingInterval from source object.")
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSamplingInterval.__dict__ and type(IAgCrdnAxesSamplingInterval.__dict__[attrname]) == property:
            return IAgCrdnAxesSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesSamplingInterval.")
    
    _get_Times_metadata = { "name" : "Times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        return self._intf.get_property(IAgCrdnAxesSamplingInterval._metadata, IAgCrdnAxesSamplingInterval._get_Times_metadata)

    _get_Quaternions_metadata = { "name" : "Quaternions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Quaternions(self) -> list:
        """An array of 4-tuples each tuple representing the orientation of the axes as a quaternion (q1,q2,q3,q4)."""
        return self._intf.get_property(IAgCrdnAxesSamplingInterval._metadata, IAgCrdnAxesSamplingInterval._get_Quaternions_metadata)

    _get_Velocities_metadata = { "name" : "Velocities",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def Velocities(self) -> list:
        """An array of angular velocities."""
        return self._intf.get_property(IAgCrdnAxesSamplingInterval._metadata, IAgCrdnAxesSamplingInterval._get_Velocities_metadata)

    _get_Start_metadata = { "name" : "Start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(IAgCrdnAxesSamplingInterval._metadata, IAgCrdnAxesSamplingInterval._get_Start_metadata)

    _get_Stop_metadata = { "name" : "Stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(IAgCrdnAxesSamplingInterval._metadata, IAgCrdnAxesSamplingInterval._get_Stop_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5BF49282-A56A-48F1-85C9-92CF71C803D0}", IAgCrdnAxesSamplingInterval)
agcls.AgTypeNameMap["IAgCrdnAxesSamplingInterval"] = IAgCrdnAxesSamplingInterval

class IAgCrdnAxesSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F593657B-35A4-4F40-B697-4D14E66195AC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_Count" : 1,
                             "Item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        self.__dict__["_intf"] = interface_proxy()
        if sourceObject is not None and sourceObject._intf is not None:
            intf = sourceObject._intf.query_interface(agcom.GUID(IAgCrdnAxesSamplingIntervalCollection._metadata["uuid"]))
            if intf is not None:
                self._private_init(intf)
                del(intf)
            else:
                raise STKInvalidCastError("Failed to create IAgCrdnAxesSamplingIntervalCollection from source object.")
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSamplingIntervalCollection.__dict__ and type(IAgCrdnAxesSamplingIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnAxesSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAgCrdnAxesSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAgCrdnAxesSamplingInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_Count_metadata = { "name" : "Count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(IAgCrdnAxesSamplingIntervalCollection._metadata, IAgCrdnAxesSamplingIntervalCollection._get_Count_metadata)

    _Item_metadata = { "name" : "Item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def Item(self, index:int) -> "IAgCrdnAxesSamplingInterval":
        """Accesses an element at the specified position."""
        return self._intf.invoke(IAgCrdnAxesSamplingIntervalCollection._metadata, IAgCrdnAxesSamplingIntervalCollection._Item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Returns a COM enumerator."""
        return self._intf.get_property(IAgCrdnAxesSamplingIntervalCollection._metadata, IAgCrdnAxesSamplingIntervalCollection._get__NewEnum_metadata)

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F593657B-35A4-4F40-B697-4D14E66195AC}", IAgCrdnAxesSamplingIntervalCollection)
agcls.AgTypeNameMap["IAgCrdnAxesSamplingIntervalCollection"] = IAgCrdnAxesSamplingIntervalCollection



class AgCrdnEvaluateResult(IAgCrdnEvaluateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        IAgCrdnEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEvaluateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEvaluateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEvaluateResult.")

agcls.AgClassCatalog.add_catalog_entry("{94FD0DFF-1DD0-4CA5-A7DB-1CB9CA3E3C93}", AgCrdnEvaluateResult)


class AgCrdnEvaluateWithRateResult(IAgCrdnEvaluateWithRateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        IAgCrdnEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEvaluateWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEvaluateWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{832CA139-8ECF-4E95-AB67-1BB7713CF9FC}", AgCrdnEvaluateWithRateResult)


class AgCrdnEventIntervalResult(IAgCrdnEventIntervalResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalResult.")

agcls.AgClassCatalog.add_catalog_entry("{ACE6C28C-4664-4B7F-8736-91F55C7962A6}", AgCrdnEventIntervalResult)


class AgCrdnEventFindOccurrenceResult(IAgCrdnEventFindOccurrenceResult):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventFindOccurrenceResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventFindOccurrenceResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventFindOccurrenceResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEventFindOccurrenceResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventFindOccurrenceResult.")

agcls.AgClassCatalog.add_catalog_entry("{6A432F58-4CAB-4448-8540-CBBAA9C2B9F0}", AgCrdnEventFindOccurrenceResult)


class AgCrdnFindTimesResult(IAgCrdnFindTimesResult):
    """Returns a collection of intervals and an array of times."""
    def __init__(self, sourceObject=None):
        IAgCrdnFindTimesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnFindTimesResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnFindTimesResult._get_property(self, attrname) is not None: found_prop = IAgCrdnFindTimesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnFindTimesResult.")

agcls.AgClassCatalog.add_catalog_entry("{AF246FCF-7FA3-4CD6-878B-E9AC267F017A}", AgCrdnFindTimesResult)


class AgCrdnIntervalsVectorResult(IAgCrdnIntervalsVectorResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalsVectorResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnIntervalsVectorResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalsVectorResult._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalsVectorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnIntervalsVectorResult.")

agcls.AgClassCatalog.add_catalog_entry("{233B8EB4-0B6A-485F-BACB-C678798FDA21}", AgCrdnIntervalsVectorResult)


class AgCrdnEventIntervalCollectionOccurredResult(IAgCrdnEventIntervalCollectionOccurredResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionOccurredResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalCollectionOccurredResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionOccurredResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionOccurredResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalCollectionOccurredResult.")

agcls.AgClassCatalog.add_catalog_entry("{9D2BD8F6-406D-4BA0-B5CF-C81711C7C344}", AgCrdnEventIntervalCollectionOccurredResult)


class AgCrdnIntervalListResult(IAgCrdnIntervalListResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalListResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnIntervalListResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalListResult._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalListResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnIntervalListResult.")

agcls.AgClassCatalog.add_catalog_entry("{C24C2EE4-3F75-41E8-BDC3-FE71E863921F}", AgCrdnIntervalListResult)


class AgCrdnIntervalVectorCollection(IAgCrdnIntervalVectorCollection):
    """A collection of interval collections."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalVectorCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnIntervalVectorCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalVectorCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalVectorCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnIntervalVectorCollection.")

agcls.AgClassCatalog.add_catalog_entry("{99AAE1D2-3C5D-4836-A1BD-6EAD38FC9BC5}", AgCrdnIntervalVectorCollection)


class AgCrdnEventGroup(IAgCrdnEventGroup):
    """Access or create VGT events associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventGroup.")

agcls.AgClassCatalog.add_catalog_entry("{D5D83181-A954-4FA9-886E-A917F135C974}", AgCrdnEventGroup)


class AgCrdnEventIntervalGroup(IAgCrdnEventIntervalGroup):
    """Access or create VGT event intervals associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalGroup.")

agcls.AgClassCatalog.add_catalog_entry("{48C9D4D2-2713-4063-8BB1-D6F2E72E1025}", AgCrdnEventIntervalGroup)


class AgCrdnEventIntervalListGroup(IAgCrdnEventIntervalListGroup):
    """Access or create VGT event interval lists associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListGroup.")

agcls.AgClassCatalog.add_catalog_entry("{3B2FDEBA-A2B9-4568-8F48-469F604DB966}", AgCrdnEventIntervalListGroup)


class AgCrdnEventArrayGroup(IAgCrdnEventArrayGroup):
    """Access or create VGT event arrays associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayGroup.")

agcls.AgClassCatalog.add_catalog_entry("{365C4A6E-9C2B-4883-96C6-CF689BCC2943}", AgCrdnEventArrayGroup)


class AgCrdnCalcScalarGroup(IAgCrdnCalcScalarGroup):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarGroup.")

agcls.AgClassCatalog.add_catalog_entry("{DFAD8468-4480-460F-993D-74FFADB567B3}", AgCrdnCalcScalarGroup)


class AgCrdnEventIntervalCollectionGroup(IAgCrdnEventIntervalCollectionGroup):
    """Access or create VGT event interval collections associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalCollectionGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalCollectionGroup.")

agcls.AgClassCatalog.add_catalog_entry("{16E277E2-E306-40E7-B698-B725BDED5739}", AgCrdnEventIntervalCollectionGroup)


class AgCrdnParameterSetGroup(IAgCrdnParameterSetGroup):
    """Access or create VGT parameter sets associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSetGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSetGroup.")

agcls.AgClassCatalog.add_catalog_entry("{4AF3C889-3805-40E2-94E2-3EA11AAFB0D7}", AgCrdnParameterSetGroup)


class AgCrdnConditionGroup(IAgCrdnConditionGroup):
    """Access or create VGT conditions associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionGroup.")

agcls.AgClassCatalog.add_catalog_entry("{28BCB469-D32F-4FCE-9CC2-76216E3A37CA}", AgCrdnConditionGroup)


class AgCrdnConditionSetGroup(IAgCrdnConditionSetGroup):
    """Allows accessing and creating condition set components."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionSetGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionSetGroup.")

agcls.AgClassCatalog.add_catalog_entry("{D82D5C71-102E-4154-9FF6-153C4EDB5A94}", AgCrdnConditionSetGroup)


class AgCrdnConditionSetEvaluateResult(IAgCrdnConditionSetEvaluateResult):
    """Represents the results returned by ConditionSet.Evaluate."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionSetEvaluateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetEvaluateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionSetEvaluateResult.")

agcls.AgClassCatalog.add_catalog_entry("{13F4EB53-F5AB-487A-BC09-AA186C884744}", AgCrdnConditionSetEvaluateResult)


class AgCrdnConditionSetEvaluateWithRateResult(IAgCrdnConditionSetEvaluateWithRateResult):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionSetEvaluateWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionSetEvaluateWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{53051D77-87D0-432C-9044-A2AB1E2104BA}", AgCrdnConditionSetEvaluateWithRateResult)


class AgCrdnVolumeGridGroup(IAgCrdnVolumeGridGroup):
    """Access or create VGT volume grids associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridGroup.")

agcls.AgClassCatalog.add_catalog_entry("{5E471C90-D0F2-4B6B-88AE-D529E9D16D03}", AgCrdnVolumeGridGroup)


class AgCrdnVolumeGroup(IAgCrdnVolumeGroup):
    """Access or create spatial conditions associated with a volume grid."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGroup.")

agcls.AgClassCatalog.add_catalog_entry("{0055B726-654F-446B-82D7-BCDD744F1D8F}", AgCrdnVolumeGroup)


class AgCrdnVolumeCalcGroup(IAgCrdnVolumeCalcGroup):
    """Access or create VGT volume calc associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcGroup.")

agcls.AgClassCatalog.add_catalog_entry("{b10331b7-f8c3-4a59-9e9b-b05dd6599167}", AgCrdnVolumeCalcGroup)


class AgCrdnCalcScalar(IAgCrdnCalcScalar, IAgCrdn):
    """Any scalar calculation that is not constant by construction."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalar.")

agcls.AgClassCatalog.add_catalog_entry("{440E178B-1B34-4896-A25F-2A4F3AD4848E}", AgCrdnCalcScalar)


class AgCrdnCalcScalarAngle(IAgCrdnCalcScalarAngle, IAgCrdnCalcScalar, IAgCrdn):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarAngle.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarAngle._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarAngle._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarAngle.")

agcls.AgClassCatalog.add_catalog_entry("{2E2A940D-2656-4410-86B4-D7314B788E47}", AgCrdnCalcScalarAngle)


class AgCrdnCalcScalarConstant(IAgCrdnCalcScalarConstant, IAgCrdnCalcScalar, IAgCrdn):
    """Constant scalar value of specified dimension."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarConstant.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarConstant._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarConstant._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarConstant._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarConstant.")

agcls.AgClassCatalog.add_catalog_entry("{0725A767-6788-4FF4-B848-EF3D526BD7B0}", AgCrdnCalcScalarConstant)


class AgCrdnCalcScalarCustom(IAgCrdnCalcScalarCustom, IAgCrdnCalcScalar, IAgCrdn):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarCustom.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarCustom._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarCustom._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarCustom._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarCustom.")

agcls.AgClassCatalog.add_catalog_entry("{80114DE9-EF5E-47DB-AC1B-91FD78FCA094}", AgCrdnCalcScalarCustom)


class AgCrdnCalcScalarDataElement(IAgCrdnCalcScalarDataElement, IAgCrdnCalcScalar, IAgCrdn):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarDataElement.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarDataElement._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarDataElement._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarDataElement._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarDataElement.")

agcls.AgClassCatalog.add_catalog_entry("{260D686F-07E2-49DB-8E88-467EF79EFA54}", AgCrdnCalcScalarDataElement)


class AgCrdnCalcScalarDerivative(IAgCrdnCalcScalarDerivative, IAgCrdnCalcScalar, IAgCrdn):
    """Derivative of an input scalar calculation."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarDerivative.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarDerivative._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarDerivative._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarDerivative.")

agcls.AgClassCatalog.add_catalog_entry("{865CE7A8-F7C3-4B25-AA1D-10CA305C7CF0}", AgCrdnCalcScalarDerivative)


class AgCrdnCalcScalarDotProduct(IAgCrdnCalcScalarDotProduct, IAgCrdnCalcScalar, IAgCrdn):
    """Dot product between two vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarDotProduct.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarDotProduct._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarDotProduct._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarDotProduct._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarDotProduct.")

agcls.AgClassCatalog.add_catalog_entry("{703f009e-faab-4281-8d07-733b1344d42b}", AgCrdnCalcScalarDotProduct)


class AgCrdnCalcScalarElapsedTime(IAgCrdnCalcScalarElapsedTime, IAgCrdnCalcScalar, IAgCrdn):
    """Time elapsed since the reference time instant. Negative if in the past."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarElapsedTime.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarElapsedTime._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarElapsedTime._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarElapsedTime._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarElapsedTime.")

agcls.AgClassCatalog.add_catalog_entry("{9D9FAF22-291A-4348-9EAD-1C8DF06D9C1C}", AgCrdnCalcScalarElapsedTime)


class AgCrdnCalcScalarFactory(IAgCrdnCalcScalarFactory):
    """The factory creates scalar calculation components."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarFactory.")

agcls.AgClassCatalog.add_catalog_entry("{47235112-821F-4DC2-9A70-57AB9F1F17E8}", AgCrdnCalcScalarFactory)


class AgCrdnCalcScalarFile(IAgCrdnCalcScalarFile, IAgCrdnCalcScalar, IAgCrdn):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFile.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarFile._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFile._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFile._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarFile.")

agcls.AgClassCatalog.add_catalog_entry("{75F0039F-B789-4771-BD50-9AEF30F6038E}", AgCrdnCalcScalarFile)


class AgCrdnCalcScalarFixedAtTimeInstant(IAgCrdnCalcScalarFixedAtTimeInstant, IAgCrdnCalcScalar, IAgCrdn):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFixedAtTimeInstant.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarFixedAtTimeInstant._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFixedAtTimeInstant._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarFixedAtTimeInstant.")

agcls.AgClassCatalog.add_catalog_entry("{83E8DC6B-7821-4474-AA5B-29646ECD1EC1}", AgCrdnCalcScalarFixedAtTimeInstant)


class AgCrdnCalcScalarFunction(IAgCrdnCalcScalarFunction, IAgCrdnCalcScalar, IAgCrdn):
    """Defined by performing the specified function on the input scalar or time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFunction.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarFunction._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFunction._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFunction._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarFunction.")

agcls.AgClassCatalog.add_catalog_entry("{40158F99-3146-4167-8BB0-A0046BB08EEB}", AgCrdnCalcScalarFunction)


class AgCrdnCalcScalarFunction2Var(IAgCrdnCalcScalarFunction2Var, IAgCrdnCalcScalar, IAgCrdn):
    """Defined by performing a function(x,y) on two scalar arguments."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFunction2Var.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarFunction2Var._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFunction2Var._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFunction2Var._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarFunction2Var.")

agcls.AgClassCatalog.add_catalog_entry("{05CA07A4-A36F-44EF-99C4-5E0999E79200}", AgCrdnCalcScalarFunction2Var)


class AgCrdnCalcScalarIntegral(IAgCrdnCalcScalarIntegral, IAgCrdnCalcScalar, IAgCrdn):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarIntegral.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarIntegral._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarIntegral._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarIntegral._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarIntegral.")

agcls.AgClassCatalog.add_catalog_entry("{C87C787A-BEDA-4AEC-9F88-3D6EE0936A03}", AgCrdnCalcScalarIntegral)


class AgCrdnCalcScalarPlugin(IAgCrdnCalcScalarPlugin, IAgCrdnCalcScalar, IAgCrdn):
    """Use a scalar calculation plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarPlugin.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarPlugin._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarPlugin._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarPlugin.")

agcls.AgClassCatalog.add_catalog_entry("{E435E30B-EA9B-4EFB-852A-C20427B71484}", AgCrdnCalcScalarPlugin)


class AgCrdnCalcScalarSurfaceDistanceBetweenPoints(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, IAgCrdnCalcScalar, IAgCrdn):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarSurfaceDistanceBetweenPoints.")

agcls.AgClassCatalog.add_catalog_entry("{DEDCB488-6C70-4BC0-A719-68832FB6D30E}", AgCrdnCalcScalarSurfaceDistanceBetweenPoints)


class AgCrdnCalcScalarVectorComponent(IAgCrdnCalcScalarVectorComponent, IAgCrdnCalcScalar, IAgCrdn):
    """The specified component of a vector when resolved in the specified axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarVectorComponent.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarVectorComponent._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarVectorComponent._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarVectorComponent._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarVectorComponent.")

agcls.AgClassCatalog.add_catalog_entry("{0b8e5c9f-de1b-4b6b-9e38-87b16db7bb71}", AgCrdnCalcScalarVectorComponent)


class AgCrdnCalcScalarVectorMagnitude(IAgCrdnCalcScalarVectorMagnitude, IAgCrdnCalcScalar, IAgCrdn):
    """Scalar equal to the magnitude of a specified vector."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarVectorMagnitude.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCalcScalarVectorMagnitude._private_init(self, intf)
        IAgCrdnCalcScalar._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarVectorMagnitude._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarVectorMagnitude._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCalcScalarVectorMagnitude.")

agcls.AgClassCatalog.add_catalog_entry("{C7430CE8-D611-4F5C-B4B4-05531F1E0CC0}", AgCrdnCalcScalarVectorMagnitude)


class AgCrdnCondition(IAgCrdnCondition, IAgCrdn):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    def __init__(self, sourceObject=None):
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCondition._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCondition.")

agcls.AgClassCatalog.add_catalog_entry("{D1BED244-FFB2-4038-AE76-A9B3194B2E49}", AgCrdnCondition)


class AgCrdnConditionCombined(IAgCrdnConditionCombined, IAgCrdnCondition, IAgCrdn):
    """Defines a condition which combines multiple conditions."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionCombined.__init__(self, sourceObject)
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionCombined._private_init(self, intf)
        IAgCrdnCondition._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionCombined._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionCombined._get_property(self, attrname)
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionCombined.")

agcls.AgClassCatalog.add_catalog_entry("{92F4488B-3543-4229-B1FB-447D282199B9}", AgCrdnConditionCombined)


class AgCrdnConditionFactory(IAgCrdnConditionFactory):
    """The factory creates condition components."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionFactory.")

agcls.AgClassCatalog.add_catalog_entry("{06C627F8-87EA-4552-86E8-7E5049914CDE}", AgCrdnConditionFactory)


class AgCrdnConditionPointInVolume(IAgCrdnConditionPointInVolume, IAgCrdnCondition, IAgCrdn):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionPointInVolume.__init__(self, sourceObject)
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionPointInVolume._private_init(self, intf)
        IAgCrdnCondition._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionPointInVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionPointInVolume._get_property(self, attrname)
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionPointInVolume.")

agcls.AgClassCatalog.add_catalog_entry("{41532AD9-B30C-44AE-8581-CE74C24846A8}", AgCrdnConditionPointInVolume)


class AgCrdnConditionScalarBounds(IAgCrdnConditionScalarBounds, IAgCrdnCondition, IAgCrdn):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionScalarBounds.__init__(self, sourceObject)
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionScalarBounds._private_init(self, intf)
        IAgCrdnCondition._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionScalarBounds._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionScalarBounds._get_property(self, attrname)
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionScalarBounds.")

agcls.AgClassCatalog.add_catalog_entry("{452E2178-AFB0-4E61-8187-9C6CB4A704A0}", AgCrdnConditionScalarBounds)


class AgCrdnConditionSet(IAgCrdnConditionSet, IAgCrdn):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSet._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionSet.")

agcls.AgClassCatalog.add_catalog_entry("{B6407B1B-6858-49FC-845A-F8A6239162C2}", AgCrdnConditionSet)


class AgCrdnConditionSetFactory(IAgCrdnConditionSetFactory):
    """The factory creates condition set components."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionSetFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionSetFactory.")

agcls.AgClassCatalog.add_catalog_entry("{D2445C98-9EA1-458F-9B6A-607249BF399A}", AgCrdnConditionSetFactory)


class AgCrdnConditionSetScalarThresholds(IAgCrdnConditionSetScalarThresholds, IAgCrdnConditionSet, IAgCrdn):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetScalarThresholds.__init__(self, sourceObject)
        IAgCrdnConditionSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConditionSetScalarThresholds._private_init(self, intf)
        IAgCrdnConditionSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetScalarThresholds._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetScalarThresholds._get_property(self, attrname)
        if IAgCrdnConditionSet._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConditionSetScalarThresholds.")

agcls.AgClassCatalog.add_catalog_entry("{EED0BF6B-4D96-4D55-B988-0B962DCDBB4E}", AgCrdnConditionSetScalarThresholds)


class AgCrdnConverge(IAgCrdnConverge, IAgCrdn):
    """Represents a base class for convergence definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnConverge.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConverge._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConverge._get_property(self, attrname) is not None: found_prop = IAgCrdnConverge._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConverge.")

agcls.AgClassCatalog.add_catalog_entry("{6A13D679-1970-43C2-8D4F-174B08AB04DC}", AgCrdnConverge)


class AgCrdnConvergeBasic(IAgCrdnConvergeBasic, IAgCrdnConverge, IAgCrdn):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    def __init__(self, sourceObject=None):
        IAgCrdnConvergeBasic.__init__(self, sourceObject)
        IAgCrdnConverge.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnConvergeBasic._private_init(self, intf)
        IAgCrdnConverge._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConvergeBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnConvergeBasic._get_property(self, attrname)
        if IAgCrdnConverge._get_property(self, attrname) is not None: found_prop = IAgCrdnConverge._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnConvergeBasic.")

agcls.AgClassCatalog.add_catalog_entry("{808F19C3-0E31-4C89-94C8-BBE01E067DFF}", AgCrdnConvergeBasic)


class AgCrdnDerivative(IAgCrdnDerivative, IAgCrdn):
    """Represents a base class for derivative definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnDerivative.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnDerivative._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnDerivative._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnDerivative.")

agcls.AgClassCatalog.add_catalog_entry("{2C7C1DA3-BD86-4D8B-9505-AC796FF1FD45}", AgCrdnDerivative)


class AgCrdnDerivativeBasic(IAgCrdnDerivativeBasic, IAgCrdnDerivative, IAgCrdn):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    def __init__(self, sourceObject=None):
        IAgCrdnDerivativeBasic.__init__(self, sourceObject)
        IAgCrdnDerivative.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnDerivativeBasic._private_init(self, intf)
        IAgCrdnDerivative._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnDerivativeBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnDerivativeBasic._get_property(self, attrname)
        if IAgCrdnDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnDerivative._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnDerivativeBasic.")

agcls.AgClassCatalog.add_catalog_entry("{3CD084C3-0045-4452-9793-AE8DF4073433}", AgCrdnDerivativeBasic)


class AgCrdnEvent(IAgCrdnEvent, IAgCrdn):
    """Defines an event (time instant)."""
    def __init__(self, sourceObject=None):
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEvent._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEvent.")

agcls.AgClassCatalog.add_catalog_entry("{A4B75B25-5DAE-4AEC-86EF-512F5E031766}", AgCrdnEvent)


class AgCrdnEventArray(IAgCrdnEventArray, IAgCrdn):
    """An ordered array of times, which may or may not be evenly spaced."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArray.")

agcls.AgClassCatalog.add_catalog_entry("{F5C87B1A-D519-4A01-8649-AA7560CD503A}", AgCrdnEventArray)


class AgCrdnEventArrayConditionCrossings(IAgCrdnEventArrayConditionCrossings, IAgCrdnEventArray, IAgCrdn):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayConditionCrossings.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayConditionCrossings._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayConditionCrossings._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayConditionCrossings._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayConditionCrossings.")

agcls.AgClassCatalog.add_catalog_entry("{B6FBC501-3521-4AE3-AFD8-4971F089D14F}", AgCrdnEventArrayConditionCrossings)


class AgCrdnEventArrayExtrema(IAgCrdnEventArrayExtrema, IAgCrdnEventArray, IAgCrdn):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayExtrema.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayExtrema._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayExtrema._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayExtrema._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayExtrema.")

agcls.AgClassCatalog.add_catalog_entry("{8FB3F78C-D9F6-43F0-BCAA-5A7DCD035592}", AgCrdnEventArrayExtrema)


class AgCrdnEventArrayFactory(IAgCrdnEventArrayFactory):
    """The factory creates event arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayFactory.")

agcls.AgClassCatalog.add_catalog_entry("{A001EDFD-FAC8-4BBE-9FDC-0C7A5C4BB11C}", AgCrdnEventArrayFactory)


class AgCrdnEventArrayFiltered(IAgCrdnEventArrayFiltered, IAgCrdnEventArray, IAgCrdn):
    """Defined by filtering times from original time array according to specified filtering method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFiltered.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayFiltered._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFiltered._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFiltered._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayFiltered.")

agcls.AgClassCatalog.add_catalog_entry("{CA0D9FE7-E921-406E-8A1A-EE448A46C03C}", AgCrdnEventArrayFiltered)


class AgCrdnEventArrayFixedStep(IAgCrdnEventArrayFixedStep, IAgCrdnEventArray, IAgCrdn):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFixedStep.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayFixedStep._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFixedStep._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFixedStep._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayFixedStep.")

agcls.AgClassCatalog.add_catalog_entry("{CDA379CC-7511-496E-874E-14E10F3E2B1A}", AgCrdnEventArrayFixedStep)


class AgCrdnEventArrayFixedTimes(IAgCrdnEventArrayFixedTimes, IAgCrdnEventArray, IAgCrdn):
    """Array defined by time ordered instants each explicitly specified."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFixedTimes.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayFixedTimes._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFixedTimes._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFixedTimes._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayFixedTimes.")

agcls.AgClassCatalog.add_catalog_entry("{EA73AECA-23AB-4DA1-B297-E80E19C55C15}", AgCrdnEventArrayFixedTimes)


class AgCrdnEventArrayMerged(IAgCrdnEventArrayMerged, IAgCrdnEventArray, IAgCrdn):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayMerged.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayMerged._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayMerged._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayMerged._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayMerged.")

agcls.AgClassCatalog.add_catalog_entry("{44FBC83E-D466-425F-ADF5-2003D754F935}", AgCrdnEventArrayMerged)


class AgCrdnEventArraySignaled(IAgCrdnEventArraySignaled, IAgCrdnEventArray, IAgCrdn):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArraySignaled.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArraySignaled._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArraySignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArraySignaled._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArraySignaled.")

agcls.AgClassCatalog.add_catalog_entry("{50E37652-E4D1-4B6F-BA12-2D9B17E5F1AA}", AgCrdnEventArraySignaled)


class AgCrdnEventArrayStartStopTimes(IAgCrdnEventArrayStartStopTimes, IAgCrdnEventArray, IAgCrdn):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayStartStopTimes.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventArrayStartStopTimes._private_init(self, intf)
        IAgCrdnEventArray._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayStartStopTimes._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayStartStopTimes._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventArrayStartStopTimes.")

agcls.AgClassCatalog.add_catalog_entry("{1AF5E1AC-97CB-4375-B0AE-AE8B6684432B}", AgCrdnEventArrayStartStopTimes)


class AgCrdnEventEpoch(IAgCrdnEventEpoch, IAgCrdnEvent, IAgCrdn):
    """Event set at specified date/time."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventEpoch.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventEpoch._private_init(self, intf)
        IAgCrdnEvent._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnEventEpoch._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventEpoch.")

agcls.AgClassCatalog.add_catalog_entry("{230426D4-438A-4B6E-A9D2-5393F7F87238}", AgCrdnEventEpoch)


class AgCrdnEventExtremum(IAgCrdnEventExtremum, IAgCrdnEvent, IAgCrdn):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventExtremum.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventExtremum._private_init(self, intf)
        IAgCrdnEvent._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventExtremum._get_property(self, attrname) is not None: found_prop = IAgCrdnEventExtremum._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventExtremum.")

agcls.AgClassCatalog.add_catalog_entry("{7D4AD095-F1A4-4ACA-8788-50DEF2F4B604}", AgCrdnEventExtremum)


class AgCrdnEventFactory(IAgCrdnEventFactory):
    """The factory creates events."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventFactory.")

agcls.AgClassCatalog.add_catalog_entry("{9DEB7422-F9AA-492A-9269-3BDB7B0AF7E4}", AgCrdnEventFactory)


class AgCrdnEventInterval(IAgCrdnEventInterval, IAgCrdn):
    """A single time interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventInterval.")

agcls.AgClassCatalog.add_catalog_entry("{2CDA6DDC-7412-441A-8F94-0671FD57D16A}", AgCrdnEventInterval)


class AgCrdnEventIntervalBetweenTimeInstants(IAgCrdnEventIntervalBetweenTimeInstants, IAgCrdnEventInterval, IAgCrdn):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalBetweenTimeInstants.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalBetweenTimeInstants._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalBetweenTimeInstants._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalBetweenTimeInstants._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalBetweenTimeInstants.")

agcls.AgClassCatalog.add_catalog_entry("{E84D9CAE-E919-4B84-99D7-553CCB97739C}", AgCrdnEventIntervalBetweenTimeInstants)


class AgCrdnEventIntervalCollection(IAgCrdnEventIntervalCollection, IAgCrdn):
    """A collection of related interval lists."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalCollection._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalCollection.")

agcls.AgClassCatalog.add_catalog_entry("{892BFFEB-D366-49D5-8220-50AC5E4529A1}", AgCrdnEventIntervalCollection)


class AgCrdnEventIntervalCollectionCondition(IAgCrdnEventIntervalCollectionCondition, IAgCrdnEventIntervalCollection, IAgCrdn):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionCondition.__init__(self, sourceObject)
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalCollectionCondition._private_init(self, intf)
        IAgCrdnEventIntervalCollection._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionCondition._get_property(self, attrname)
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalCollectionCondition.")

agcls.AgClassCatalog.add_catalog_entry("{05E4AFDD-2917-46BA-84C9-1EE7973F11D7}", AgCrdnEventIntervalCollectionCondition)


class AgCrdnEventIntervalCollectionFactory(IAgCrdnEventIntervalCollectionFactory):
    """The factory creates collections of event interval lists."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalCollectionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalCollectionFactory.")

agcls.AgClassCatalog.add_catalog_entry("{C76F8390-6619-47D5-9D33-DD1FBBF19B63}", AgCrdnEventIntervalCollectionFactory)


class AgCrdnEventIntervalCollectionLighting(IAgCrdnEventIntervalCollectionLighting, IAgCrdnEventIntervalCollection, IAgCrdn):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionLighting.__init__(self, sourceObject)
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalCollectionLighting._private_init(self, intf)
        IAgCrdnEventIntervalCollection._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionLighting._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionLighting._get_property(self, attrname)
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalCollectionLighting.")

agcls.AgClassCatalog.add_catalog_entry("{5457BFBA-3076-4250-B0E0-81FA79D58F19}", AgCrdnEventIntervalCollectionLighting)


class AgCrdnEventIntervalCollectionSignaled(IAgCrdnEventIntervalCollectionSignaled, IAgCrdnEventIntervalCollection, IAgCrdn):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionSignaled.__init__(self, sourceObject)
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalCollectionSignaled._private_init(self, intf)
        IAgCrdnEventIntervalCollection._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionSignaled._get_property(self, attrname)
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalCollectionSignaled.")

agcls.AgClassCatalog.add_catalog_entry("{D1ED3869-B0E3-40F6-967A-C539C5D5D630}", AgCrdnEventIntervalCollectionSignaled)


class AgCrdnEventIntervalFactory(IAgCrdnEventIntervalFactory):
    """The factory creates event intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalFactory.")

agcls.AgClassCatalog.add_catalog_entry("{D5D195D8-DE6D-4926-B743-556B08A827C8}", AgCrdnEventIntervalFactory)


class AgCrdnEventIntervalFixed(IAgCrdnEventIntervalFixed, IAgCrdnEventInterval, IAgCrdn):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFixed.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalFixed._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFixed._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFixed._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalFixed.")

agcls.AgClassCatalog.add_catalog_entry("{4408570B-CE46-4B6A-9A50-F8F6D56D76F1}", AgCrdnEventIntervalFixed)


class AgCrdnEventIntervalFixedDuration(IAgCrdnEventIntervalFixedDuration, IAgCrdnEventInterval, IAgCrdn):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFixedDuration.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalFixedDuration._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFixedDuration._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFixedDuration._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalFixedDuration.")

agcls.AgClassCatalog.add_catalog_entry("{84316F31-A3DB-4DF3-B8E3-352673D4E251}", AgCrdnEventIntervalFixedDuration)


class AgCrdnEventIntervalFromIntervalList(IAgCrdnEventIntervalFromIntervalList, IAgCrdnEventInterval, IAgCrdn):
    """Interval created from specified interval list by using one of several selection methods."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFromIntervalList.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalFromIntervalList._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFromIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFromIntervalList._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalFromIntervalList.")

agcls.AgClassCatalog.add_catalog_entry("{0E3B57D7-B236-4DCA-82DA-6C4835A6D0F1}", AgCrdnEventIntervalFromIntervalList)


class AgCrdnEventIntervalList(IAgCrdnEventIntervalList, IAgCrdn):
    """An ordered list of time intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalList.")

agcls.AgClassCatalog.add_catalog_entry("{050E0A6D-9960-4470-9803-AF58B43FD747}", AgCrdnEventIntervalList)


class AgCrdnEventIntervalListCondition(IAgCrdnEventIntervalListCondition, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListCondition.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListCondition._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListCondition._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListCondition.")

agcls.AgClassCatalog.add_catalog_entry("{4D1E24FE-BD49-4F09-9C30-523AFD58E02B}", AgCrdnEventIntervalListCondition)


class AgCrdnEventIntervalListFactory(IAgCrdnEventIntervalListFactory):
    """The factory creates event interval lists."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListFactory.")

agcls.AgClassCatalog.add_catalog_entry("{DC3FA659-172B-4C9D-9DCA-EF6AD6CC4A8A}", AgCrdnEventIntervalListFactory)


class AgCrdnEventIntervalListFile(IAgCrdnEventIntervalListFile, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFile.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListFile._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFile._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFile._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListFile.")

agcls.AgClassCatalog.add_catalog_entry("{5A3BC6C1-559F-448D-946E-3D608C0C59B4}", AgCrdnEventIntervalListFile)


class AgCrdnEventIntervalListFiltered(IAgCrdnEventIntervalListFiltered, IAgCrdnEventIntervalList, IAgCrdn):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFiltered.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListFiltered._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFiltered._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFiltered._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListFiltered.")

agcls.AgClassCatalog.add_catalog_entry("{7123DA29-BECE-4032-9A81-77CDA69C5B13}", AgCrdnEventIntervalListFiltered)


class AgCrdnEventIntervalListFixed(IAgCrdnEventIntervalListFixed, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFixed.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListFixed._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFixed._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFixed._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListFixed.")

agcls.AgClassCatalog.add_catalog_entry("{60EF79E3-069B-45E3-A5A6-B49F9F9D618E}", AgCrdnEventIntervalListFixed)


class AgCrdnEventIntervalListMerged(IAgCrdnEventIntervalListMerged, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListMerged.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListMerged._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListMerged._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListMerged._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListMerged.")

agcls.AgClassCatalog.add_catalog_entry("{115C7064-1624-4928-B401-2C2B8DA2A2DC}", AgCrdnEventIntervalListMerged)


class AgCrdnEventIntervalListScaled(IAgCrdnEventIntervalListScaled, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListScaled.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListScaled._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListScaled._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListScaled.")

agcls.AgClassCatalog.add_catalog_entry("{3A5FDAFA-95C5-4743-A675-B9598AAAA1B9}", AgCrdnEventIntervalListScaled)


class AgCrdnEventIntervalListSignaled(IAgCrdnEventIntervalListSignaled, IAgCrdnEventIntervalList, IAgCrdn):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListSignaled.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListSignaled._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListSignaled._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListSignaled.")

agcls.AgClassCatalog.add_catalog_entry("{0C2159AF-FCE5-46AA-A06B-30E49A5B6704}", AgCrdnEventIntervalListSignaled)


class AgCrdnEventIntervalListTimeOffset(IAgCrdnEventIntervalListTimeOffset, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListTimeOffset.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalListTimeOffset._private_init(self, intf)
        IAgCrdnEventIntervalList._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListTimeOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListTimeOffset._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalListTimeOffset.")

agcls.AgClassCatalog.add_catalog_entry("{BA2C1495-B20E-477A-A995-8B5B879DE84C}", AgCrdnEventIntervalListTimeOffset)


class AgCrdnEventIntervalScaled(IAgCrdnEventIntervalScaled, IAgCrdnEventInterval, IAgCrdn):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalScaled.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalScaled._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalScaled._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalScaled.")

agcls.AgClassCatalog.add_catalog_entry("{8BCF947C-8E52-4B0C-9416-520C7CCEAB3E}", AgCrdnEventIntervalScaled)


class AgCrdnEventIntervalSignaled(IAgCrdnEventIntervalSignaled, IAgCrdnEventInterval, IAgCrdn):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalSignaled.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalSignaled._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalSignaled._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalSignaled.")

agcls.AgClassCatalog.add_catalog_entry("{0E2D6BF4-81D9-476D-A4F2-F1882E24B56E}", AgCrdnEventIntervalSignaled)


class AgCrdnEventIntervalSmartInterval(IAgCrdnEventIntervalSmartInterval, IAgCrdnEventInterval, IAgCrdn):
    """A smart interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalSmartInterval.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalSmartInterval._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalSmartInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalSmartInterval._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalSmartInterval.")

agcls.AgClassCatalog.add_catalog_entry("{F3D4E2AC-3845-4719-AD57-EE0C715A584D}", AgCrdnEventIntervalSmartInterval)


class AgCrdnEventIntervalTimeOffset(IAgCrdnEventIntervalTimeOffset, IAgCrdnEventInterval, IAgCrdn):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalTimeOffset.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventIntervalTimeOffset._private_init(self, intf)
        IAgCrdnEventInterval._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalTimeOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalTimeOffset._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventIntervalTimeOffset.")

agcls.AgClassCatalog.add_catalog_entry("{DE89BB00-5A89-4DA4-8730-CA2C3495A867}", AgCrdnEventIntervalTimeOffset)


class AgCrdnEventSignaled(IAgCrdnEventSignaled, IAgCrdnEvent, IAgCrdn):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventSignaled.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventSignaled._private_init(self, intf)
        IAgCrdnEvent._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventSignaled._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventSignaled.")

agcls.AgClassCatalog.add_catalog_entry("{3951EF3D-DAEA-4F04-B78C-22537BD84A2D}", AgCrdnEventSignaled)


class AgCrdnEventSmartEpoch(IAgCrdnEventSmartEpoch, IAgCrdnEvent, IAgCrdn):
    """A smart epoch."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventSmartEpoch.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventSmartEpoch._private_init(self, intf)
        IAgCrdnEvent._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventSmartEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnEventSmartEpoch._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventSmartEpoch.")

agcls.AgClassCatalog.add_catalog_entry("{F722C253-92DA-4956-983B-B80AB469F192}", AgCrdnEventSmartEpoch)


class AgCrdnEventStartStopTime(IAgCrdnEventStartStopTime, IAgCrdnEvent, IAgCrdn):
    """Event is either start or stop time selected from a reference interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventStartStopTime.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventStartStopTime._private_init(self, intf)
        IAgCrdnEvent._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventStartStopTime._get_property(self, attrname) is not None: found_prop = IAgCrdnEventStartStopTime._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventStartStopTime.")

agcls.AgClassCatalog.add_catalog_entry("{F0429607-A51C-495C-9902-585429D40D10}", AgCrdnEventStartStopTime)


class AgCrdnEventTimeOffset(IAgCrdnEventTimeOffset, IAgCrdnEvent, IAgCrdn):
    """Event at fixed offset from specified reference event."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventTimeOffset.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnEventTimeOffset._private_init(self, intf)
        IAgCrdnEvent._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventTimeOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnEventTimeOffset._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnEventTimeOffset.")

agcls.AgClassCatalog.add_catalog_entry("{EE2C89C8-C148-4044-B0BE-BF137D4B876B}", AgCrdnEventTimeOffset)


class AgCrdnFirstIntervalsFilter(IAgCrdnFirstIntervalsFilter, IAgCrdnPruneFilter):
    """The filter selects a portion of first intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnFirstIntervalsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnFirstIntervalsFilter._private_init(self, intf)
        IAgCrdnPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnFirstIntervalsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnFirstIntervalsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnFirstIntervalsFilter.")

agcls.AgClassCatalog.add_catalog_entry("{9A044590-5063-4331-9FC2-621221CF7EA9}", AgCrdnFirstIntervalsFilter)


class AgCrdnGapsFilter(IAgCrdnGapsFilter, IAgCrdnPruneFilter):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IAgCrdnGapsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnGapsFilter._private_init(self, intf)
        IAgCrdnPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGapsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnGapsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnGapsFilter.")

agcls.AgClassCatalog.add_catalog_entry("{C54D3817-6B48-4436-8E1D-323A38DC2BC0}", AgCrdnGapsFilter)


class AgCrdnIntegral(IAgCrdnIntegral, IAgCrdn):
    """Represents a base class for integral definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntegral.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnIntegral._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntegral._get_property(self, attrname) is not None: found_prop = IAgCrdnIntegral._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnIntegral.")

agcls.AgClassCatalog.add_catalog_entry("{9C6B1D39-FC48-475A-A888-DA9D459C1906}", AgCrdnIntegral)


class AgCrdnIntegralBasic(IAgCrdnIntegralBasic, IAgCrdnIntegral, IAgCrdn):
    """Integral definition determines how scalar calculation is numerically integrated."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntegralBasic.__init__(self, sourceObject)
        IAgCrdnIntegral.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnIntegralBasic._private_init(self, intf)
        IAgCrdnIntegral._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntegralBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnIntegralBasic._get_property(self, attrname)
        if IAgCrdnIntegral._get_property(self, attrname) is not None: found_prop = IAgCrdnIntegral._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnIntegralBasic.")

agcls.AgClassCatalog.add_catalog_entry("{7FCEE0EE-218C-419E-B5DB-8381B18FAE8A}", AgCrdnIntegralBasic)


class AgCrdnInterp(IAgCrdnInterp, IAgCrdn):
    """Represents a base class for interpolation definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnInterp.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnInterp._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnInterp._get_property(self, attrname) is not None: found_prop = IAgCrdnInterp._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnInterp.")

agcls.AgClassCatalog.add_catalog_entry("{F73B3675-6FD4-4050-9566-797DCD695107}", AgCrdnInterp)


class AgCrdnInterpBasic(IAgCrdnInterpBasic, IAgCrdnInterp, IAgCrdn):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    def __init__(self, sourceObject=None):
        IAgCrdnInterpBasic.__init__(self, sourceObject)
        IAgCrdnInterp.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnInterpBasic._private_init(self, intf)
        IAgCrdnInterp._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnInterpBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnInterpBasic._get_property(self, attrname)
        if IAgCrdnInterp._get_property(self, attrname) is not None: found_prop = IAgCrdnInterp._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnInterpBasic.")

agcls.AgClassCatalog.add_catalog_entry("{AB05143F-6997-4F40-BE86-DCF4D723F31E}", AgCrdnInterpBasic)


class AgCrdnIntervalsFilter(IAgCrdnIntervalsFilter, IAgCrdnPruneFilter):
    """The filter selects intervals of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnIntervalsFilter._private_init(self, intf)
        IAgCrdnPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnIntervalsFilter.")

agcls.AgClassCatalog.add_catalog_entry("{DA31C4A7-B07C-4DEC-B479-BBEB07234B44}", AgCrdnIntervalsFilter)


class AgCrdnLastIntervalsFilter(IAgCrdnLastIntervalsFilter, IAgCrdnPruneFilter):
    """The filter selects a portion of last intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnLastIntervalsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnLastIntervalsFilter._private_init(self, intf)
        IAgCrdnPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnLastIntervalsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnLastIntervalsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnLastIntervalsFilter.")

agcls.AgClassCatalog.add_catalog_entry("{1FAF4A1D-B0BA-4A86-A0AC-049670C66302}", AgCrdnLastIntervalsFilter)


class AgCrdnParameterSet(IAgCrdnParameterSet, IAgCrdn):
    """Parameter set contains various sets of scalar computations."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSet.")

agcls.AgClassCatalog.add_catalog_entry("{CD1D82FC-08BF-4854-9295-F90AC87FAE68}", AgCrdnParameterSet)


class AgCrdnParameterSetAttitude(IAgCrdnParameterSetAttitude, IAgCrdnParameterSet, IAgCrdn):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetAttitude.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSetAttitude._private_init(self, intf)
        IAgCrdnParameterSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetAttitude._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetAttitude._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSetAttitude.")

agcls.AgClassCatalog.add_catalog_entry("{7082CB04-052B-46A2-A051-4FF52D0260B0}", AgCrdnParameterSetAttitude)


class AgCrdnParameterSetFactory(IAgCrdnParameterSetFactory):
    """The factory is used to create instances of available parameter set types."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSetFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSetFactory.")

agcls.AgClassCatalog.add_catalog_entry("{FF399336-197C-480B-98AC-3F07E76FF3BC}", AgCrdnParameterSetFactory)


class AgCrdnParameterSetGroundTrajectory(IAgCrdnParameterSetGroundTrajectory, IAgCrdnParameterSet, IAgCrdn):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetGroundTrajectory.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSetGroundTrajectory._private_init(self, intf)
        IAgCrdnParameterSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetGroundTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetGroundTrajectory._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSetGroundTrajectory.")

agcls.AgClassCatalog.add_catalog_entry("{B1972E17-F000-4BFF-80A3-216A91D0E2B1}", AgCrdnParameterSetGroundTrajectory)


class AgCrdnParameterSetOrbit(IAgCrdnParameterSetOrbit, IAgCrdnParameterSet, IAgCrdn):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetOrbit.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSetOrbit._private_init(self, intf)
        IAgCrdnParameterSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetOrbit._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetOrbit._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSetOrbit.")

agcls.AgClassCatalog.add_catalog_entry("{BF4A60A0-68E5-4000-8843-DD7FD76813A9}", AgCrdnParameterSetOrbit)


class AgCrdnParameterSetTrajectory(IAgCrdnParameterSetTrajectory, IAgCrdnParameterSet, IAgCrdn):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetTrajectory.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSetTrajectory._private_init(self, intf)
        IAgCrdnParameterSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetTrajectory._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSetTrajectory.")

agcls.AgClassCatalog.add_catalog_entry("{542072ED-4073-4F91-8EC8-45F7CC401ED7}", AgCrdnParameterSetTrajectory)


class AgCrdnParameterSetVector(IAgCrdnParameterSetVector, IAgCrdnParameterSet, IAgCrdn):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetVector.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnParameterSetVector._private_init(self, intf)
        IAgCrdnParameterSet._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetVector._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetVector._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnParameterSetVector.")

agcls.AgClassCatalog.add_catalog_entry("{DC7B40D5-7091-4A24-A698-436D2A274DC8}", AgCrdnParameterSetVector)


class AgCrdnPruneFilter(IAgCrdnPruneFilter):
    """A filter used with event interval list pruned class to prune interval lists..."""
    def __init__(self, sourceObject=None):
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPruneFilter.")

agcls.AgClassCatalog.add_catalog_entry("{E08D63E9-CC8E-41F8-B3C5-0D062425C025}", AgCrdnPruneFilter)


class AgCrdnPruneFilterFactory(IAgCrdnPruneFilterFactory):
    """The factory creates pruning filters."""
    def __init__(self, sourceObject=None):
        IAgCrdnPruneFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPruneFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPruneFilterFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPruneFilterFactory.")

agcls.AgClassCatalog.add_catalog_entry("{954284C2-3544-4888-9A56-759AA8C7E1F7}", AgCrdnPruneFilterFactory)


class AgCrdnRelativeSatisfactionConditionFilter(IAgCrdnRelativeSatisfactionConditionFilter, IAgCrdnPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    def __init__(self, sourceObject=None):
        IAgCrdnRelativeSatisfactionConditionFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnRelativeSatisfactionConditionFilter._private_init(self, intf)
        IAgCrdnPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnRelativeSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnRelativeSatisfactionConditionFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnRelativeSatisfactionConditionFilter.")

agcls.AgClassCatalog.add_catalog_entry("{93A5C2C0-AABA-4DB3-9359-100604D0BA02}", AgCrdnRelativeSatisfactionConditionFilter)


class AgCrdnSampling(IAgCrdnSampling, IAgCrdn):
    """Base sampling interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnSampling.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSampling._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSampling._get_property(self, attrname) is not None: found_prop = IAgCrdnSampling._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSampling.")

agcls.AgClassCatalog.add_catalog_entry("{17FC40E9-EF68-4FFD-8A16-071054486F6A}", AgCrdnSampling)


class AgCrdnSamplingBasic(IAgCrdnSamplingBasic, IAgCrdnSampling, IAgCrdn):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingBasic.__init__(self, sourceObject)
        IAgCrdnSampling.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSamplingBasic._private_init(self, intf)
        IAgCrdnSampling._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingBasic._get_property(self, attrname)
        if IAgCrdnSampling._get_property(self, attrname) is not None: found_prop = IAgCrdnSampling._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSamplingBasic.")

agcls.AgClassCatalog.add_catalog_entry("{CB786C50-8D9C-4333-A985-FFD2ADD20206}", AgCrdnSamplingBasic)


class AgCrdnSamplingCurvatureTolerance(IAgCrdnSamplingCurvatureTolerance, IAgCrdnSamplingMethod):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingCurvatureTolerance.__init__(self, sourceObject)
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSamplingCurvatureTolerance._private_init(self, intf)
        IAgCrdnSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingCurvatureTolerance._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingCurvatureTolerance._get_property(self, attrname)
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSamplingCurvatureTolerance.")

agcls.AgClassCatalog.add_catalog_entry("{EF49B404-27D2-4AC5-BB5E-EA223A237922}", AgCrdnSamplingCurvatureTolerance)


class AgCrdnSamplingFixedStep(IAgCrdnSamplingFixedStep, IAgCrdnSamplingMethod):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingFixedStep.__init__(self, sourceObject)
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSamplingFixedStep._private_init(self, intf)
        IAgCrdnSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingFixedStep._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingFixedStep._get_property(self, attrname)
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSamplingFixedStep.")

agcls.AgClassCatalog.add_catalog_entry("{9B7D520F-7835-4E84-BCA4-D748C73CB609}", AgCrdnSamplingFixedStep)


class AgCrdnSamplingMethod(IAgCrdnSamplingMethod):
    """A sampling method."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSamplingMethod.")

agcls.AgClassCatalog.add_catalog_entry("{D77F1444-C9BC-4C9C-91A2-A5F9DE172AB8}", AgCrdnSamplingMethod)


class AgCrdnSamplingMethodFactory(IAgCrdnSamplingMethodFactory):
    """The factory creates sampling method components."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingMethodFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSamplingMethodFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingMethodFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethodFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSamplingMethodFactory.")

agcls.AgClassCatalog.add_catalog_entry("{E55B6BC9-25B5-46E6-A29A-4E32F9EF3080}", AgCrdnSamplingMethodFactory)


class AgCrdnSamplingRelativeTolerance(IAgCrdnSamplingRelativeTolerance, IAgCrdnSamplingMethod):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingRelativeTolerance.__init__(self, sourceObject)
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSamplingRelativeTolerance._private_init(self, intf)
        IAgCrdnSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingRelativeTolerance._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingRelativeTolerance._get_property(self, attrname)
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSamplingRelativeTolerance.")

agcls.AgClassCatalog.add_catalog_entry("{5FBC3E6B-8097-4482-A1BA-DAA0083FE904}", AgCrdnSamplingRelativeTolerance)


class AgCrdnSatisfactionConditionFilter(IAgCrdnSatisfactionConditionFilter, IAgCrdnPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IAgCrdnSatisfactionConditionFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSatisfactionConditionFilter._private_init(self, intf)
        IAgCrdnPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnSatisfactionConditionFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSatisfactionConditionFilter.")

agcls.AgClassCatalog.add_catalog_entry("{3DD67B2F-2C0A-4355-A154-08E47A93AFCF}", AgCrdnSatisfactionConditionFilter)


class AgCrdnSignalDelay(IAgCrdnSignalDelay, IAgCrdn):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        IAgCrdnSignalDelay.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSignalDelay._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSignalDelay._get_property(self, attrname) is not None: found_prop = IAgCrdnSignalDelay._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSignalDelay.")

agcls.AgClassCatalog.add_catalog_entry("{71744841-D938-44BE-8336-2B54F06CF443}", AgCrdnSignalDelay)


class AgCrdnSignalDelayBasic(IAgCrdnSignalDelayBasic, IAgCrdnSignalDelay, IAgCrdn):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        IAgCrdnSignalDelayBasic.__init__(self, sourceObject)
        IAgCrdnSignalDelay.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSignalDelayBasic._private_init(self, intf)
        IAgCrdnSignalDelay._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSignalDelayBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnSignalDelayBasic._get_property(self, attrname)
        if IAgCrdnSignalDelay._get_property(self, attrname) is not None: found_prop = IAgCrdnSignalDelay._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSignalDelayBasic.")

agcls.AgClassCatalog.add_catalog_entry("{0763A330-475A-4E4E-AB26-8943A8CC1C92}", AgCrdnSignalDelayBasic)


class AgCrdnVolumeCalcFactory(IAgCrdnVolumeCalcFactory):
    """The factory is used to create instances of volume calcs."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcFactory.")

agcls.AgClassCatalog.add_catalog_entry("{80956ae5-fb8c-4ce4-930f-56b362d07cec}", AgCrdnVolumeCalcFactory)


class AgCrdnVolumeFactory(IAgCrdnVolumeFactory):
    """The factory is used to create instances of volumes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeFactory.")

agcls.AgClassCatalog.add_catalog_entry("{F9497BD8-A985-4054-8ADE-9042DE66125F}", AgCrdnVolumeFactory)


class AgCrdnVolumeGridFactory(IAgCrdnVolumeGridFactory):
    """The factory is used to create instances of volume grids."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridFactory.")

agcls.AgClassCatalog.add_catalog_entry("{F6359611-FB48-4B00-9017-01A4BE2B76E5}", AgCrdnVolumeGridFactory)


class AgCrdnGridCoordinateDefinition(IAgCrdnGridCoordinateDefinition):
    """Defines a set of coordinate values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridCoordinateDefinition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnGridCoordinateDefinition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridCoordinateDefinition._get_property(self, attrname) is not None: found_prop = IAgCrdnGridCoordinateDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnGridCoordinateDefinition.")

agcls.AgClassCatalog.add_catalog_entry("{CCE5BC10-615F-441F-95AE-CB4CC0A7C62A}", AgCrdnGridCoordinateDefinition)


class AgCrdnGridValuesCustom(IAgCrdnGridValuesCustom, IAgCrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesCustom.__init__(self, sourceObject)
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnGridValuesCustom._private_init(self, intf)
        IAgCrdnGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesCustom._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesCustom._get_property(self, attrname)
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnGridValuesCustom.")

agcls.AgClassCatalog.add_catalog_entry("{B50CCBA5-A969-40E1-86B3-96DAE5D2A3E3}", AgCrdnGridValuesCustom)


class AgCrdnGridValuesFixedNumberOfSteps(IAgCrdnGridValuesFixedNumberOfSteps, IAgCrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesFixedNumberOfSteps.__init__(self, sourceObject)
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnGridValuesFixedNumberOfSteps._private_init(self, intf)
        IAgCrdnGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesFixedNumberOfSteps._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesFixedNumberOfSteps._get_property(self, attrname)
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnGridValuesFixedNumberOfSteps.")

agcls.AgClassCatalog.add_catalog_entry("{DDD7F78E-13DC-4417-8AE5-B43BB1511AFC}", AgCrdnGridValuesFixedNumberOfSteps)


class AgCrdnGridValuesFixedStep(IAgCrdnGridValuesFixedStep, IAgCrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesFixedStep.__init__(self, sourceObject)
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnGridValuesFixedStep._private_init(self, intf)
        IAgCrdnGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesFixedStep._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesFixedStep._get_property(self, attrname)
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnGridValuesFixedStep.")

agcls.AgClassCatalog.add_catalog_entry("{0942EA2D-33DE-41B5-98BE-E53E659EC81D}", AgCrdnGridValuesFixedStep)


class AgCrdnGridValuesMethod(IAgCrdnGridValuesMethod):
    """A grid values method."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnGridValuesMethod.")

agcls.AgClassCatalog.add_catalog_entry("{D1D242BF-73F3-443A-AB46-64EAA02C5F37}", AgCrdnGridValuesMethod)


class AgCrdnLightTimeDelay(IAgCrdnLightTimeDelay):
    """Manage Light Time Delay options.."""
    def __init__(self, sourceObject=None):
        IAgCrdnLightTimeDelay.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnLightTimeDelay._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnLightTimeDelay._get_property(self, attrname) is not None: found_prop = IAgCrdnLightTimeDelay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnLightTimeDelay.")

agcls.AgClassCatalog.add_catalog_entry("{085E2242-4392-4F35-857E-A46A72EADE70}", AgCrdnLightTimeDelay)


class AgCrdnVolume(IAgCrdnVolume, IAgCrdn):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolume.")

agcls.AgClassCatalog.add_catalog_entry("{299D5D3F-7E12-4747-BFD3-2B5CADBAD8EE}", AgCrdnVolume)


class AgCrdnVolumeCalc(IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalc.")

agcls.AgClassCatalog.add_catalog_entry("{d014bfd1-130d-4dc4-a841-76c75bc08f9c}", AgCrdnVolumeCalc)


class AgCrdnVolumeCalcAltitude(IAgCrdnVolumeCalcAltitude, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc altitude interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcAltitude.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcAltitude._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcAltitude._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcAltitude._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcAltitude.")

agcls.AgClassCatalog.add_catalog_entry("{4e3c369c-c189-48ce-8e93-f0c6478f0abe}", AgCrdnVolumeCalcAltitude)


class AgCrdnVolumeCalcAngleOffVector(IAgCrdnVolumeCalcAngleOffVector, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc angle off vector interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcAngleOffVector.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcAngleOffVector._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcAngleOffVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcAngleOffVector._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcAngleOffVector.")

agcls.AgClassCatalog.add_catalog_entry("{e37c954b-d3d5-4d2e-91b6-0ae4f8380620}", AgCrdnVolumeCalcAngleOffVector)


class AgCrdnVolumeCalcConditionSatMetric(IAgCrdnVolumeCalcConditionSatMetric, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc condition satisfaction interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcConditionSatMetric.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcConditionSatMetric._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcConditionSatMetric._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcConditionSatMetric._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcConditionSatMetric.")

agcls.AgClassCatalog.add_catalog_entry("{589b39d3-7b75-4fe8-8fb2-1c7e5e247fea}", AgCrdnVolumeCalcConditionSatMetric)


class AgCrdnVolumeCalcDelayRange(IAgCrdnVolumeCalcDelayRange, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc propagation delay to location interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcDelayRange.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcDelayRange._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcDelayRange._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcDelayRange._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcDelayRange.")

agcls.AgClassCatalog.add_catalog_entry("{bd9388e8-e5f8-4ba9-9371-4ff8fc1ed33c}", AgCrdnVolumeCalcDelayRange)


class AgCrdnVolumeCalcFile(IAgCrdnVolumeCalcFile, IAgCrdnVolumeCalc, IAgCrdn):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcFile.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcFile._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcFile._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcFile._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcFile.")

agcls.AgClassCatalog.add_catalog_entry("{188f96c6-9568-4609-9944-dfc5fb7247c5}", AgCrdnVolumeCalcFile)


class AgCrdnVolumeCalcFromScalar(IAgCrdnVolumeCalcFromScalar, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc scalar to location interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcFromScalar.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcFromScalar._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcFromScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcFromScalar._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcFromScalar.")

agcls.AgClassCatalog.add_catalog_entry("{73219623-93c0-4c6e-961a-7fae5dfe9234}", AgCrdnVolumeCalcFromScalar)


class AgCrdnVolumeCalcRange(IAgCrdnVolumeCalcRange, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc distance to location interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcRange.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcRange._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcRange._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcRange._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcRange.")

agcls.AgClassCatalog.add_catalog_entry("{7f1aa95f-e8d6-4faf-925b-98785243ba67}", AgCrdnVolumeCalcRange)


class AgCrdnVolumeCalcSolarIntensity(IAgCrdnVolumeCalcSolarIntensity, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc solar intensityn interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcSolarIntensity.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCalcSolarIntensity._private_init(self, intf)
        IAgCrdnVolumeCalc._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcSolarIntensity._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcSolarIntensity._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCalcSolarIntensity.")

agcls.AgClassCatalog.add_catalog_entry("{7796e871-d645-4f65-a3dc-de687b6fbcd5}", AgCrdnVolumeCalcSolarIntensity)


class AgCrdnVolumeCombined(IAgCrdnVolumeCombined, IAgCrdnVolume, IAgCrdn):
    """A combined volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCombined.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeCombined._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCombined._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCombined._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeCombined.")

agcls.AgClassCatalog.add_catalog_entry("{7ECD2E89-B432-47C3-A80F-AF6429E66746}", AgCrdnVolumeCombined)


class AgCrdnVolumeFromCalc(IAgCrdnVolumeFromCalc, IAgCrdnVolume, IAgCrdn):
    """An volume from calc volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromCalc.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeFromCalc._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromCalc._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeFromCalc.")

agcls.AgClassCatalog.add_catalog_entry("{0F2AC0BF-4645-4C7F-9660-A894E267FD59}", AgCrdnVolumeFromCalc)


class AgCrdnVolumeFromCondition(IAgCrdnVolumeFromCondition, IAgCrdnVolume, IAgCrdn):
    """A volume from conditioninterface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromCondition.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeFromCondition._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromCondition._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeFromCondition.")

agcls.AgClassCatalog.add_catalog_entry("{A2546B12-78BF-4F8F-87C2-31BC73DA265B}", AgCrdnVolumeFromCondition)


class AgCrdnVolumeFromGrid(IAgCrdnVolumeFromGrid, IAgCrdnVolume, IAgCrdn):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromGrid.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeFromGrid._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromGrid._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeFromGrid.")

agcls.AgClassCatalog.add_catalog_entry("{D49FE282-4C05-4097-970C-1282997378E9}", AgCrdnVolumeFromGrid)


class AgCrdnVolumeFromTimeSatisfaction(IAgCrdnVolumeFromTimeSatisfaction, IAgCrdnVolume, IAgCrdn):
    """An volume from time satisfaction volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromTimeSatisfaction.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeFromTimeSatisfaction._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromTimeSatisfaction._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromTimeSatisfaction._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeFromTimeSatisfaction.")

agcls.AgClassCatalog.add_catalog_entry("{29ECFCF5-9E5E-4E17-99AA-0B312227CFBF}", AgCrdnVolumeFromTimeSatisfaction)


class AgCrdnVolumeGrid(IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGrid._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGrid.")

agcls.AgClassCatalog.add_catalog_entry("{B7068C38-74D7-4F22-B0C4-A0DBA06DF373}", AgCrdnVolumeGrid)


class AgCrdnVolumeGridBearingAlt(IAgCrdnVolumeGridBearingAlt, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid bearing alt (Surface Bearing) interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridBearingAlt.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridBearingAlt._private_init(self, intf)
        IAgCrdnVolumeGrid._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridBearingAlt._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridBearingAlt._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridBearingAlt.")

agcls.AgClassCatalog.add_catalog_entry("{ED60A16E-82F8-4E0A-9F07-CF8DF05C985A}", AgCrdnVolumeGridBearingAlt)


class AgCrdnVolumeGridCartesian(IAgCrdnVolumeGridCartesian, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid Cartesian interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridCartesian.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridCartesian._private_init(self, intf)
        IAgCrdnVolumeGrid._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridCartesian._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridCartesian._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridCartesian.")

agcls.AgClassCatalog.add_catalog_entry("{AF15D0A4-BB42-4762-A761-9BD11DC948D0}", AgCrdnVolumeGridCartesian)


class AgCrdnVolumeGridConstrained(IAgCrdnVolumeGridConstrained, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid constrained interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridConstrained.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridConstrained._private_init(self, intf)
        IAgCrdnVolumeGrid._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridConstrained._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridConstrained._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridConstrained.")

agcls.AgClassCatalog.add_catalog_entry("{253FC52C-5554-4A53-AE3D-624316ECFFFD}", AgCrdnVolumeGridConstrained)


class AgCrdnVolumeGridCylindrical(IAgCrdnVolumeGridCylindrical, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid cylindrical interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridCylindrical.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridCylindrical._private_init(self, intf)
        IAgCrdnVolumeGrid._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridCylindrical._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridCylindrical._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridCylindrical.")

agcls.AgClassCatalog.add_catalog_entry("{55C6A7AA-5354-4DF1-9A0E-F62CB01115C8}", AgCrdnVolumeGridCylindrical)


class AgCrdnVolumeGridLatLonAlt(IAgCrdnVolumeGridLatLonAlt, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridLatLonAlt.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridLatLonAlt._private_init(self, intf)
        IAgCrdnVolumeGrid._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridLatLonAlt._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridLatLonAlt._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridLatLonAlt.")

agcls.AgClassCatalog.add_catalog_entry("{89C10FC4-4031-4B63-9C55-E092DDF3839D}", AgCrdnVolumeGridLatLonAlt)


class AgCrdnVolumeGridResult(IAgCrdnVolumeGridResult):
    """An interface that generates Volume Grid results."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridResult._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridResult.")

agcls.AgClassCatalog.add_catalog_entry("{43B95CA7-5CCA-4477-9F37-63A86CD9DEBB}", AgCrdnVolumeGridResult)


class AgCrdnVolumeGridSpherical(IAgCrdnVolumeGridSpherical, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid spherical interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridSpherical.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeGridSpherical._private_init(self, intf)
        IAgCrdnVolumeGrid._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridSpherical._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridSpherical._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeGridSpherical.")

agcls.AgClassCatalog.add_catalog_entry("{0DFD2937-3181-4895-AB05-A45FFD744964}", AgCrdnVolumeGridSpherical)


class AgCrdnVolumeInview(IAgCrdnVolumeInview, IAgCrdnVolume, IAgCrdn):
    """An Inview volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeInview.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeInview._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeInview._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeInview._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeInview.")

agcls.AgClassCatalog.add_catalog_entry("{DC8CB747-2714-4F73-8BD6-ED974F0B03AB}", AgCrdnVolumeInview)


class AgCrdnVolumeLighting(IAgCrdnVolumeLighting, IAgCrdnVolume, IAgCrdn):
    """A lighting volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeLighting.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeLighting._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeLighting._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeLighting._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeLighting.")

agcls.AgClassCatalog.add_catalog_entry("{B9ACC019-A8DD-4342-ADE9-1335215F0FAF}", AgCrdnVolumeLighting)


class AgCrdnVolumeOverTime(IAgCrdnVolumeOverTime, IAgCrdnVolume, IAgCrdn):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeOverTime.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVolumeOverTime._private_init(self, intf)
        IAgCrdnVolume._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeOverTime._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeOverTime._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVolumeOverTime.")

agcls.AgClassCatalog.add_catalog_entry("{F5AB68EE-DCC1-435F-A0C3-133095B01D2D}", AgCrdnVolumeOverTime)


class AgCrdnGeneric(IAgCrdn):
    """Generic VGT component."""
    def __init__(self, sourceObject=None):
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnGeneric.")

agcls.AgClassCatalog.add_catalog_entry("{2909EDFB-9BE2-4BD2-A678-186C9D136937}", AgCrdnGeneric)


class AgCrdnTypeInfo(IAgCrdnTypeInfo):
    """VGT component info."""
    def __init__(self, sourceObject=None):
        IAgCrdnTypeInfo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnTypeInfo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnTypeInfo._get_property(self, attrname) is not None: found_prop = IAgCrdnTypeInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnTypeInfo.")

agcls.AgClassCatalog.add_catalog_entry("{BA26887C-6DFE-4F18-96D8-5694296568D2}", AgCrdnTypeInfo)


class AgCrdnInstance(IAgCrdnContext, IAgCrdnInstance):
    """Enables to obtain information about the parent object that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IAgCrdnContext.__init__(self, sourceObject)
        IAgCrdnInstance.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnContext._private_init(self, intf)
        IAgCrdnInstance._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnContext._get_property(self, attrname) is not None: found_prop = IAgCrdnContext._get_property(self, attrname)
        if IAgCrdnInstance._get_property(self, attrname) is not None: found_prop = IAgCrdnInstance._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnInstance.")

agcls.AgClassCatalog.add_catalog_entry("{28241775-2044-4AD1-BC1D-D5B345437415}", AgCrdnInstance)


class AgCrdnTemplate(IAgCrdnContext, IAgCrdnTemplate):
    """Enables to obtain information about the STK class that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IAgCrdnContext.__init__(self, sourceObject)
        IAgCrdnTemplate.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnContext._private_init(self, intf)
        IAgCrdnTemplate._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnContext._get_property(self, attrname) is not None: found_prop = IAgCrdnContext._get_property(self, attrname)
        if IAgCrdnTemplate._get_property(self, attrname) is not None: found_prop = IAgCrdnTemplate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnTemplate.")

agcls.AgClassCatalog.add_catalog_entry("{DB2ABC0D-53EC-43C9-AB85-3ADBDC10CFE3}", AgCrdnTemplate)


class AgCrdnPointRefTo(IAgCrdnPointRefTo, IAgCrdnRefTo):
    """Represents a reference to a VGT point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointRefTo._private_init(self, intf)
        IAgCrdnRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnPointRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointRefTo.")

agcls.AgClassCatalog.add_catalog_entry("{33A043CD-6D36-414A-B73C-9DA3ABDE4C6F}", AgCrdnPointRefTo)


class AgCrdnVectorRefTo(IAgCrdnVectorRefTo, IAgCrdnRefTo):
    """Represents a vector reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorRefTo._private_init(self, intf)
        IAgCrdnRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorRefTo.")

agcls.AgClassCatalog.add_catalog_entry("{76ABF2B5-C60E-4B80-84BA-3F2345E357A6}", AgCrdnVectorRefTo)


class AgCrdnAxesRefTo(IAgCrdnAxesRefTo, IAgCrdnRefTo):
    """Represents a reference to a VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesRefTo._private_init(self, intf)
        IAgCrdnRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesRefTo.")

agcls.AgClassCatalog.add_catalog_entry("{ABAD0C95-5570-461A-9DA0-FD800B10DB20}", AgCrdnAxesRefTo)


class AgCrdnAngleRefTo(IAgCrdnAngleRefTo, IAgCrdnRefTo):
    """Represents a reference to a VGT angle."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleRefTo._private_init(self, intf)
        IAgCrdnRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleRefTo.")

agcls.AgClassCatalog.add_catalog_entry("{E1C8DFF6-65AA-4A6B-B160-7315BD795133}", AgCrdnAngleRefTo)


class AgCrdnSystemRefTo(IAgCrdnSystemRefTo, IAgCrdnRefTo):
    """Represents a System reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSystemRefTo._private_init(self, intf)
        IAgCrdnRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSystemRefTo.")

agcls.AgClassCatalog.add_catalog_entry("{4C6DEAA3-3DD0-439F-A58F-A2BC329384A8}", AgCrdnSystemRefTo)


class AgCrdnPlaneRefTo(IAgCrdnPlaneRefTo, IAgCrdnRefTo):
    """Represents a Plane reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneRefTo._private_init(self, intf)
        IAgCrdnRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneRefTo.")

agcls.AgClassCatalog.add_catalog_entry("{C24A1C1D-EEF3-43DB-83BF-04F12E85B155}", AgCrdnPlaneRefTo)


class AgCrdnVector(IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A generic vector class."""
    def __init__(self, sourceObject=None):
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVector.")

agcls.AgClassCatalog.add_catalog_entry("{64392436-52D5-4274-9483-E10C56BBD037}", AgCrdnVector)


class AgCrdnAxesLabels(IAgCrdnAxesLabels):
    """Allows configuring the VGT axes labels."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesLabels.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesLabels._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesLabels._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesLabels.")

agcls.AgClassCatalog.add_catalog_entry("{AC9F13AD-1E42-4695-AC74-6259D2013E4F}", AgCrdnAxesLabels)


class AgCrdnAxes(IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """A generic axes class."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxes.")

agcls.AgClassCatalog.add_catalog_entry("{50F5DD10-4D83-4603-94ED-BF7514C26282}", AgCrdnAxes)


class AgCrdnPoint(IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """A generic VGT point class."""
    def __init__(self, sourceObject=None):
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPoint.")

agcls.AgClassCatalog.add_catalog_entry("{0092C129-467E-4B36-B971-C53F65481DA9}", AgCrdnPoint)


class AgCrdnSystem(IAgCrdnSystem, IAgCrdnTimeProperties, IAgCrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystem.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSystem._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnSystem._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSystem.")

agcls.AgClassCatalog.add_catalog_entry("{20F29E1B-F72A-4B9C-B13B-04E8F1CCAEA6}", AgCrdnSystem)


class AgCrdnAngle(IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngle._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngle.")

agcls.AgClassCatalog.add_catalog_entry("{C3F96DA3-00EC-4E20-A66C-B3506100496B}", AgCrdnAngle)


class AgCrdnPlaneLabels(IAgCrdnPlaneLabels):
    """Allows configuring the X and Y axes labels."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneLabels.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneLabels._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneLabels._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneLabels.")

agcls.AgClassCatalog.add_catalog_entry("{E40312E9-2D04-4F38-8E35-0C1F5CC66B79}", AgCrdnPlaneLabels)


class AgCrdnPlane(IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlane._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlane.")

agcls.AgClassCatalog.add_catalog_entry("{2E6EAA85-8440-4C4E-97FE-76491E05098A}", AgCrdnPlane)


class AgCrdnAxesAlignedAndConstrained(IAgCrdnAxesAlignedAndConstrained, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAlignedAndConstrained.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesAlignedAndConstrained._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAlignedAndConstrained._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAlignedAndConstrained._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesAlignedAndConstrained.")

agcls.AgClassCatalog.add_catalog_entry("{46BB7D5B-6593-434F-B288-BF1445920A2C}", AgCrdnAxesAlignedAndConstrained)


class AgCrdnAxesAngularOffset(IAgCrdnAxesAngularOffset, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAngularOffset.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesAngularOffset._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAngularOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAngularOffset._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesAngularOffset.")

agcls.AgClassCatalog.add_catalog_entry("{64503F8B-96E7-455B-B589-2578ADE1214B}", AgCrdnAxesAngularOffset)


class AgCrdnAxesFixedAtEpoch(IAgCrdnAxesFixedAtEpoch, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes based on another set fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesFixedAtEpoch.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesFixedAtEpoch._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFixedAtEpoch._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesFixedAtEpoch.")

agcls.AgClassCatalog.add_catalog_entry("{BEEE1271-F9F7-4C9E-A6C9-4337AA4F86AC}", AgCrdnAxesFixedAtEpoch)


class AgCrdnAxesBPlane(IAgCrdnAxesBPlane, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """B-Plane axes using the selected target body and reference vector."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesBPlane.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesBPlane._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesBPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesBPlane._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesBPlane.")

agcls.AgClassCatalog.add_catalog_entry("{E0F714EA-31E4-4F92-876F-BDD3183C29B5}", AgCrdnAxesBPlane)


class AgCrdnAxesCustomScript(IAgCrdnAxesCustomScript, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Customized axes offset with respect to a set of reference Axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesCustomScript.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesCustomScript._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesCustomScript._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesCustomScript._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesCustomScript.")

agcls.AgClassCatalog.add_catalog_entry("{BC7A87DC-118E-46ED-8657-90DF42B7B101}", AgCrdnAxesCustomScript)


class AgCrdnAxesAttitudeFile(IAgCrdnAxesAttitudeFile, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes specified by data from a file."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAttitudeFile.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesAttitudeFile._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAttitudeFile._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAttitudeFile._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesAttitudeFile.")

agcls.AgClassCatalog.add_catalog_entry("{3505D063-9E1B-4964-9865-FFE41F64C8CF}", AgCrdnAxesAttitudeFile)


class AgCrdnAxesFixed(IAgCrdnAxesFixed, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesFixed.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesFixed._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesFixed._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFixed._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesFixed.")

agcls.AgClassCatalog.add_catalog_entry("{4AE41C73-3C82-405B-B7D2-A6D1BE7EE2EE}", AgCrdnAxesFixed)


class AgCrdnAxesModelAttach(IAgCrdnAxesModelAttach, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesModelAttach.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesModelAttach._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesModelAttach._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesModelAttach._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesModelAttach.")

agcls.AgClassCatalog.add_catalog_entry("{816C612A-13DD-4812-BFDE-E3861F8C39FD}", AgCrdnAxesModelAttach)


class AgCrdnAxesSpinning(IAgCrdnAxesSpinning, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSpinning.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesSpinning._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSpinning._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSpinning._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesSpinning.")

agcls.AgClassCatalog.add_catalog_entry("{C0FB8B6D-84CC-4553-ADA9-2F7D91A83AB6}", AgCrdnAxesSpinning)


class AgCrdnAxesOnSurface(IAgCrdnAxesOnSurface, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Topocentric axes located at the reference point's projection on the central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesOnSurface.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesOnSurface._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesOnSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesOnSurface._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesOnSurface.")

agcls.AgClassCatalog.add_catalog_entry("{CE8C301A-A846-44FD-8871-5AB4CAACEF11}", AgCrdnAxesOnSurface)


class AgCrdnAxesTrajectory(IAgCrdnAxesTrajectory, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesTrajectory.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesTrajectory._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesTrajectory._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesTrajectory.")

agcls.AgClassCatalog.add_catalog_entry("{4038771E-73C1-4989-A9AB-4DC37025FACC}", AgCrdnAxesTrajectory)


class AgCrdnAxesLagrangeLibration(IAgCrdnAxesLagrangeLibration, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesLagrangeLibration.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesLagrangeLibration._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesLagrangeLibration._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesLagrangeLibration._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesLagrangeLibration.")

agcls.AgClassCatalog.add_catalog_entry("{16315085-7C87-4A20-865C-0F419A5CDA2F}", AgCrdnAxesLagrangeLibration)


class AgCrdnAxesCommonTasks(IAgCrdnAxesCommonTasks):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesCommonTasks.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesCommonTasks._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesCommonTasks._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesCommonTasks.")

agcls.AgClassCatalog.add_catalog_entry("{07D4865C-78F1-4B3A-9756-D70050613D4A}", AgCrdnAxesCommonTasks)


class AgCrdnAxesAtTimeInstant(IAgCrdnAxesAtTimeInstant, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnAxes):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAtTimeInstant.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesAtTimeInstant._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAtTimeInstant._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesAtTimeInstant.")

agcls.AgClassCatalog.add_catalog_entry("{3845C20A-A6E2-45A0-A748-10E9B565C48D}", AgCrdnAxesAtTimeInstant)


class AgCrdnAxesPlugin(IAgCrdnAxesPlugin, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnAxes):
    """A VGT axes plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesPlugin.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesPlugin._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnAxes._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesPlugin._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesPlugin.")

agcls.AgClassCatalog.add_catalog_entry("{C494C46D-EBC6-45B9-B2E7-C9FF7E75467D}", AgCrdnAxesPlugin)


class AgCrdnAngleBetweenVectors(IAgCrdnAngleBetweenVectors, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between two vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleBetweenVectors.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleBetweenVectors._private_init(self, intf)
        IAgCrdnAngle._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleBetweenVectors._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleBetweenVectors._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleBetweenVectors.")

agcls.AgClassCatalog.add_catalog_entry("{2F0AA430-85D0-4479-9540-B1B64EB3B530}", AgCrdnAngleBetweenVectors)


class AgCrdnAngleBetweenPlanes(IAgCrdnAngleBetweenPlanes, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between two planes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleBetweenPlanes.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleBetweenPlanes._private_init(self, intf)
        IAgCrdnAngle._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleBetweenPlanes._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleBetweenPlanes._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleBetweenPlanes.")

agcls.AgClassCatalog.add_catalog_entry("{30C2886F-8792-475D-9E42-975308B1B94E}", AgCrdnAngleBetweenPlanes)


class AgCrdnAngleDihedral(IAgCrdnAngleDihedral, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between two vectors about an axis."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleDihedral.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleDihedral._private_init(self, intf)
        IAgCrdnAngle._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleDihedral._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleDihedral._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleDihedral.")

agcls.AgClassCatalog.add_catalog_entry("{550855BB-E8F1-440B-BA5C-024ACE2E2A17}", AgCrdnAngleDihedral)


class AgCrdnAngleRotation(IAgCrdnAngleRotation, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleRotation.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleRotation._private_init(self, intf)
        IAgCrdnAngle._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleRotation._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleRotation._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleRotation.")

agcls.AgClassCatalog.add_catalog_entry("{AD8B87A3-8407-42AB-B6CA-8E83450C32C1}", AgCrdnAngleRotation)


class AgCrdnAngleToPlane(IAgCrdnAngleToPlane, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between a vector and a plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleToPlane.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleToPlane._private_init(self, intf)
        IAgCrdnAngle._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleToPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleToPlane._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleToPlane.")

agcls.AgClassCatalog.add_catalog_entry("{8CE8877B-1078-41CD-AEE6-B9DDD92F8201}", AgCrdnAngleToPlane)


class AgCrdnPlaneNormal(IAgCrdnPlaneNormal, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneNormal.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneNormal._private_init(self, intf)
        IAgCrdnPlane._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneNormal._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneNormal._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneNormal.")

agcls.AgClassCatalog.add_catalog_entry("{0AED319D-7B6C-462B-882B-D363F7A2A86C}", AgCrdnPlaneNormal)


class AgCrdnPlaneQuadrant(IAgCrdnPlaneQuadrant, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A plane based on a selected Quadrant of a reference system."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneQuadrant.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneQuadrant._private_init(self, intf)
        IAgCrdnPlane._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneQuadrant._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneQuadrant._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneQuadrant.")

agcls.AgClassCatalog.add_catalog_entry("{8330CE61-25F6-4F92-AE2E-BDB566BA42F3}", AgCrdnPlaneQuadrant)


class AgCrdnPlaneTrajectory(IAgCrdnPlaneTrajectory, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneTrajectory.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneTrajectory._private_init(self, intf)
        IAgCrdnPlane._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneTrajectory._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneTrajectory.")

agcls.AgClassCatalog.add_catalog_entry("{7BD18F79-6788-48B1-AFB5-243D62C01177}", AgCrdnPlaneTrajectory)


class AgCrdnPlaneTriad(IAgCrdnPlaneTriad, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A Plane containing points PointA, PointB and ReferencePont with the first axis aligned with the direction from the ReferencePoint to PointA and the second axis toward the direction from the ReferencePoint to PointB."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneTriad.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneTriad._private_init(self, intf)
        IAgCrdnPlane._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneTriad._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneTriad._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneTriad.")

agcls.AgClassCatalog.add_catalog_entry("{8A4D3940-BD08-4D5C-A171-E0AC90DEB5F4}", AgCrdnPlaneTriad)


class AgCrdnPlaneTwoVector(IAgCrdnPlaneTwoVector, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneTwoVector.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneTwoVector._private_init(self, intf)
        IAgCrdnPlane._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneTwoVector._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneTwoVector._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneTwoVector.")

agcls.AgClassCatalog.add_catalog_entry("{49a61e7a-baba-48fd-9d9d-61f91c520291}", AgCrdnPlaneTwoVector)


class AgCrdnPointBPlane(IAgCrdnPointBPlane, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """B-Plane point using the selected target body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointBPlane.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointBPlane._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointBPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPointBPlane._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointBPlane.")

agcls.AgClassCatalog.add_catalog_entry("{E62329EB-83D1-47CE-8B5B-B795995A2270}", AgCrdnPointBPlane)


class AgCrdnPointFile(IAgCrdnPointFile, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point specified by data from a file."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointFile.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointFile._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointFile._get_property(self, attrname) is not None: found_prop = IAgCrdnPointFile._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointFile.")

agcls.AgClassCatalog.add_catalog_entry("{0E71C927-09CA-4A90-95F0-CB87E244CE72}", AgCrdnPointFile)


class AgCrdnPointFixedInSystem(IAgCrdnPointFixedInSystem, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointFixedInSystem.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointFixedInSystem._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointFixedInSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnPointFixedInSystem._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointFixedInSystem.")

agcls.AgClassCatalog.add_catalog_entry("{9FA10E06-094A-446C-BE9A-5BA397776778}", AgCrdnPointFixedInSystem)


class AgCrdnPointGrazing(IAgCrdnPointGrazing, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointGrazing.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointGrazing._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointGrazing._get_property(self, attrname) is not None: found_prop = IAgCrdnPointGrazing._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointGrazing.")

agcls.AgClassCatalog.add_catalog_entry("{C7D8A954-B6ED-43A0-8B2C-C58B06DCDFF7}", AgCrdnPointGrazing)


class AgCrdnPointGlint(IAgCrdnPointGlint, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point on central body surface that reflects from source to observer."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointGlint.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointGlint._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointGlint._get_property(self, attrname) is not None: found_prop = IAgCrdnPointGlint._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointGlint.")

agcls.AgClassCatalog.add_catalog_entry("{68F85553-0FA2-459D-93AC-BD4D68A01F6F}", AgCrdnPointGlint)


class AgCrdnPointCovarianceGrazing(IAgCrdnPointCovarianceGrazing, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCovarianceGrazing.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointCovarianceGrazing._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCovarianceGrazing._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCovarianceGrazing._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointCovarianceGrazing.")

agcls.AgClassCatalog.add_catalog_entry("{84D91807-716E-46F4-AB70-53C73FA21C20}", AgCrdnPointCovarianceGrazing)


class AgCrdnPointPlaneIntersection(IAgCrdnPointPlaneIntersection, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point on a plane located along a given direction looking from a given origin."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointPlaneIntersection.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointPlaneIntersection._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointPlaneIntersection._get_property(self, attrname) is not None: found_prop = IAgCrdnPointPlaneIntersection._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointPlaneIntersection.")

agcls.AgClassCatalog.add_catalog_entry("{63F785C4-EC8E-4BCA-AF05-D57BD357D06C}", AgCrdnPointPlaneIntersection)


class AgCrdnPointOnSurface(IAgCrdnPointOnSurface, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The detic subpoint of the reference point as projected onto the central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointOnSurface.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointOnSurface._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointOnSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnPointOnSurface._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointOnSurface.")

agcls.AgClassCatalog.add_catalog_entry("{03ECCFD1-B058-4817-826F-EDE2A6880757}", AgCrdnPointOnSurface)


class AgCrdnPointModelAttach(IAgCrdnPointModelAttach, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointModelAttach.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointModelAttach._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointModelAttach._get_property(self, attrname) is not None: found_prop = IAgCrdnPointModelAttach._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointModelAttach.")

agcls.AgClassCatalog.add_catalog_entry("{15958616-F779-4772-9E54-9B134B69BE89}", AgCrdnPointModelAttach)


class AgCrdnPointSatelliteCollectionEntry(IAgCrdnPointSatelliteCollectionEntry, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSatelliteCollectionEntry.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointSatelliteCollectionEntry._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSatelliteCollectionEntry._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSatelliteCollectionEntry._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointSatelliteCollectionEntry.")

agcls.AgClassCatalog.add_catalog_entry("{d0dacbed-0c16-4de5-b32a-9c7624297014}", AgCrdnPointSatelliteCollectionEntry)


class AgCrdnPointPlaneProjection(IAgCrdnPointPlaneProjection, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointPlaneProjection.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointPlaneProjection._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointPlaneProjection._get_property(self, attrname) is not None: found_prop = IAgCrdnPointPlaneProjection._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointPlaneProjection.")

agcls.AgClassCatalog.add_catalog_entry("{C750AD99-2498-42F6-BBBD-CEB1835E8F3A}", AgCrdnPointPlaneProjection)


class AgCrdnPointLagrangeLibration(IAgCrdnPointLagrangeLibration, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointLagrangeLibration.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointLagrangeLibration._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointLagrangeLibration._get_property(self, attrname) is not None: found_prop = IAgCrdnPointLagrangeLibration._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointLagrangeLibration.")

agcls.AgClassCatalog.add_catalog_entry("{6BF6D976-775A-445D-AD2B-899892F3127E}", AgCrdnPointLagrangeLibration)


class AgCrdnPointCommonTasks(IAgCrdnPointCommonTasks):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCommonTasks.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointCommonTasks._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCommonTasks._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointCommonTasks.")

agcls.AgClassCatalog.add_catalog_entry("{9866644C-E731-465E-A7AA-3F4667C1729E}", AgCrdnPointCommonTasks)


class AgCrdnPointCentBodyIntersect(IAgCrdnPointCentBodyIntersect, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """Point on central body surface along direction vector originating at source point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCentBodyIntersect.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointCentBodyIntersect._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCentBodyIntersect._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCentBodyIntersect._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointCentBodyIntersect.")

agcls.AgClassCatalog.add_catalog_entry("{882047E8-7CB3-489B-B029-33163CBBA583}", AgCrdnPointCentBodyIntersect)


class AgCrdnPointAtTimeInstant(IAgCrdnPointAtTimeInstant, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointAtTimeInstant.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointAtTimeInstant._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnPointAtTimeInstant._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointAtTimeInstant.")

agcls.AgClassCatalog.add_catalog_entry("{8BFB46DF-C6BC-45DA-BAA7-9C996710CFDA}", AgCrdnPointAtTimeInstant)


class AgCrdnPointPlugin(IAgCrdnPointPlugin, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """A VGT point plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointPlugin.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointPlugin._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnPointPlugin._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointPlugin.")

agcls.AgClassCatalog.add_catalog_entry("{8297DC34-1755-4FE7-BA23-2D9CDE487EF1}", AgCrdnPointPlugin)


class AgCrdnPointCBFixedOffset(IAgCrdnPointCBFixedOffset, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """Point specified by fixed components with respect to central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCBFixedOffset.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointCBFixedOffset._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnPoint._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCBFixedOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCBFixedOffset._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointCBFixedOffset.")

agcls.AgClassCatalog.add_catalog_entry("{0C76BDAE-992E-4D61-8D09-E6B2B6923A5B}", AgCrdnPointCBFixedOffset)


class AgCrdnSystemAssembled(IAgCrdnSystemAssembled, IAgCrdnSystem, IAgCrdnTimeProperties, IAgCrdn):
    """A system assembled from an origin point and a set of reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemAssembled.__init__(self, sourceObject)
        IAgCrdnSystem.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSystemAssembled._private_init(self, intf)
        IAgCrdnSystem._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemAssembled._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemAssembled._get_property(self, attrname)
        if IAgCrdnSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnSystem._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSystemAssembled.")

agcls.AgClassCatalog.add_catalog_entry("{CE4E84B1-8CCF-467A-A3ED-274D0943407F}", AgCrdnSystemAssembled)


class AgCrdnSystemOnSurface(IAgCrdnSystemOnSurface, IAgCrdnSystem, IAgCrdnTimeProperties, IAgCrdn):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemOnSurface.__init__(self, sourceObject)
        IAgCrdnSystem.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSystemOnSurface._private_init(self, intf)
        IAgCrdnSystem._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemOnSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemOnSurface._get_property(self, attrname)
        if IAgCrdnSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnSystem._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSystemOnSurface.")

agcls.AgClassCatalog.add_catalog_entry("{073423F9-A59D-4313-B499-C86A45C63513}", AgCrdnSystemOnSurface)


class AgCrdnLLAPosition(IAgCrdnLLAPosition):
    """A position represented by the Latitude, longtitude and Latitude."""
    def __init__(self, sourceObject=None):
        IAgCrdnLLAPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnLLAPosition._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnLLAPosition._get_property(self, attrname) is not None: found_prop = IAgCrdnLLAPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnLLAPosition.")

agcls.AgClassCatalog.add_catalog_entry("{CB962F51-978A-43F9-A88B-AAB62117F93C}", AgCrdnLLAPosition)


class AgCrdnSystemCommonTasks(IAgCrdnSystemCommonTasks):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemCommonTasks.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSystemCommonTasks._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemCommonTasks._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSystemCommonTasks.")

agcls.AgClassCatalog.add_catalog_entry("{EBE7AF41-FC7E-4D82-B522-72B4AA551B41}", AgCrdnSystemCommonTasks)


class AgCrdnVectorAngleRate(IAgCrdnVectorAngleRate, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorAngleRate.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorAngleRate._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorAngleRate._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorAngleRate._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorAngleRate.")

agcls.AgClassCatalog.add_catalog_entry("{5769E079-8E9B-40B2-B2EF-14F202AF5666}", AgCrdnVectorAngleRate)


class AgCrdnVectorApoapsis(IAgCrdnVectorApoapsis, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorApoapsis.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorApoapsis._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorApoapsis._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorApoapsis._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorApoapsis.")

agcls.AgClassCatalog.add_catalog_entry("{22E4138C-29C6-4401-91E0-DF0C00422302}", AgCrdnVectorApoapsis)


class AgCrdnVectorFixedAtEpoch(IAgCrdnVectorFixedAtEpoch, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Based on another vector fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFixedAtEpoch.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorFixedAtEpoch._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFixedAtEpoch._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorFixedAtEpoch.")

agcls.AgClassCatalog.add_catalog_entry("{FA8DB5F5-1F28-40E6-9B86-489E06D61523}", AgCrdnVectorFixedAtEpoch)


class AgCrdnVectorAngularVelocity(IAgCrdnVectorAngularVelocity, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorAngularVelocity.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorAngularVelocity._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorAngularVelocity._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorAngularVelocity._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorAngularVelocity.")

agcls.AgClassCatalog.add_catalog_entry("{2ABC83DB-6F6C-4A91-8597-21BD2715D411}", AgCrdnVectorAngularVelocity)


class AgCrdnVectorConing(IAgCrdnVectorConing, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorConing.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorConing._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorConing._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorConing._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorConing.")

agcls.AgClassCatalog.add_catalog_entry("{74E6F986-E292-4115-84E4-9E9953C163B8}", AgCrdnVectorConing)


class AgCrdnVectorCross(IAgCrdnVectorCross, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """The vector cross product of two vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorCross.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorCross._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorCross._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorCross._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorCross.")

agcls.AgClassCatalog.add_catalog_entry("{88B6E3B7-51CD-45DE-97C0-DCFE834C0111}", AgCrdnVectorCross)


class AgCrdnVectorCustomScript(IAgCrdnVectorCustomScript, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Customized vector components defined with respect to reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorCustomScript.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorCustomScript._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorCustomScript._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorCustomScript._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorCustomScript.")

agcls.AgClassCatalog.add_catalog_entry("{D65CDDC6-21DA-419F-BF72-79C2376648E8}", AgCrdnVectorCustomScript)


class AgCrdnVectorDerivative(IAgCrdnVectorDerivative, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A vector derivative of a vector computed with respect to specified axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDerivative.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorDerivative._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDerivative._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorDerivative.")

agcls.AgClassCatalog.add_catalog_entry("{B81ECB39-CF3E-49AE-8622-F454CD0EA7B2}", AgCrdnVectorDerivative)


class AgCrdnVectorDisplacement(IAgCrdnVectorDisplacement, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector defined by its start and end points."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDisplacement.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorDisplacement._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDisplacement._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDisplacement._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorDisplacement.")

agcls.AgClassCatalog.add_catalog_entry("{6CAADA67-7238-4705-9F74-95596344DED0}", AgCrdnVectorDisplacement)


class AgCrdnVectorTwoPlanesIntersection(IAgCrdnVectorTwoPlanesIntersection, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Defined along the intersection of two planes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorTwoPlanesIntersection.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorTwoPlanesIntersection._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorTwoPlanesIntersection._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorTwoPlanesIntersection._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorTwoPlanesIntersection.")

agcls.AgClassCatalog.add_catalog_entry("{B1145553-76CD-4C1E-AE08-E63E29CF4E46}", AgCrdnVectorTwoPlanesIntersection)


class AgCrdnVectorModelAttach(IAgCrdnVectorModelAttach, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorModelAttach.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorModelAttach._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorModelAttach._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorModelAttach._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorModelAttach.")

agcls.AgClassCatalog.add_catalog_entry("{E95BEEB8-C544-4852-9C82-20080343E585}", AgCrdnVectorModelAttach)


class AgCrdnVectorProjection(IAgCrdnVectorProjection, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A projection of a vector computed with respect to a reference plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorProjection.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorProjection._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorProjection._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorProjection._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorProjection.")

agcls.AgClassCatalog.add_catalog_entry("{7306544A-A8B0-477B-B89D-BA711C9ED600}", AgCrdnVectorProjection)


class AgCrdnVectorScaled(IAgCrdnVectorScaled, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorScaled.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorScaled._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorScaled._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorScaled.")

agcls.AgClassCatalog.add_catalog_entry("{92D80C29-251B-436B-9DA0-D5BA4B262185}", AgCrdnVectorScaled)


class AgCrdnVectorEccentricity(IAgCrdnVectorEccentricity, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorEccentricity.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorEccentricity._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorEccentricity._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorEccentricity._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorEccentricity.")

agcls.AgClassCatalog.add_catalog_entry("{C7F157D7-11EB-4779-955F-98530B9C2608}", AgCrdnVectorEccentricity)


class AgCrdnVectorFixedInAxes(IAgCrdnVectorFixedInAxes, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFixedInAxes.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorFixedInAxes._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFixedInAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFixedInAxes._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorFixedInAxes.")

agcls.AgClassCatalog.add_catalog_entry("{61E9F963-8CFC-4B24-B583-716A64BAE54C}", AgCrdnVectorFixedInAxes)


class AgCrdnVectorLineOfNodes(IAgCrdnVectorLineOfNodes, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorLineOfNodes.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorLineOfNodes._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorLineOfNodes._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorLineOfNodes._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorLineOfNodes.")

agcls.AgClassCatalog.add_catalog_entry("{3D6B3FD1-93C2-4F11-AB10-B749DF633C29}", AgCrdnVectorLineOfNodes)


class AgCrdnVectorOrbitAngularMomentum(IAgCrdnVectorOrbitAngularMomentum, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorOrbitAngularMomentum.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorOrbitAngularMomentum._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorOrbitAngularMomentum._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorOrbitAngularMomentum._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorOrbitAngularMomentum.")

agcls.AgClassCatalog.add_catalog_entry("{2B38A283-7EDA-43E2-9C04-E9964FCA7D91}", AgCrdnVectorOrbitAngularMomentum)


class AgCrdnVectorOrbitNormal(IAgCrdnVectorOrbitNormal, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorOrbitNormal.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorOrbitNormal._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorOrbitNormal._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorOrbitNormal._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorOrbitNormal.")

agcls.AgClassCatalog.add_catalog_entry("{AFBAED88-891B-4EF7-98BD-DEBAF630C0E1}", AgCrdnVectorOrbitNormal)


class AgCrdnVectorPeriapsis(IAgCrdnVectorPeriapsis, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorPeriapsis.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorPeriapsis._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorPeriapsis._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorPeriapsis._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorPeriapsis.")

agcls.AgClassCatalog.add_catalog_entry("{DA81B380-6D7C-48F4-8E7F-472035958B44}", AgCrdnVectorPeriapsis)


class AgCrdnVectorReflection(IAgCrdnVectorReflection, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorReflection.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorReflection._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorReflection._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorReflection._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorReflection.")

agcls.AgClassCatalog.add_catalog_entry("{C35F8BF0-ED12-48BF-8770-EE63DAF4A9B1}", AgCrdnVectorReflection)


class AgCrdnVectorRotationVector(IAgCrdnVectorRotationVector, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorRotationVector.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorRotationVector._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorRotationVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorRotationVector._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorRotationVector.")

agcls.AgClassCatalog.add_catalog_entry("{c599beae-b6c1-495e-8957-a4b9ffc5cb8e}", AgCrdnVectorRotationVector)


class AgCrdnVectorDirectionToStar(IAgCrdnVectorDirectionToStar, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDirectionToStar.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorDirectionToStar._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDirectionToStar._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDirectionToStar._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorDirectionToStar.")

agcls.AgClassCatalog.add_catalog_entry("{147FDFCC-767A-460C-9833-02A582AFCA9C}", AgCrdnVectorDirectionToStar)


class AgCrdnVectorFixedAtTimeInstant(IAgCrdnVectorFixedAtTimeInstant, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFixedAtTimeInstant.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorFixedAtTimeInstant._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFixedAtTimeInstant._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorFixedAtTimeInstant.")

agcls.AgClassCatalog.add_catalog_entry("{BC8737B3-A94E-4B68-857F-81E780C874FD}", AgCrdnVectorFixedAtTimeInstant)


class AgCrdnVectorLinearCombination(IAgCrdnVectorLinearCombination, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Linear combination of two input vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorLinearCombination.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorLinearCombination._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorLinearCombination._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorLinearCombination._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorLinearCombination.")

agcls.AgClassCatalog.add_catalog_entry("{59E2764C-7920-4CDC-B5FF-2590154E1ABE}", AgCrdnVectorLinearCombination)


class AgCrdnVectorProjectAlongVector(IAgCrdnVectorProjectAlongVector, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """A projection of a source vector in the direction of another vector."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorProjectAlongVector.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorProjectAlongVector._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorProjectAlongVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorProjectAlongVector._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorProjectAlongVector.")

agcls.AgClassCatalog.add_catalog_entry("{7B76B999-135B-4AAF-ADEA-444FD759417D}", AgCrdnVectorProjectAlongVector)


class AgCrdnVectorScalarLinearCombination(IAgCrdnVectorScalarLinearCombination, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Linear combination of two input vectors using scalars."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorScalarLinearCombination.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorScalarLinearCombination._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorScalarLinearCombination._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorScalarLinearCombination._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorScalarLinearCombination.")

agcls.AgClassCatalog.add_catalog_entry("{0FB78FA5-9E5F-4A0F-AD73-FB89A0E523F8}", AgCrdnVectorScalarLinearCombination)


class AgCrdnVectorScalarScaled(IAgCrdnVectorScalarScaled, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Scaled version of the input vector using scalar."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorScalarScaled.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorScalarScaled._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorScalarScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorScalarScaled._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorScalarScaled.")

agcls.AgClassCatalog.add_catalog_entry("{9C93B992-687F-4311-B339-DE0DA38409AE}", AgCrdnVectorScalarScaled)


class AgCrdnVectorVelocityAcceleration(IAgCrdnVectorVelocityAcceleration, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Velocity vector of a point in a coordinate system."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorVelocityAcceleration.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorVelocityAcceleration._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorVelocityAcceleration._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorVelocityAcceleration._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorVelocityAcceleration.")

agcls.AgClassCatalog.add_catalog_entry("{75A62225-C09F-4F08-B7FE-9216B02DECF2}", AgCrdnVectorVelocityAcceleration)


class AgCrdnVectorPlugin(IAgCrdnVectorPlugin, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """A VGT vector plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorPlugin.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorPlugin._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorPlugin._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorPlugin.")

agcls.AgClassCatalog.add_catalog_entry("{E105429A-489E-47F6-B827-8E5819FCE917}", AgCrdnVectorPlugin)


class AgCrdnVectorDispSurface(IAgCrdnVectorDispSurface, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDispSurface.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorDispSurface._private_init(self, intf)
        IAgCrdn._private_init(self, intf)
        IAgCrdnTimeProperties._private_init(self, intf)
        IAgCrdnVector._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDispSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDispSurface._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorDispSurface.")

agcls.AgClassCatalog.add_catalog_entry("{ccd4af03-78af-47ae-902a-90860a17daa4}", AgCrdnVectorDispSurface)


class AgCrdnVectorFactory(IAgCrdnVectorFactory):
    """A Factory object to create vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorFactory.")

agcls.AgClassCatalog.add_catalog_entry("{084C11E1-D35D-4F42-83D6-3EF43FEC1E23}", AgCrdnVectorFactory)


class AgCrdnAxesFactory(IAgCrdnAxesFactory):
    """A Factory object to create axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesFactory.")

agcls.AgClassCatalog.add_catalog_entry("{7B3E2402-1E15-43DC-BB48-6E98D377B107}", AgCrdnAxesFactory)


class AgCrdnSystemFactory(IAgCrdnSystemFactory):
    """A Factory class to create VGT systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSystemFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSystemFactory.")

agcls.AgClassCatalog.add_catalog_entry("{01A37414-BA74-4DF3-A007-6A3395C8A859}", AgCrdnSystemFactory)


class AgCrdnPointFactory(IAgCrdnPointFactory):
    """A Factory object to create points."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnPointFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointFactory.")

agcls.AgClassCatalog.add_catalog_entry("{6C79F3B2-8AE5-468A-940F-F0988752B309}", AgCrdnPointFactory)


class AgCrdnPlaneFactory(IAgCrdnPlaneFactory):
    """A Factory object to create VGT planes."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneFactory.")

agcls.AgClassCatalog.add_catalog_entry("{6F83DB0C-0AFB-4831-BED0-63AE2F8FEFFB}", AgCrdnPlaneFactory)


class AgCrdnAngleFactory(IAgCrdnAngleFactory):
    """A Factory object to create angles."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleFactory._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleFactory.")

agcls.AgClassCatalog.add_catalog_entry("{0888F89F-9D77-4FCE-9A08-67FCBE870187}", AgCrdnAngleFactory)


class AgCrdnVectorGroup(IAgCrdnVectorGroup):
    """Access or create VGT vectors associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnVectorGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnVectorGroup.")

agcls.AgClassCatalog.add_catalog_entry("{69ABE9EE-BAA4-40A7-8097-06DBE70D71D5}", AgCrdnVectorGroup)


class AgCrdnPointGroup(IAgCrdnPointGroup):
    """Access or create VGT points associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnPointGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointGroup.")

agcls.AgClassCatalog.add_catalog_entry("{0793BE73-C894-4AF7-BFDB-5D61F5C3B6FD}", AgCrdnPointGroup)


class AgCrdnAngleGroup(IAgCrdnAngleGroup):
    """Access or create VGT angles associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAngleGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAngleGroup.")

agcls.AgClassCatalog.add_catalog_entry("{CF6C41CC-A02E-424C-8E7E-B5BA05F1FAF3}", AgCrdnAngleGroup)


class AgCrdnAxesGroup(IAgCrdnAxesGroup):
    """Access or create VGT axes associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesGroup.")

agcls.AgClassCatalog.add_catalog_entry("{2D792657-9D6E-4B1E-AEAB-B964839C6F94}", AgCrdnAxesGroup)


class AgCrdnPlaneGroup(IAgCrdnPlaneGroup):
    """Represents a VGT Plane component."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPlaneGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPlaneGroup.")

agcls.AgClassCatalog.add_catalog_entry("{15117A82-3EE6-483E-A65E-2A44F60DB355}", AgCrdnPlaneGroup)


class AgCrdnSystemGroup(IAgCrdnSystemGroup):
    """Access or create VGT systems associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnSystemGroup._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnSystemGroup.")

agcls.AgClassCatalog.add_catalog_entry("{65E8F1CC-E68C-4EF6-9A68-443DD01C55E2}", AgCrdnSystemGroup)


class AgCrdnProvider(IAgCrdnProvider):
    """Allows accessing existing Vector Geometry Tool components."""
    def __init__(self, sourceObject=None):
        IAgCrdnProvider.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnProvider._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnProvider._get_property(self, attrname) is not None: found_prop = IAgCrdnProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnProvider.")

agcls.AgClassCatalog.add_catalog_entry("{D9031FE1-81E1-4818-944D-5F00FC3EC97D}", AgCrdnProvider)


class AgCrdnRoot(IAgCrdnRoot):
    """Represents a VGT root."""
    def __init__(self, sourceObject=None):
        IAgCrdnRoot.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnRoot._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnRoot._get_property(self, attrname) is not None: found_prop = IAgCrdnRoot._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnRoot.")

agcls.AgClassCatalog.add_catalog_entry("{26E18B6F-19CA-4537-B6B3-D307DAADCDBB}", AgCrdnRoot)


class AgCrdnWellKnownEarthSystems(IAgCrdnWellKnownEarthSystems):
    """Well-known Earth's coordinate systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownEarthSystems.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnWellKnownEarthSystems._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownEarthSystems._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownEarthSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnWellKnownEarthSystems.")

agcls.AgClassCatalog.add_catalog_entry("{9CE3EA8C-78D7-4C9E-9D35-4E34DBA9FD19}", AgCrdnWellKnownEarthSystems)


class AgCrdnWellKnownEarthAxes(IAgCrdnWellKnownEarthAxes):
    """Well-known Earth's axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownEarthAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnWellKnownEarthAxes._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownEarthAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownEarthAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnWellKnownEarthAxes.")

agcls.AgClassCatalog.add_catalog_entry("{B79CA8BC-D4BA-4F76-9278-AB7C9C537859}", AgCrdnWellKnownEarthAxes)


class AgCrdnWellKnownSunSystems(IAgCrdnWellKnownSunSystems):
    """The Sun's well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownSunSystems.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnWellKnownSunSystems._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownSunSystems._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownSunSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnWellKnownSunSystems.")

agcls.AgClassCatalog.add_catalog_entry("{855EB036-E71F-47F9-B27B-57247345282A}", AgCrdnWellKnownSunSystems)


class AgCrdnWellKnownSunAxes(IAgCrdnWellKnownSunAxes):
    """Well-known Sun's axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownSunAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnWellKnownSunAxes._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownSunAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownSunAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnWellKnownSunAxes.")

agcls.AgClassCatalog.add_catalog_entry("{7F786A33-8851-4FA4-A0CA-DC353170143E}", AgCrdnWellKnownSunAxes)


class AgCrdnWellKnownSystems(IAgCrdnWellKnownSystems):
    """Well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownSystems.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnWellKnownSystems._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownSystems._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnWellKnownSystems.")

agcls.AgClassCatalog.add_catalog_entry("{8C5101B3-3FDD-443D-A59F-B1E801873E0A}", AgCrdnWellKnownSystems)


class AgCrdnWellKnownAxes(IAgCrdnWellKnownAxes):
    """Represents well-known VGT Axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnWellKnownAxes._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnWellKnownAxes.")

agcls.AgClassCatalog.add_catalog_entry("{5E24B44A-B46D-4B9B-A22C-615EFAA73A6C}", AgCrdnWellKnownAxes)


class AgCrdnMethodCallAngleFindResult(IAgCrdnMethodCallResult, IAgCrdnAngleFindResult):
    """Represents result returned with IAgCrdnAngle.FindCoordinates method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAngleFindResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAngleFindResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAngleFindResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleFindResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAngleFindResult.")

agcls.AgClassCatalog.add_catalog_entry("{10a2d878-07e8-4a17-86d9-f91267332b29}", AgCrdnMethodCallAngleFindResult)


class AgCrdnMethodCallAngleFindWithRateResult(IAgCrdnMethodCallResult, IAgCrdnAngleFindWithRateResult):
    """Contains the results returned with IAgCrdnAngle.FindCoordinatesWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAngleFindWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAngleFindWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAngleFindWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleFindWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAngleFindWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{b6e274e3-92c4-4ee1-80ee-f5d80cd2bdc6}", AgCrdnMethodCallAngleFindWithRateResult)


class AgCrdnMethodCallAxesTransformResult(IAgCrdnMethodCallResult, IAgCrdnAxesTransformResult):
    """Contains the results returned with IAgCrdnAxes.TransformFrom method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAxesTransformResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAxesTransformResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAxesTransformResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesTransformResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAxesTransformResult.")

agcls.AgClassCatalog.add_catalog_entry("{d5e580c7-4a27-4249-8424-c74b7552d60c}", AgCrdnMethodCallAxesTransformResult)


class AgCrdnMethodCallAxesTransformWithRateResult(IAgCrdnMethodCallResult, IAgCrdnAxesTransformWithRateResult):
    """Contains the results returned with IAgCrdnAxes.TransformFromWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAxesTransformWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAxesTransformWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAxesTransformWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesTransformWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAxesTransformWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{30590e9a-ff5f-4d09-9282-32617361277f}", AgCrdnMethodCallAxesTransformWithRateResult)


class AgCrdnMethodCallAxesFindInAxesResult(IAgCrdnMethodCallResult, IAgCrdnAxesFindInAxesResult):
    """Contains the results returned with IAgCrdnAxes.FindInAxes method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAxesFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAxesFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAxesFindInAxesResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFindInAxesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAxesFindInAxesResult.")

agcls.AgClassCatalog.add_catalog_entry("{a03bd5b7-7178-47cf-bad3-a490b325b12e}", AgCrdnMethodCallAxesFindInAxesResult)


class AgCrdnMethodCallAxesFindInAxesWithRateResult(IAgCrdnMethodCallResult, IAgCrdnAxesFindInAxesWithRateResult):
    """Contains the results returned with IAgCrdnAxes.FindInAxesWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAxesFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAxesFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAxesFindInAxesWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFindInAxesWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAxesFindInAxesWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{aa8fab1e-798b-4fa0-97de-c772db073b01}", AgCrdnMethodCallAxesFindInAxesWithRateResult)


class AgCrdnMethodCallPlaneFindInAxesResult(IAgCrdnMethodCallResult, IAgCrdnPlaneFindInAxesResult):
    """Contains the results returned with IAgCrdnPlane.FindInAxes method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnPlaneFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnPlaneFindInAxesResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneFindInAxesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallPlaneFindInAxesResult.")

agcls.AgClassCatalog.add_catalog_entry("{3ad1d6cb-62bb-4d58-bbfb-42370c82041e}", AgCrdnMethodCallPlaneFindInAxesResult)


class AgCrdnMethodCallPlaneFindInAxesWithRateResult(IAgCrdnMethodCallResult, IAgCrdnPlaneFindInAxesWithRateResult):
    """Contains the results returned with IAgCrdnPlane.FindInAxesWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnPlaneFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnPlaneFindInAxesWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneFindInAxesWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallPlaneFindInAxesWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{385659fa-76a0-4fd8-ac65-45b9fc375d21}", AgCrdnMethodCallPlaneFindInAxesWithRateResult)


class AgCrdnMethodCallPlaneFindInSystemResult(IAgCrdnMethodCallResult, IAgCrdnPlaneFindInSystemResult):
    """Contains the results returned with IAgCrdnPlane.FindInSystem method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnPlaneFindInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnPlaneFindInSystemResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneFindInSystemResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallPlaneFindInSystemResult.")

agcls.AgClassCatalog.add_catalog_entry("{95a12be5-069b-450e-bec2-acb2dee9e956}", AgCrdnMethodCallPlaneFindInSystemResult)


class AgCrdnMethodCallPlaneFindInSystemWithRateResult(IAgCrdnMethodCallResult, IAgCrdnPlaneFindInSystemWithRateResult):
    """Contains the results returned with IAgCrdnPlane.FindInSystemWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInSystemWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnPlaneFindInSystemWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnPlaneFindInSystemWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneFindInSystemWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallPlaneFindInSystemWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{57eea690-8b67-4a20-a56a-386b59693b6f}", AgCrdnMethodCallPlaneFindInSystemWithRateResult)


class AgCrdnMethodCallPointLocateInSystemResult(IAgCrdnMethodCallResult, IAgCrdnPointLocateInSystemResult):
    """Contains the results returned with IAgCrdnPlane.FindInSystemWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnPointLocateInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnPointLocateInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnPointLocateInSystemResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPointLocateInSystemResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallPointLocateInSystemResult.")

agcls.AgClassCatalog.add_catalog_entry("{d1c86686-9f3c-40e1-bad0-f4d7fc4e4b38}", AgCrdnMethodCallPointLocateInSystemResult)


class AgCrdnMethodCallPointLocateInSystemWithRateResult(IAgCrdnMethodCallResult, IAgCrdnPointLocateInSystemWithRateResult):
    """Contains the results returned with IAgCrdnPoint.LocateInSystemWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnPointLocateInSystemWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnPointLocateInSystemWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnPointLocateInSystemWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPointLocateInSystemWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallPointLocateInSystemWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{7fb55c98-4c9b-4236-a8dc-8b645c43efe7}", AgCrdnMethodCallPointLocateInSystemWithRateResult)


class AgCrdnMethodCallSystemTransformResult(IAgCrdnMethodCallResult, IAgCrdnSystemTransformResult):
    """Contains the results returned with IAgCrdnSystem.TransformFrom and IAgCrdnSystem.TransformTo methods."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnSystemTransformResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnSystemTransformResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnSystemTransformResult._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemTransformResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallSystemTransformResult.")

agcls.AgClassCatalog.add_catalog_entry("{69867a9e-52f7-41ac-9305-1dd6d718dd9f}", AgCrdnMethodCallSystemTransformResult)


class AgCrdnMethodCallSystemTransformWithRateResult(IAgCrdnMethodCallResult, IAgCrdnSystemTransformWithRateResult):
    """Contains the results returned with IAgCrdnSystem.TransformFromWithRate and IAgCrdnSystem.TransformToWithRate methods."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnSystemTransformWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnSystemTransformWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnSystemTransformWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemTransformWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallSystemTransformWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{29682212-7424-423f-8abb-09e337d5a3c5}", AgCrdnMethodCallSystemTransformWithRateResult)


class AgCrdnMethodCallSystemFindInSystemResult(IAgCrdnMethodCallResult, IAgCrdnSystemFindInSystemResult):
    """Contains the results returned with IAgCrdnSystem.FindInSystem method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnSystemFindInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnSystemFindInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnSystemFindInSystemResult._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemFindInSystemResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallSystemFindInSystemResult.")

agcls.AgClassCatalog.add_catalog_entry("{a58affee-d2b4-4406-bdb4-1644ac88ff2d}", AgCrdnMethodCallSystemFindInSystemResult)


class AgCrdnMethodCallVectorFindInAxesResult(IAgCrdnMethodCallResult, IAgCrdnVectorFindInAxesResult):
    """Contains the results returned with IAgCrdnVector.FindInAxes method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnVectorFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnVectorFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnVectorFindInAxesResult._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFindInAxesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallVectorFindInAxesResult.")

agcls.AgClassCatalog.add_catalog_entry("{d1e45a85-ed27-499f-a507-9bda219f9c2e}", AgCrdnMethodCallVectorFindInAxesResult)


class AgCrdnMethodCallVectorFindInAxesWithRateResult(IAgCrdnMethodCallResult, IAgCrdnVectorFindInAxesWithRateResult):
    """Contains the results returned with IAgCrdnVector.FindInAxesWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnVectorFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnVectorFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnVectorFindInAxesWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFindInAxesWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallVectorFindInAxesWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{a2999b36-fde8-4cb2-aef1-fa1928a1b5d4}", AgCrdnMethodCallVectorFindInAxesWithRateResult)


class AgCrdnMethodCallAngleFindAngleWithRateResult(IAgCrdnMethodCallResult, IAgCrdnAngleFindAngleWithRateResult):
    """Contains the results returned with IAgCrdnAngle.FindAngleWithRate method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAngleFindAngleWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAngleFindAngleWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAngleFindAngleWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleFindAngleWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAngleFindAngleWithRateResult.")

agcls.AgClassCatalog.add_catalog_entry("{93ce2539-4115-4086-9076-e006c49881da}", AgCrdnMethodCallAngleFindAngleWithRateResult)


class AgCrdnMethodCallAngleFindAngleResult(IAgCrdnMethodCallResult, IAgCrdnAngleFindAngleResult):
    """Contains the results returned with IAgCrdnAngle.FindAngle method."""
    def __init__(self, sourceObject=None):
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
        IAgCrdnAngleFindAngleResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnMethodCallResult._private_init(self, intf)
        IAgCrdnAngleFindAngleResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnMethodCallResult._get_property(self, attrname) is not None: found_prop = IAgCrdnMethodCallResult._get_property(self, attrname)
        if IAgCrdnAngleFindAngleResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleFindAngleResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnMethodCallAngleFindAngleResult.")

agcls.AgClassCatalog.add_catalog_entry("{15dab968-8385-4f28-b60f-9567af54380e}", AgCrdnMethodCallAngleFindAngleResult)


class AgCrdnInterval(IAgCrdnInterval):
    """Represents an interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnInterval.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnInterval._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnInterval.")

agcls.AgClassCatalog.add_catalog_entry("{7825007C-4D30-46EC-A047-EAF6683C4187}", AgCrdnInterval)


class AgCrdnIntervalCollection(IAgCrdnIntervalCollection):
    """Represents a collection of intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnIntervalCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnIntervalCollection.")

agcls.AgClassCatalog.add_catalog_entry("{908714CE-1D69-4F68-875A-9B584CF8F2A7}", AgCrdnIntervalCollection)


class AgCrdnCentralBody(IAgCrdnCentralBody):
    """Represents an central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnCentralBody.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCentralBody._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCentralBody._get_property(self, attrname) is not None: found_prop = IAgCrdnCentralBody._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCentralBody.")

agcls.AgClassCatalog.add_catalog_entry("{9A0248DF-B126-4448-A653-CD5C28DC9229}", AgCrdnCentralBody)


class AgCrdnCentralBodyRefTo(IAgCrdnCentralBodyRefTo, IAgCrdnRefTo):
    """Represents a central body reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnCentralBodyRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCentralBodyRefTo._private_init(self, intf)
        IAgCrdnRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCentralBodyRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnCentralBodyRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCentralBodyRefTo.")

agcls.AgClassCatalog.add_catalog_entry("{AFB22A58-DB60-4A1B-B0D4-44916CACC759}", AgCrdnCentralBodyRefTo)


class AgCrdnCentralBodyCollection(IAgCrdnCentralBodyCollection):
    """A collection of central body names."""
    def __init__(self, sourceObject=None):
        IAgCrdnCentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCentralBodyCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCentralBodyCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnCentralBodyCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCentralBodyCollection.")

agcls.AgClassCatalog.add_catalog_entry("{E8951B8F-E457-4289-9125-5381515552C4}", AgCrdnCentralBodyCollection)


class AgCrdnCollection(IAgCrdnCollection):
    """A collection of VGT objects."""
    def __init__(self, sourceObject=None):
        IAgCrdnCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnCollection.")

agcls.AgClassCatalog.add_catalog_entry("{24B18D3A-675E-467D-A97C-5CD42EB6DC8D}", AgCrdnCollection)


class AgCrdnPointSamplingResult(IAgCrdnPointSamplingResult):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSamplingResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointSamplingResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSamplingResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointSamplingResult.")

agcls.AgClassCatalog.add_catalog_entry("{A3132149-15ED-4D7E-85A6-FD1B2BB80B1E}", AgCrdnPointSamplingResult)


class AgCrdnPointSamplingInterval(IAgCrdnPointSamplingInterval):
    """The interface represents an interval with the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointSamplingInterval._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSamplingInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointSamplingInterval.")

agcls.AgClassCatalog.add_catalog_entry("{8B7546E8-0228-4269-92D1-B3C186AF18EF}", AgCrdnPointSamplingInterval)


class AgCrdnPointSamplingIntervalCollection(IAgCrdnPointSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnPointSamplingIntervalCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnPointSamplingIntervalCollection.")

agcls.AgClassCatalog.add_catalog_entry("{3F6CF6B1-7192-4960-927D-1FC328122E59}", AgCrdnPointSamplingIntervalCollection)


class AgCrdnAxesSamplingResult(IAgCrdnAxesSamplingResult):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSamplingResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesSamplingResult._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSamplingResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesSamplingResult.")

agcls.AgClassCatalog.add_catalog_entry("{54622168-5440-4C86-9539-A0CA336E554B}", AgCrdnAxesSamplingResult)


class AgCrdnAxesSamplingInterval(IAgCrdnAxesSamplingInterval):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesSamplingInterval._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSamplingInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesSamplingInterval.")

agcls.AgClassCatalog.add_catalog_entry("{069BCA07-B5AB-4A46-A508-AFE218E21B2F}", AgCrdnAxesSamplingInterval)


class AgCrdnAxesSamplingIntervalCollection(IAgCrdnAxesSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAgCrdnAxesSamplingIntervalCollection._private_init(self, intf)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AgCrdnAxesSamplingIntervalCollection.")

agcls.AgClassCatalog.add_catalog_entry("{4AD4C296-E643-4CB6-A34A-D33748117EEF}", AgCrdnAxesSamplingIntervalCollection)



################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################
